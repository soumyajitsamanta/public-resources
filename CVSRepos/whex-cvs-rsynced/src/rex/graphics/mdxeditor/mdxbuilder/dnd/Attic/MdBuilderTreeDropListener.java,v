head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2006.01.13.12.21.15;	author igorludi;	state dead;
branches;
next	1.1;

1.1
date	2005.10.18.14.04.41;	author igorludi;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@package rex.graphics.mdxeditor.mdxbuilder.dnd;

import java.awt.datatransfer.*;
import java.awt.dnd.*;

import rex.graphics.dimensiontree.elements.*;
import rex.graphics.mdxeditor.mdxbuilder.*;
import rex.graphics.mdxeditor.mdxbuilder.nodes.*;
import rex.graphics.mdxeditor.mdxfunctions.*;
import rex.utils.*;

/**
 * This is a tree drop listener. It listens to the drop events and does two things:
* <br>- listens and decides whether to accept drop (by calling the MBTNode's: <code> public boolean acceptDrop(DataFlavor flavor))</code>
* <br>- handles drop by forwarding the data to MBTNode's  <code> public void handleDrop(  Object droppedData
                          , DefaultMutableTreeNode containerNode
                          , DefaultTreeModel treeModel);</code>
* @@see rex.graphics.mdxeditor.mdxbuilder.nodes.MBTNode
 * @@author Igor Mekterovic
 * @@version 0.3
 */
public class MdBuilderTreeDropListener implements DropTargetListener{

   MdxBuilderTree mdxBuilderTree;
   public MdBuilderTreeDropListener(MdxBuilderTree _mdxBuilderTree) {
       mdxBuilderTree = _mdxBuilderTree;
   }
   /**
    * Decides wether to accept drag.
    * @@param dtde DropTargetDragEvent
    */
   public void dragEnter(DropTargetDragEvent dtde) {
      if (! acceptDrop(dtde)) {
//         S.out("enter not ok");
         dtde.rejectDrag();
         return;
      }
      dtde.acceptDrag(dtde.getDropAction());

   }

   /**
    * Handler. Does nothing.
    * @@param dte DropTargetEvent
    */
   public void dragExit(DropTargetEvent dte) {}


   /**
    * Decides wether to accept drag.
    * @@param dtde DropTargetDragEvent
    */
   public void dragOver(DropTargetDragEvent dtde) {
//      System.out.println("dtlistener dragOver");
      if (!acceptDrop(dtde)) {
//         S.out("enter not ok");
//         DropLabel.this.borderColor = Color.red;
//         showBorder(true);
         dtde.rejectDrag();
//         dtde.getDropTargetContext().dropComplete(true);
//         System.out.println("drop complete set");
         return;
      }
//      DropLabel.this.borderColor = Color.green;
//      showBorder(true);
//      S.out("dt enter: accepting " + dtde.getDropAction());
      dtde.acceptDrag(dtde.getDropAction());
   }


   /**
    * Decides wether drop is acceptable. Used by dragOver and dragEnter handlers.
    * @@param dtde DropTargetDragEvent
    * @@return boolean
    */
   private boolean acceptDrop(DropTargetDragEvent dtde){
      try {
          // Ok, get the object and try to figure out what it is
         DataFlavor[] flavors = dtde.getCurrentDataFlavors();
         String s;
         for (int i = 0; flavors!=null && i < flavors.length; i++) {
//            S.out("calling acceptDropOnPoint for " + flavors[i].getMimeType());
            if (mdxBuilderTree.acceptDropOnPoint(dtde.getLocation(), flavors[i])) {
               return true;
            }
         }
      } catch (Exception e) {
          e.printStackTrace();
      }
      return false;
   }

   /**
    * Handler. Does nothing.
    * @@param dtde DropTargetDragEvent
    */
   public void dropActionChanged(DropTargetDragEvent dtde) {}


   /**
    * Handles drop. Forwards the dropped data to appropriate MBTNode.
    * @@see rex.graphics.mdxeditor.mdxbuilder.nodes.MBTNode
    * @@param dtde DropTargetDropEvent
    */
   public void drop(DropTargetDropEvent dtde) {
       try {
           // Ok, get the dropped object and try to figure out what it is
          Transferable tr = dtde.getTransferable();
          DataFlavor[] flavors = tr.getTransferDataFlavors();
          String s;
          for (int i = 0; i < flavors.length; i++) {
//             System.out.println("\n\nPossible flavor: " + flavors[i].getMimeType()
//                                + "\n data = " + tr.getTransferData(flavors[i])
//                                + "\nisFlavorSerializedObjectType()=" + (flavors[i].isFlavorSerializedObjectType())
//                                + "\nclass = " + tr.getTransferData(flavors[i]).getClass().getName());
//           doesn't have to be:   flavors[i].isFlavorSerializedObjectType() && (because i'm using local JVM dnd)
             if (  (tr.getTransferData(flavors[i]) instanceof DimensionTreeElement)
                || (tr.getTransferData(flavors[i]) instanceof MBTNode)
                || (tr.getTransferData(flavors[i]) instanceof MdxFunction)) {

                dtde.acceptDrop(DnDConstants.ACTION_COPY);

                mdxBuilderTree.handleDropOnPoint(dtde.getLocation(), tr.getTransferData(flavors[i]));
//                S.out("droppedData = " + droppedData);
                dtde.dropComplete(true);
                return;
             }
          }
          S.out("Drop failed: " + dtde);
          dtde.rejectDrop();
          dtde.dropComplete(true);
       } catch (Exception e) {
           e.printStackTrace();
           dtde.rejectDrop();
           dtde.dropComplete(true);
       }
   }

}
@


1.1
log
@*** empty log message ***
@
text
@@

