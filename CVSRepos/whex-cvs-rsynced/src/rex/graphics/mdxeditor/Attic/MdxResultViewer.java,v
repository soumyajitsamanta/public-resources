head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2006.01.13.12.21.15;	author igorludi;	state dead;
branches;
next	1.4;

1.4
date	2005.10.18.14.04.40;	author igorludi;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.18.13.40.38;	author igorludi;	state dead;
branches;
next	1.2;

1.2
date	2005.10.18.13.31.11;	author igorludi;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.28.14.11.07;	author igorludi;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@package rex.graphics.mdxeditor;

import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import org.tempuri.type.*;
import rex.graphics.*;
import rex.graphics.charts.*;
import rex.graphics.dimensiontree.*;
import rex.graphics.dimensiontree.dnd.*;
import rex.graphics.filtertree.*;
import rex.graphics.filtertree.elements.*;
import rex.metadata.*;
import rex.metadata.resultelements.*;
import rex.utils.*;

/**
 * Displays a result of an MDX query.
 *
 * @@see rex.graphics.CubeExplorer
 * @@see rex.graphics.mdxeditor.MdxResultPage
 * @@author Igor Mekterovic
 * @@version 0.3
 */
public class MdxResultViewer extends JPanel implements IViewer{
   private JSplitPane splitPane;
   private JPanel rightPane;
   private JPanel leftPane;
   private LinkedList filterTrees;
   private LinkedList chartTabs;
   private TreeDragSource ds;
   private Query q;
   private LinkedList pages;
   private StatusBar statusBar;
   private ClsXMLAProxDiscoverRestrictions restrictions;
   private ClsXMLAProxDiscoverProperties properties;
   private ClsXMLAProxExecuteProperties execProperties;
   private ServerMetadata smd;
   private ClsXMLAProxExecuteResult r;
   private ExecuteResult er;
   private static int MAX_CHAPTER_COUNT = 10;
   private boolean errorOccured;
   private String errorMessage;
   private CubeExplorer2 cubeExplorer;
   private String mdxQuery;
   private static ImageIcon tableIcon, chartIcon;
   private boolean  showRowTotalsOn, showColumnTotalsOn;
   private MdxEditor parent;


   static {
      tableIcon = S.getAppIcon("table.gif");
      chartIcon = S.getAppIcon("chart.gif");
   }

   /**
    * Full constructor.
    *
    * @@param _restrictions ClsXMLAProxDiscoverRestrictions
    * @@param _properties ClsXMLAProxDiscoverProperties
    * @@param _smd ServerMetadata
    * @@param _mdxQuery String
    * @@param _statusBar StatusBar
    * @@param _showRowTotalsOn boolean
    * @@param _showColumnTotalsOn boolean
    * @@param _parent MdxEditor
    */
   public MdxResultViewer(
                     ClsXMLAProxDiscoverRestrictions _restrictions
                  ,  ClsXMLAProxDiscoverProperties   _properties
                  ,  ServerMetadata _smd
                  ,  String _mdxQuery
                  ,  StatusBar _statusBar
                  ,  boolean _showRowTotalsOn
                  ,  boolean _showColumnTotalsOn
                  ,  MdxEditor _parent){
      this(_restrictions, _properties, _smd);
      mdxQuery           = _mdxQuery;
      statusBar          = _statusBar;
      showRowTotalsOn    = _showRowTotalsOn;
      showColumnTotalsOn = _showColumnTotalsOn;
      parent             = _parent;
      refreshQuery();

   }

   /**
    * Constructor used for testing.
    *
    * @@param _restrictions ClsXMLAProxDiscoverRestrictions
    * @@param _properties ClsXMLAProxDiscoverProperties
    * @@param _smd ServerMetadata
    */
   public MdxResultViewer( ClsXMLAProxDiscoverRestrictions _restrictions
                  ,  ClsXMLAProxDiscoverProperties   _properties
                  ,  ServerMetadata _smd){
      restrictions = _restrictions;
      properties   = _properties;
      smd = _smd;
      execProperties = new ClsXMLAProxExecuteProperties();
      ClsXMLAProxExecutePropertyList exPropList = new ClsXMLAProxExecutePropertyList();
      exPropList.setCatalog(properties.getPropertyList().getCatalog());
      exPropList.setDataSourceInfo(properties.getPropertyList().getDataSourceInfo());
      execProperties.setPropertyList(exPropList);

      q = new Query(_restrictions.getRestrictionList().getCubeName(), this);

      rightPane = new JPanel(){

         {
            setOpaque(false);
         } // instance initializer

         public void paintComponent(Graphics g) {
            S.paintBackground(g, this);
            super.paintComponent(g);
         }
      };

      rightPane.setLayout(new BoxLayout(rightPane, BoxLayout.Y_AXIS));
//      rightPane.setBorder(BorderFactory.createLineBorder(Color.GREEN, 1));



      pages = new LinkedList();
      MdxResultPage c = new MdxResultPage();
      c.setCurrent(true);
      pages.add(c);
      rightPane.add(c);

//      leftPane = new JPanel();
//      leftPane.setLayout(new BorderLayout());
//      leftPane.setPreferredSize(new Dimension(0,0));
//      leftPane.setMaximumSize(new Dimension(0,Short.MAX_VALUE));

      this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
//      this.add(leftPane);
//      this.add(new JScrollPane(rightPane));
      this.add(rightPane);

   }

   /**
    * Refreshes a MDX query:
    * Query is executed, while refreshing progress bar in another thread. Afterwards, depending on the result of the query,
    * CubeExplorer objects and MdxResultPage objests are created and displayed.
    * <br> If there are members on PAGES axis, result is sliced along that axis and each slice (MdxResultPage) is displayed in separate tab.
    */
   public void refreshQuery(){
//      mdxQuery = _mdxquery;
      if (q.canExecute()) {
         mdxQuery = q.getQuery();
         parent.appendGeneratedMDX("\n\n-- *** Generated(" + GregorianCalendar.getInstance().getTime() + "):  *** \n" + mdxQuery);
      }
      // else use mdxQuery that was passed on in the contructor, i.e. query that user typed in
      if (true){
         statusBar.startServerClock();
         statusBar.setStatus("Executing query...");
         errorOccured = false;
         statusBar.progressJob(new Runnable(){
            public void run(){
               try{
                  r = smd.execute(mdxQuery, execProperties);
               }catch(Exception e){
                  errorOccured = true;
                  errorMessage = e.getMessage();
                  e.printStackTrace();
//                  statusBar.setStatus("An error occured while executing a query :(");
                  return;
               }
            }
         }, StatusBar.JOB_TYPE_CRITICAL);
         statusBar.stopServerClock();
         if (!errorOccured){
            statusBar.setStatus("Query is succesfully executed, preparing display...");
            statusBar.startClientClock();

            statusBar.progressJob(new Runnable() {
               public void run() {
                  er = new ExecuteResult(r, q);
//                  S.out("DEBUG: er.getAxis(Axis1).getTupleCount()=" + er.getAxis("Axis1").getTupleCount());
                  if (!er.isValid()) {
                     if (er.getAxis("Axis1").getTupleCount() == 0) {
                        statusBar.setStatus("Invalid result, attempting recovery (no data on Axis1).");
                        errorOccured = true;
//                        q.clearRowAxis();
                     }
                     else if (er.getAxis("Axis0").getTupleCount() == 0) {
                        statusBar.setStatus("Invalid result, attempting recovery (no data on Axis0).");
                        errorOccured = true;
//                        q.clearColumnAxis();
                     }
                     //((Chapter)pages.getFirst()).refreshDisplay();
                     return;
                  }
//                  q.updateQueryWithResults(er);

                  rightPane.removeAll();
                  JComponent rightPaneTableContent;
                  int chapterCount;
                  if (er.getAxis("Axis2") != null) {
                    // *****************        THERE ARE PAGES !!!  *************************/
                     chapterCount = er.getAxis("Axis2").getTupleCount();
                     pages.clear();
                     // here we make different cube slicers and make new cube explorers
                     // one for each chapter
                     final JTabbedPane jtp = new JTabbedPane(JTabbedPane.TOP);
                     for (int cc = 0; cc < chapterCount && cc < MAX_CHAPTER_COUNT; cc++) {
                        CubeSlicer cs = new CubeSlicer( (short) 1
                           , (short) 0
                           , new short[] {2}
                           , new Tuple[] {er.getAxis("Axis2").getTupleAt(cc)}
                           );
                        cubeExplorer = new CubeExplorer2(er, cs, showColumnTotalsOn, showRowTotalsOn);
                        cubeExplorer.setMaximumSize(new Dimension(Short.MAX_VALUE, cubeExplorer.getHeight()));

                        MdxResultPage c = new MdxResultPage(cubeExplorer);
                        c.setMaximumSize(new Dimension(  Short.MAX_VALUE
                                                       , cubeExplorer.getPrefferedHeight() + MdxResultPage.getAdditionalHeight()));
                        pages.add(c);
                        // this is heavy - now I have to check if there are any charts to display
                        // chart tabs ARE INSIDE page tabs!
                        if (chartTabs != null && chartTabs.size() > 0) {
                           // THERE ARE NO CHARTS SO FAR IN THE MDX EDITOR
                           JTabbedPane chartTabbedPane = new JTabbedPane(JTabbedPane.RIGHT);
                           chartTabbedPane.addTab(null, tableIcon, c);
                           Iterator it = chartTabs.iterator();
                           Integer type;
                           while (it.hasNext()) {
                              type = (Integer) it.next();
                              // I'm creating a NEW chart that is the same type as the one in the chartTabs
                              // In the case when I have pages (e.g. 3 pages) and charts (e.g. 2 charts)
                              // I will create 3*2 charts.
                              Chart pageChart  = new Chart(er, cs, type.intValue());
                              chartTabbedPane.addTab(null, pageChart.getIcon(), pageChart);
                           }

                           jtp.addTab(er.getAxis("Axis2").getTupleAt(cc).getShortCaption()
                                      , null
                                      , chartTabbedPane
                                      , er.getAxis("Axis2").getTupleAt(cc).getToolTip()
                                      );

                        }else{
                           JPanel holder = new JPanel(){
                              {
                                 setOpaque(false);
                              } // instance initializer

                              public void paintComponent(Graphics g) {
                                 S.paintBackground(g, this);
                                 super.paintComponent(g);
                              }
                           };
                           holder.setLayout(new BoxLayout(holder, BoxLayout.Y_AXIS));
//                           holder.setBorder(BorderFactory.createLineBorder(Color.GREEN, 1));
                           holder.add(c);

                           jtp.addTab( er.getAxis("Axis2").getTupleAt(cc).getShortCaption()
                                      , null
                                      , holder
                                      , er.getAxis("Axis2").getTupleAt(cc).getToolTip()
                                      );
                        }

                     }
//                     jtp.setMaximumSize(new Dimension(  Short.MAX_VALUE
//                                                       , cubeExplorer.getPrefferedHeight() + MdxResultPage.getAdditionalHeight()));
                     jtp.addMouseListener(new PageLabelPopUpListener(jtp));
                     rightPane.add(jtp);
//                     rightPane.add(Box.createVerticalGlue());


                  }else{
                     // *****************        NO PAGES  *************************/
                     chapterCount = 1;
                     pages.clear();

                     CubeSlicer cs = new CubeSlicer( (short) 1, (short) 0);
                     cubeExplorer = new CubeExplorer2(er, cs, showColumnTotalsOn, showRowTotalsOn);
                     cubeExplorer.setMaximumSize(new Dimension(Short.MAX_VALUE, cubeExplorer.getPrefferedHeight()));

                     MdxResultPage c = new MdxResultPage(cubeExplorer);
                     c.setMaximumSize(new Dimension(  Short.MAX_VALUE
                                                       , cubeExplorer.getPrefferedHeight() + MdxResultPage.getAdditionalHeight()));
                     c.setCurrent(true);
                     pages.add(c);

                     if (chartTabs != null && chartTabs.size()>0){
                        JTabbedPane chartTabbedPane = new JTabbedPane(JTabbedPane.RIGHT);
                        chartTabbedPane.addTab(null, tableIcon, c);
                        Iterator it = chartTabs.iterator();
                        Integer type;
                        Chart chart;
                        while (it.hasNext()) {
                           type = (Integer) it.next();
                           chart = new Chart(er, cs, type.intValue());
                           chartTabbedPane.addTab(null, chart.getIcon(), chart);
                        }
                        rightPane.add(chartTabbedPane);
                     }
                     else {
                        rightPane.add(c);
//                        rightPane.add(Box.createVerticalGlue());
                     }
                  }


                  rightPane.repaint();
                  rightPane.invalidate();
                  rightPane.revalidate();
                  ListIterator it = pages.listIterator();
                  MdxResultPage currentMdxResultPage;
                  while (it.hasNext()) {
                     if ( ( (MdxResultPage) it.next()).isCurrent()) {
                        ( (MdxResultPage) it.previous()).getCubeExplorer().setPrefferedDividerLocation();
                        break;
                     }
                  }
               }
            }, StatusBar.JOB_TYPE_NORMAL);

            statusBar.setDataCellsNumber(er.getAxis("Axis1").getTupleCount(),
                                         er.getAxis("Axis0").getTupleCount());
            statusBar.stopClientClock();
            if (!errorOccured) statusBar.setStatus("Ready.");
            q.setQuery(er);
         }else{
            JOptionPane.showMessageDialog(  null
                                          , "An error occured while executing a query:\n" + errorMessage
                                          , "Executing query"
                                          , JOptionPane.ERROR_MESSAGE);
            statusBar.setStatus("Error occured while executing a MDX query. Ready.");
         }


      }else{
         // refresh EmptyResultTable
         ((MdxResultPage)pages.getFirst()).refreshDisplay();
      }

   }

   /**
    * Adds specified member to the filter(Tree). Returns the tree model of the newly instantiated FilterTree
    * @@see rex.graphics.filtertree.FilterTree
    * @@param filterMember Member
    * @@return FilterTreeModel
    */
   public FilterTreeModel addMemberToFilter(Member filterMember){
      if (filterTrees == null){
         filterTrees = new LinkedList();
      }
      LinkedList eml = new LinkedList();
      eml.add(filterMember);
      FilterTree filterTree = new FilterTree( restrictions
                                             , properties
                                             , smd
                                             , q
                                             , ((DimensionTreeModel)parent.getDimensionTree().getTree().getModel()).getDimensionTreeElement(filterMember.getDimensionUniqueName())
                                             , eml
                                             , this);
      filterTrees.add(filterTree);
      refreshLeftPane();
      return (FilterTreeModel)filterTree.getTree().getModel();
   }

   /**
    * Removes the specified FilterTree.
    * @@param filterToDrop FilterTree
    */
   public void dropFilterTree(FilterTree filterToDrop){
      ListIterator it = filterTrees.listIterator();
      while(it.hasNext()){
         if((FilterTree)it.next() == filterToDrop){
            it.previous();
            it.remove();
            refreshLeftPane();
            return;
         }
      }
      S.out("assert: Viewer:dropFilterTree:Couldn't find filter to drop!");
   }

   /**
    * Refreshes the display of Filter tree(s).
    */
   public void refreshFilterDisplay(){
      refreshLeftPane();
   }

   /**
    * Refreshes the display of Filter tree(s).
    */
   private void refreshLeftPane(){
      if (filterTrees != null && filterTrees.size()>0){
         leftPane.removeAll();
         // the whole display depends on the FIRST filterTree - the first one is the boss !
         if (!((FilterTree)filterTrees.getFirst()).isDisplayedInTab()){
            JPanel filtersPane = new JPanel();
            filtersPane.setLayout(new BoxLayout(filtersPane, BoxLayout.Y_AXIS));
            Iterator it = filterTrees.iterator();
            while (it.hasNext()) {
               filtersPane.add( (JPanel) it.next());
            }
            leftPane.add(new JScrollPane(filtersPane));
         }else{
            JTabbedPane dimFilterTabbedPane = new JTabbedPane(JTabbedPane.LEFT);
//            dimFilterTabbedPane.addTab(null
//                                   , DimensionElement.getDimensionIcon()
//                                   , parent.getDimensionTree()
//                                   , "Dimension tree used for browsing and generating queries."
//                                   );
            Iterator it = filterTrees.iterator();
            int i=1;
            FilterTree ft;
            while (it.hasNext()) {
               ft = (FilterTree)it.next();
               dimFilterTabbedPane.addTab(   null // "Filter" + i
                                           , FilterTreeRootElement.getFilterIcon()
                                           , ft
                                           , ft.getCaption());
               i++;
            }
            leftPane.add(dimFilterTabbedPane);
         }
         leftPane.setPreferredSize(new Dimension(200, this.getHeight()));
         leftPane.setMaximumSize(new Dimension(250, Short.MAX_VALUE));
      }else{
         leftPane.removeAll();
//         leftPane.add(parent.getDimensionTree(), BorderLayout.CENTER);
         leftPane.setPreferredSize(new Dimension(0,0));
         leftPane.setMaximumSize(new Dimension(0,Short.MAX_VALUE));
      }
      this.invalidate();
      this.revalidate();
      this.repaint();
   }

   /**
    * Returns true if error occured during the execution of the query, otherwise false.
    * @@return boolean
    */
   public boolean getErrorOccured(){
      return errorOccured;
   }

   /**
    * Forwards the specified value to the CubeExplorer to turn on/off collumn totals.
    * @@see rex.graphics.CubeExplorer
    * @@param _showColumnTotalsOn boolean
    */
   void setShowColumnTotalsOn(boolean _showColumnTotalsOn){
      if (cubeExplorer != null){
         cubeExplorer.setShowColumnTotalsOn(_showColumnTotalsOn);
      }
   }

   /**
    * Forwards the specified value to the CubeExplorer to turn on/off row totals.
    * @@param _showRowTotalsOn boolean
    */
   void setShowRowTotalsOn(boolean _showRowTotalsOn){
      if (cubeExplorer != null){
         cubeExplorer.setShowRowTotalsOn(_showRowTotalsOn);
      }
   }

   /**
    * Does nothing.
    * @@param elementToEnable QueryElement
    */
   public void enableTreeElements( QueryElement elementToEnable){
//      do nothing  -> this is editor, so everythin goes !
   }

   /**
    * Inner class that handles pop-up display and pop-up actions for the PAGES members (available as right-click on the tab labels)
    * @@author Igor Mekterovic
    * @@version 0.3
    */
   class PageLabelPopUpListener extends MouseAdapter implements ActionListener{
      JTabbedPane jtp;
      JPopupMenu popup;
      JMenuItem menuItem;
      int idx;
      PageLabelPopUpListener(JTabbedPane _jtp){
         jtp = _jtp;
         popup = new JPopupMenu();

         menuItem = new JMenuItem( (String) TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.KEEP_THIS_MEMBER_ONLY));
         menuItem.addActionListener(this);
         popup.add(menuItem);

         menuItem = new JMenuItem( (String) TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.REMOVE_MEMBER_FROM_QUERY));
         menuItem.addActionListener(this);
         popup.add(menuItem);

         menuItem = new JMenuItem( (String) TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.REMOVE_DIMENSION_FROM_QUERY));
         menuItem.addActionListener(this);
         popup.add(menuItem);

         menuItem = new JMenuItem( (String) TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.SEND_MEMBER_TO_FILTER));
         menuItem.addActionListener(this);
         popup.add(menuItem);


      }
      public void mouseClicked(MouseEvent e) {

         if (SwingUtilities.isRightMouseButton(e)) {

            idx = jtp.indexAtLocation(e.getX(), e.getY());
            popup.show(e.getComponent()
                       , e.getX()
                       , e.getY());
         }
         if (e.isPopupTrigger()) {
//            S.out("e.getX()=" + e.getX()
//                  + "e.getY()=" + e.getY()
//                  + "point = " + e.getPoint()
//                  + " E = " + e);
         }
      }

      public void actionPerformed(ActionEvent e){
         int i = 0;
         // To do:
         if (e.getActionCommand().equals((String)TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.REMOVE_DIMENSION_FROM_QUERY))){
            q.removePageDimensionFromQuery(er.getAxis("Axis2").getTupleAt(idx).getMemberAt(0));
         }else if (e.getActionCommand().equals((String)TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.REMOVE_MEMBER_FROM_QUERY))){
            q.removePageMemberFromQuery(er.getAxis("Axis2").getTupleAt(idx).getMemberAt(0));
         }else if (e.getActionCommand().equals((String)TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.KEEP_THIS_MEMBER_ONLY))){
            q.keepThisMemberOnlyOnPages(er.getAxis("Axis2").getTupleAt(idx).getMemberAt(0));
         }else if (e.getActionCommand().equals((String)TupleMemberLabelPopUpActions.popUpCaptions.get(TupleMemberLabelPopUpActions.SEND_MEMBER_TO_FILTER))){
            q.addPageMemberToFilter(er.getAxis("Axis2").getTupleAt(idx).getMemberAt(0));
         }

      }



   }

   /**
    * Main method used for testing the class
    * @@param args String[]
    */
   public static void main(String[] args) {
     ServerMetadata svm = new ServerMetadata("http://localhost:8080/xmla/msxisapi.dll");

     ClsXMLAProxDiscoverRestrictions restrictions = new ClsXMLAProxDiscoverRestrictions();
     ClsXMLAProxDiscoverProperties properties     = new ClsXMLAProxDiscoverProperties();
     ClsXMLAProxDiscoverPropertyList pl = new ClsXMLAProxDiscoverPropertyList();
     ClsXMLAProxDiscoverRestrictionList rl = new ClsXMLAProxDiscoverRestrictionList();

     // only cube element could have started an explore action:
     // (for the time being, if I find a meaning in exploring catalogs and datasources, I'll move those getCubeName annd getCatalogName to interface)

     pl.setDataSourceInfo("Local Analysis Server");
     rl.setCatalog("Foodmart 2000");
     rl.setCubeName("Sales");

     restrictions.setRestrictionList(rl);

     pl.setCatalog("Foodmart 2000");
     pl.setFormat("Tabular");
     pl.setContent("SchemaData");

     properties.setPropertyList(pl);


     UIPropertyManager  pm = new UIPropertyManager();
     pm.setSystemUI();

     MdxResultViewer v = new MdxResultViewer(restrictions, properties , svm, "SELECT"
            + " NON EMPTY"
            + "{ {[Measures].Members}} ON COLUMNS, "
            + " NON EMPTY "
            + "{[Gender].[Gender].Members} ON ROWS,"
            + ""
            + "{ Time.Year.Members} on PAGES"
            + " FROM Sales "
            , new StatusBar(), false, false, null);


     JFrame frame2 = new JFrame("Test viewer");

     frame2.getContentPane().add(v, BorderLayout.CENTER );

     frame2.addWindowListener(new WindowAdapter() {
        public void windowClosing(WindowEvent e) {
           System.exit(0);
        }
     });
     frame2.pack();
     frame2.setExtendedState(frame2.MAXIMIZED_BOTH);
     frame2.setVisible(true);

  }


}
@


1.4
log
@*** empty log message ***
@
text
@@


1.3
log
@*** empty log message ***
@
text
@@


1.2
log
@*** empty log message ***
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d3 1
a3 5


import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JFrame;
d6 4
a9 7
import javax.swing.JPanel;
import rex.metadata.ServerMetadata;


import javax.swing.ImageIcon;

import rex.utils.S;
d11 3
d15 2
a16 38

import javax.swing.JPopupMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import org.tempuri.type.ClsXMLAProxDiscoverRestrictions;
import org.tempuri.type.ClsXMLAProxDiscoverProperties;
import org.tempuri.type.ClsXMLAProxDiscoverPropertyList;
import org.tempuri.type.ClsXMLAProxDiscoverRestrictionList;

import rex.graphics.dimensiontree.dnd.TreeDragSource;

import org.tempuri.type.ClsXMLAProxExecuteResult;
import org.tempuri.type.ClsXMLAProxExecuteProperties;
import org.tempuri.type.ClsXMLAProxExecutePropertyList;
import rex.utils.UIPropertyManager;
import javax.swing.BoxLayout;

import java.util.LinkedList;

import rex.metadata.resultelements.Tuple;
import javax.swing.JTabbedPane;
import java.util.Iterator;
import java.util.ListIterator;
import rex.metadata.resultelements.Member;
import rex.graphics.filtertree.elements.FilterTreeRootElement;
import javax.swing.JComponent;
import rex.graphics.charts.Chart;

import java.util.ArrayList;
import javax.swing.SwingUtilities;
import rex.graphics.StatusBar;
import rex.graphics.TupleMemberLabelPopUpActions;
import rex.graphics.IViewer;
import rex.graphics.filtertree.FilterTreeModel;
import rex.graphics.filtertree.FilterTree;
import rex.graphics.dimensiontree.DimensionTreeModel;
import java.util.GregorianCalendar;
import rex.graphics.*;
d19 6
a24 6
 * <p>Title: WHEX</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: </p>
 * @@author igor
 * @@version 1.0
d45 1
a45 1
   private CubeExplorer cubeExplorer;
d57 12
a68 1

d88 7
a94 1

a108 4
//      dimTree = new DimensionTree(_restrictions, _properties, _smd, q);
//
//
//      ds = new TreeDragSource(dimTree.getTree(), DnDConstants.ACTION_COPY_OR_MOVE);
d122 3
a124 1
      rightPane.setBackground(Color.BLACK);
d132 4
a135 13
      leftPane = new JPanel();
      leftPane.setLayout(new BorderLayout());
      leftPane.setPreferredSize(new Dimension(0,0));
      leftPane.setMaximumSize(new Dimension(0,Short.MAX_VALUE));
//      leftPane.add(dimTree, BorderLayout.CENTER);

//      splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT
//                                 , leftPane
//                                 , );
//      splitPane.setContinuousLayout(false);
//      splitPane.setOneTouchExpandable(true);
//      splitPane.setDividerSize(8);
//      splitPane.setDividerLocation((int)dimTree.getMinimumSize().getWidth());
a136 2
//      this.setLayout(new BorderLayout());
//      this.add(new JScrollPane(rightPane), BorderLayout.CENTER);
d138 3
a140 2
      this.add(leftPane);
      this.add(new JScrollPane(rightPane));
d143 7
d215 1
a215 1
                        cubeExplorer = new CubeExplorer(er, cs, showColumnTotalsOn, showRowTotalsOn);
d219 2
d225 1
d246 13
d260 1
a260 2
                           jtp.addTab(er.getAxis("Axis2").getTupleAt(cc).
                                      getShortCaption()
d262 2
a263 3
                                      , c
                                      ,
                                      er.getAxis("Axis2").getTupleAt(cc).getToolTip()
d268 2
d272 1
d281 3
a283 2
                     cubeExplorer = new CubeExplorer(er, cs, showColumnTotalsOn, showRowTotalsOn);
                     cubeExplorer.setMaximumSize(new Dimension(Short.MAX_VALUE, cubeExplorer.getHeight()));
d285 2
d305 1
d345 6
d368 5
d385 4
d392 4
d441 4
d448 6
d460 4
d470 4
d478 5
a482 1

d511 1
a511 1
//         S.out("mouse clicked");
d513 1
a513 1
//            S.out("idx=" + jtp.indexAtLocation(e.getX(), e.getY())); //
d546 4
a549 1

d551 1
a551 1
     ServerMetadata svm = new ServerMetadata("http://skladiste.zpm.fer.hr/xmla/msxisapi.dll");
d581 3
a583 1
            + "{[Gender].[Gender].Members} ON ROWS"
@

