head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2006.01.13.12.21.15;	author igorludi;	state dead;
branches;
next	1.4;

1.4
date	2005.10.18.14.04.40;	author igorludi;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.18.13.40.38;	author igorludi;	state dead;
branches;
next	1.2;

1.2
date	2005.10.18.13.31.11;	author igorludi;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.28.14.11.07;	author igorludi;	state Exp;
branches;
next	;


desc
@@


1.5
log
@*** empty log message ***
@
text
@package rex.graphics.mdxeditor;

import javax.swing.JPanel;
import javax.swing.JFrame;
import java.awt.BorderLayout;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import javax.swing.JTextArea;
import javax.swing.JSplitPane;
import javax.swing.JScrollPane;
import javax.swing.JLabel;
import java.awt.Font;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JPopupMenu;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.dom.DOMSource;
import rex.utils.*;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import javax.swing.JTabbedPane;
import org.tempuri.type.ClsXMLAProxDiscoverProperties;
import rex.metadata.ServerMetadata;
import org.tempuri.type.ClsXMLAProxDiscoverRestrictions;
import org.tempuri.type.ClsXMLAProxDiscoverPropertyList;
import org.tempuri.type.ClsXMLAProxDiscoverRestrictionList;
import java.awt.event.KeyEvent;
import java.awt.event.KeyAdapter;
import java.util.HashMap;
import rex.graphics.StatusBar;
import java.awt.Dimension;
import java.awt.Toolkit;
import rex.graphics.dimensiontree.DimensionTree;
import rex.graphics.mdxeditor.mdxbuilder.MdxBuilderTree;
import rex.graphics.mdxeditor.mdxbuilder.dnd.DimensionTreeToMBTDragSource;
import java.awt.dnd.DnDConstants;
import rex.graphics.mdxeditor.mdxbuilder.MdxBuilderListener;
import rex.graphics.mdxeditor.mdxbuilder.dnd.MBTtoMBTDragSource;
import rex.graphics.mdxeditor.mdxbuilder.dnd.FunctionTreeToMBTDragSource;
import javax.swing.JOptionPane;
import rex.graphics.mdxeditor.mdxbuilder.HandlesMdxEditorSettings;
import java.util.GregorianCalendar;
import javax.swing.BoxLayout;
import java.awt.Graphics;

/**
 * This is a main class for the mdx editor. Displays and links all components (Mdx Builder Tree, Dimension Tree, ...)
 * @@author Igor Mekterovic
 * @@version 0.3
 */

public class MdxEditor extends JPanel implements MdxBuilderListener, HandlesMdxEditorSettings{
   private ClsXMLAProxDiscoverProperties properties;
   private ClsXMLAProxDiscoverRestrictions restrictions;
   private ServerMetadata smd;
   private StatusBar statusBar;
   private DimensionTree dimTree;
   private String cubeName;
   private MdxBuilderTree builderTree;
   private DimensionTreeToMBTDragSource dimTreeDragSource;
   private MBTtoMBTDragSource builderTreeDragSource;
   private FunctionTreeToMBTDragSource functionTreeDragSource;
   private String defaultSaveDirectory;

   JTextArea textArea;
   ColorMenu foregroundMenu
           , backgroundMenu;
   JPopupMenu popup;
   MdxEditorToolbar toolbar;
   static Document document;
   JPanel editorPane, resultPane;
   private boolean isTabbed;
   MdxResultViewer resultViewer;
   JSplitPane jspDimAndFuncTree;

   private static HashMap keywords;
   static {
      keywords = new HashMap();
      keywords.put("SELECT", "SELECT");
      keywords.put("FROM", "FROM");
      keywords.put("WHERE", "WHERE");
      keywords.put("NON", "NON");
      keywords.put("EMPTY", "EMPTY");
      keywords.put("COLUMNS", "COLUMNS");
      keywords.put("ROWS", "ROWS");
      keywords.put("PAGES", "PAGES");
      keywords.put("ON", "ON");
      keywords.put("WITH", "WITH");
      keywords.put("MEMBER", "MEMBER");
      keywords.put("AS", "AS");
      keywords.put("SETTOARRAY","SetToArray");
      keywords.put("DIMENSION", "Dimension");
      keywords.put("DIMENSIONS", "Dimensions");
      keywords.put("HIERARCHY", "Hierarchy");
      keywords.put("LEVEL", "Level");
      keywords.put("LEVELS", "Levels");
      keywords.put("IS", "Is");
      keywords.put("ISANCESTOR", "IsAncestor");
      keywords.put("ISEMPTY", "IsEmpty");
      keywords.put("ISGENERATION", "IsGeneration");
      keywords.put("ISLEAF", "IsLeaf");
      keywords.put("ISSIBLING", "IsSibling");
      keywords.put("ANCESTOR", "Ancestor");
      keywords.put("CLOSINGPERIOD", "ClosingPeriod");
      keywords.put("COUSIN", "Cousin");
      keywords.put("CURRENTMEMBER", "CurrentMember");
      keywords.put("DATAMEMBER", "DataMember");
      keywords.put("DEFAULTMEMBER", "DefaultMember");
      keywords.put("FIRSTCHILD", "FirstChild");
      keywords.put("FIRSTSIBLING", "FirstSibling");
      keywords.put("ITEM", "Item");
      keywords.put("LAG", "Lag");
      keywords.put("LASTCHILD", "LastChild");
      keywords.put("LASTSIBLING", "LastSibling");
      keywords.put("LEAD", "Lead");
      keywords.put("LINKMEMBER", "LinkMember");
      keywords.put("MEMBERS", "Members");
      keywords.put("NEXTMEMBER", "NextMember");
      keywords.put("OPENINGPERIOD", "OpeningPeriod");
      keywords.put("PARALLELPERIOD", "ParallelPeriod");
      keywords.put("PARENT", "Parent");
      keywords.put("PREVMEMBER", "PrevMember");
      keywords.put("STRTOMEMBER", "StrToMember");
      keywords.put("VALIDMEASURE", "ValidMeasure");
      keywords.put("AGGREGATE", "Aggregate");
      keywords.put("AVG", "Avg");
      keywords.put("CALCULATIONCURRENTPASS", "CalculationCurrentPass");
      keywords.put("CALCULATIONPASSVALUE", "CalculationPassValue");
      keywords.put("COALESCEEMPTY", "CoalesceEmpty");
      keywords.put("CORRELATION", "Correlation");
      keywords.put("COUNT", "Count");
      keywords.put("COVARIANCE", "Covariance");
      keywords.put("COVARIANCEN", "CovarianceN");
      keywords.put("DISTINCTCOUNT", "DistinctCount");
      keywords.put("IIF", "IIf");
      keywords.put("LINREGINTERCEPT", "LinRegIntercept");
      keywords.put("LINREGPOINT", "LinRegPoint");
      keywords.put("LINREGR2", "LinRegR2");
      keywords.put("LINREGSLOPE", "LinRegSlope");
      keywords.put("LINREGVARIANCE", "LinRegVariance");
      keywords.put("LOOKUPCUBE", "LookupCube");
      keywords.put("MAX", "Max");
      keywords.put("MEDIAN", "Median");
      keywords.put("MIN", "Min");
      keywords.put("ORDINAL", "Ordinal");
      keywords.put("PREDICT", "Predict");
      keywords.put("RANK", "Rank");
      keywords.put("ROLLUPCHILDREN", "RollupChildren");
      keywords.put("STDDEV", "Stddev");
      keywords.put("STDDEVP", "StddevP");
      keywords.put("STDEV", "Stdev");
      keywords.put("STDEVP", "StdevP");
      keywords.put("STRTOVALUE", "StrToValue");
      keywords.put("SUM", "Sum");
      keywords.put("VALUE", "Value");
      keywords.put("VAR", "Var");
      keywords.put("VARIANCE", "Variance");
      keywords.put("VARIANCEP", "VarianceP");
      keywords.put("VARP", "VarP");
      keywords.put("CALL", "Call");
      keywords.put("ADDCALCULATEDMEMBERS", "AddCalculatedMembers");
      keywords.put("ALLMEMBERS", "AllMembers");
      keywords.put("ANCESTORS", "Ancestors");
      keywords.put("ASCENDANTS", "Ascendants");
      keywords.put("AXIS", "Axis");
      keywords.put("BOTTOMCOUNT", "BottomCount");
      keywords.put("BOTTOMPERCENT", "BottomPercent");
      keywords.put("BOTTOMSUM", "BottomSum");
      keywords.put("CHILDREN", "Children");
      keywords.put("CROSSJOIN", "Crossjoin");
      keywords.put("DESCENDANTS", "Descendants");
      keywords.put("DISTINCT", "Distinct");
      keywords.put("DRILLDOWNLEVEL", "DrilldownLevel");
      keywords.put("DRILLDOWNLEVELBOTTOM", "DrilldownLevelBottom");
      keywords.put("DRILLDOWNLEVELTOP", "DrilldownLevelTop");
      keywords.put("DRILLDOWNMEMBER", "DrilldownMember");
      keywords.put("DRILLDOWNMEMBERBOTTOM", "DrilldownMemberBottom");
      keywords.put("DRILLDOWNMEMBERTOP", "DrilldownMemberTop");
      keywords.put("DRILLUPLEVEL", "DrillupLevel");
      keywords.put("DRILLUPMEMBER", "DrillupMember");
      keywords.put("EXCEPT", "Except");
      keywords.put("EXTRACT", "Extract");
      keywords.put("FILTER", "Filter");
      keywords.put("GENERATE", "Generate");
      keywords.put("HEAD", "Head");
      keywords.put("HIERARCHIZE", "Hierarchize");
      keywords.put("INTERSECT", "Intersect");
      keywords.put("LASTPERIODS", "LastPeriods");
      keywords.put("MEMBERS", "Members");
      keywords.put("MTD", "Mtd");
      keywords.put("NAMETOSET", "NameToSet");
      keywords.put("NONEMPTYCROSSJOIN", "NonEmptyCrossjoin");
      keywords.put("ORDER", "Order");
      keywords.put("PERIODSTODATE", "PeriodsToDate");
      keywords.put("QTD", "Qtd");
      keywords.put("SIBLINGS", "Siblings");
      keywords.put("STRIPCALCULATEDMEMBERS", "StripCalculatedMembers");
      keywords.put("STRTOSET", "StrToSet");
      keywords.put("SUBSET", "Subset");
      keywords.put("TAIL", "Tail");
      keywords.put("TOGGLEDRILLSTATE", "ToggleDrillState");
      keywords.put("TOPCOUNT", "TopCount");
      keywords.put("TOPPERCENT", "TopPercent");
      keywords.put("TOPSUM", "TopSum");
      keywords.put("UNION", "Union");
      keywords.put("VISUALTOTALS", "VisualTotals");
      keywords.put("WTD", "Wtd");
      keywords.put("YTD", "Ytd");
      keywords.put("CALCULATIONPASSVALUE", "CalculationPassValue");
      keywords.put("COALESCEEMPTY", "CoalesceEmpty");
      keywords.put("GENERATE", "Generate");
      keywords.put("IIF", "IIf");
      keywords.put("LOOKUPCUBE", "LookupCube");
      keywords.put("MEMBERTOSTR", "MemberToStr");
      keywords.put("NAME", "Name");
      keywords.put("PROPERTIES", "Properties");
      keywords.put("SETTOSTR", "SetToStr");
      keywords.put("TUPLETOSTR", "TupleToStr");
      keywords.put("UNIQUENAME", "UniqueName");
      keywords.put("USERNAME", "UserName");
      keywords.put("CURRENT", "Current");
      keywords.put("ITEM", "Item");
      keywords.put("STRTOTUPLE", "StrToTuple");
   }




   public MdxEditor( ClsXMLAProxDiscoverRestrictions _restrictions
                  ,  ClsXMLAProxDiscoverProperties   _properties
                  ,  ServerMetadata _smd
                  ,  String _cubeName
                  ){

      restrictions = _restrictions;
      properties   = _properties;
      smd = _smd;
      cubeName = _cubeName;

      foregroundMenu = new ColorMenu("Foreground Color");
      foregroundMenu.addActionListener(new ForegroundListener());

      backgroundMenu = new ColorMenu("Background Color");
      backgroundMenu.addActionListener(new BackgroundListener());

      popup = new JPopupMenu();
      popup.add(foregroundMenu);
      popup.add(backgroundMenu);

      toolbar = new MdxEditorToolbar(this);

      dimTree = new DimensionTree(restrictions, properties, smd, this);
      dimTree.setPreferredSize(new Dimension( (int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth()/5)
                                             ,(int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight()/2.1)));
      dimTreeDragSource  = new DimensionTreeToMBTDragSource(dimTree.getTree()
                                                      , DnDConstants.ACTION_COPY_OR_MOVE);
      builderTree = new MdxBuilderTree(this, this, cubeName);
      builderTree.setPreferredSize(new Dimension(  (int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth()/5)
                                                  ,(int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight()/1.1)));
      builderTreeDragSource = new MBTtoMBTDragSource(builderTree.getTree()
                                                      , DnDConstants.ACTION_COPY_OR_MOVE);

      textArea = new JTextArea();
      textArea.addMouseListener(new PopupListener());
      textArea.addKeyListener(new TextAreaKeyListener());

      editorPane = new JPanel();
      editorPane.setLayout(new BorderLayout());


      MdxFunctionTree fTree = new MdxFunctionTree(this);
      functionTreeDragSource = new FunctionTreeToMBTDragSource(fTree.getTree(), DnDConstants.ACTION_COPY_OR_MOVE);
      fTree.setPreferredSize(new Dimension( (int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth()/5)
                                                   ,(int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight()/2.1)));


      jspDimAndFuncTree = new JSplitPane(   JSplitPane.VERTICAL_SPLIT
                                                        , dimTree
                                                        , fTree
                                                       );
      jspDimAndFuncTree.setOneTouchExpandable(true);
      jspDimAndFuncTree.setDividerSize(8);


      JSplitPane jspTrees = new JSplitPane(  JSplitPane.HORIZONTAL_SPLIT
                                       , jspDimAndFuncTree
                                       , builderTree
                                      );
      jspTrees.setDividerSize(8);

      JSplitPane jspTreesAndText = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT
                                   , jspTrees
                                   , new JScrollPane(textArea));
      jspTreesAndText.setDividerSize(8);


      editorPane.add(toolbar, BorderLayout.NORTH);
      editorPane.add(jspTreesAndText, BorderLayout.CENTER);

      resultPane = new JPanel(){

         {
            setOpaque(false);
         } // instance initializer

         public void paintComponent(Graphics g) {
            S.paintBackground(g, this);
            super.paintComponent(g);
         }
      };
      resultPane.setLayout(new BoxLayout(resultPane, BoxLayout.Y_AXIS));
      resultPane.add(  new JLabel("                        \"Trying is the first step towards failure\"  H.Simpson")
                     , BorderLayout.CENTER);

      statusBar = new StatusBar();




      this.setLayout(new BorderLayout());
      this.add(new JSplitPane(JSplitPane.VERTICAL_SPLIT
                              , editorPane
                              , resultPane )
               , BorderLayout.CENTER);
      this.add(statusBar, BorderLayout.SOUTH);
      initDefaults();
//      (int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth()
      jspTreesAndText.setDividerLocation( (int)(dimTree.getPreferredSize().getWidth()
                                              + builderTree.getPreferredSize().getWidth()
                                              + jspTreesAndText.getDividerSize()
                                              + jspTrees.getDividerSize()));
      jspDimAndFuncTree.setDividerLocation((int)(dimTree.getPreferredSize().getHeight()));
//      S.out("toolkit width = " + Toolkit.getDefaultToolkit().getScreenSize().getWidth()
//             + "\n dimTree width = " + dimTree.getPreferredSize().getWidth() );

   }

   /**
    * Sets the split pane (vertical or horizontal split) to specified <code>splitType</code> and saves the defaults.
    * @@param splitType int
    */
   protected void setSplitPaneView(int splitType){
      isTabbed = false;
      this.removeAll();
      JSplitPane jsp =  new JSplitPane(
                                splitType
                              , editorPane
                              , resultPane );
      jsp.setDividerSize(8);
      this.add(  jsp
               , BorderLayout.CENTER);
      this.add(statusBar, BorderLayout.SOUTH);
      this.invalidate();
      this.revalidate();
      this.repaint();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "RESULT_POSITION");
      n.removeChild(n.getChildNodes().item(0));
      if (splitType == JSplitPane.VERTICAL_SPLIT)
         n.appendChild(document.createTextNode(MdxEditorToolbar.VERTICAL_SPLIT_PANE));
      else
         n.appendChild(document.createTextNode(MdxEditorToolbar.HORIZONTAL_SPLIT_PANE));
      saveDefaults();
   }

   /**
    * Sets the tab placement (up, bottom, left or right) to specified <code>tabPlacement</code> and saves the defaults.
    * @@param tabPlacement int
    */
   protected void setTabbedPaneView(int tabPlacement){
      isTabbed = true;
      this.removeAll();
      JTabbedPane tp = new JTabbedPane(tabPlacement);
      tp.add("Editor", editorPane);
      tp.add("Result", resultPane);
      this.add(tp, BorderLayout.CENTER);
      this.add(statusBar, BorderLayout.SOUTH);
      this.invalidate();
      this.revalidate();
      this.repaint();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "RESULT_POSITION");
      n.removeChild(n.getChildNodes().item(0));
      if (tabPlacement == JTabbedPane.TOP)
         n.appendChild(document.createTextNode(MdxEditorToolbar.TABBED_PANE_UP));
      else if (tabPlacement == JTabbedPane.BOTTOM )
         n.appendChild(document.createTextNode(MdxEditorToolbar.TABBED_PANE_BOTTOM));
      else if (tabPlacement == JTabbedPane.LEFT  )
         n.appendChild(document.createTextNode(MdxEditorToolbar.TABBED_PANE_LEFT ));
      else if (tabPlacement == JTabbedPane.RIGHT  )
         n.appendChild(document.createTextNode(MdxEditorToolbar.TABBED_PANE_RIGHT ));
      saveDefaults();
   }
   /**
    * Reads and sets the editor settings from the "mdxeditor.defaults.xml".
    * <br>If the file is missing then it sets the default settings.
    * <br>Missing setting are also replaced by default settings. (e.g. if the font size is not specified then it is set to 13)
    */
   private void initDefaults(){


      DocumentBuilder builder;
      DocumentBuilderFactory factory =
          DocumentBuilderFactory.newInstance();
      //factory.setValidating(true);
      //factory.setNamespaceAware(true);
      try {
         builder = factory.newDocumentBuilder();
      } catch(ParserConfigurationException pce){
         pce.printStackTrace();
         return;
      }
      try {
         document = builder.parse( new File("mdxeditor.defaults.xml") );
      } catch (IOException ioe) {
      // this is ok, there is no default file, let's make one:
         document = builder.newDocument();
         Element root = document.createElement("root");
         Element e;
         document.appendChild(root);
         e = document.createElement("FONT_NAME");
         e.appendChild(document.createTextNode("Courier New"));
         root.appendChild(e);

         e = document.createElement("FONT_SIZE");
         e.appendChild(document.createTextNode("13"));
         root.appendChild(e);

         e = document.createElement("BOLD");
         e.appendChild(document.createTextNode("false"));
         root.appendChild(e);

         e = document.createElement("ITALIC");
         e.appendChild(document.createTextNode("false"));
         root.appendChild(e);

         e = document.createElement("TAB_SIZE");
         e.appendChild(document.createTextNode("2"));
         root.appendChild(e);

         e = document.createElement("FOREGROUND_COLOR");
         e.appendChild(document.createTextNode("-16777216"));
         root.appendChild(e);

         e = document.createElement("BACKGROUND_COLOR");
         e.appendChild(document.createTextNode("-1"));
         root.appendChild(e);

         e = document.createElement("RESULT_POSITION");
         e.appendChild(document.createTextNode(MdxEditorToolbar.VERTICAL_SPLIT_PANE));
         root.appendChild(e);

         e = document.createElement("SAVE_DIRECTORY");
//         S.out("System.getProperty(user.home)=" + System.getProperty("user.home"));
         e.appendChild(document.createTextNode(System.getProperty("user.home")));
         root.appendChild(e);


//         S.out("creating new");
         saveDefaults();
      } catch (Exception e) {
         e.printStackTrace();
      }
      // SET UP TEXTAREA BASED ON DOCUMENT
      String fontName = new String("Courier New");
      int fontStyle = 0, fontSize=10;
      NodeList nl = document.getDocumentElement().getChildNodes();
      for(int i=0; i < nl.getLength(); i++){
         if (nl.item(i).getNodeName().equalsIgnoreCase("FONT_NAME")){
            fontName = new String(DOM.getTextFromDOMElement(nl.item(i)));
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("FONT_SIZE")){
            try{
               fontSize = Integer.parseInt(DOM.getTextFromDOMElement(nl.item(i))) ;
            }catch(NumberFormatException ex){
            }
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("BOLD")
                   && DOM.getTextFromDOMElement(nl.item(i)).equalsIgnoreCase("true")){
            fontStyle |= Font.BOLD;
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("ITALIC")
                   && DOM.getTextFromDOMElement(nl.item(i)).equalsIgnoreCase("true")){
            fontStyle |= Font.ITALIC;
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("TAB_SIZE")){
            try{
               int tabSize = Integer.parseInt(DOM.getTextFromDOMElement(nl.item(i))) ;
               setTabSize(tabSize);
            }catch(NumberFormatException ex){
            }
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("FOREGROUND_COLOR")){
            try{
               int rgb = Integer.parseInt(DOM.getTextFromDOMElement(nl.item(i))) ;
               setForegroundColor(new Color(rgb));
            }catch(NumberFormatException ex){
            }
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("BACKGROUND_COLOR")){
            try{
               int rgb = Integer.parseInt(DOM.getTextFromDOMElement(nl.item(i))) ;
               setBackgroundColor(new Color(rgb));
            }catch(NumberFormatException ex){
            }
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("RESULT_POSITION")){
            String s = DOM.getTextFromDOMElement(nl.item(i)) ;
            if (s.equals(MdxEditorToolbar.VERTICAL_SPLIT_PANE)){
               setSplitPaneView(JSplitPane.VERTICAL_SPLIT);
               toolbar.setcbResultPosition(MdxEditorToolbar.VERTICAL_SPLIT_PANE);
            }
            else if (s.equals(MdxEditorToolbar.HORIZONTAL_SPLIT_PANE)) {
               setSplitPaneView(JSplitPane.HORIZONTAL_SPLIT);
               toolbar.setcbResultPosition(MdxEditorToolbar.HORIZONTAL_SPLIT_PANE);
            }
            else if (s.equals(MdxEditorToolbar.TABBED_PANE_UP)) {
               setTabbedPaneView(JTabbedPane.TOP);
               toolbar.setcbResultPosition(MdxEditorToolbar.TABBED_PANE_UP);
            }
            else if (s.equals(MdxEditorToolbar.TABBED_PANE_LEFT)) {
               setTabbedPaneView(JTabbedPane.LEFT);
               toolbar.setcbResultPosition(MdxEditorToolbar.TABBED_PANE_LEFT);
            }
            else if (s.equals(MdxEditorToolbar.TABBED_PANE_RIGHT)) {
               setTabbedPaneView(JTabbedPane.RIGHT);
               toolbar.setcbResultPosition(MdxEditorToolbar.TABBED_PANE_RIGHT);
            }
            else if (s.equals(MdxEditorToolbar.TABBED_PANE_BOTTOM)) {
               setTabbedPaneView(JTabbedPane.BOTTOM);
               toolbar.setcbResultPosition(MdxEditorToolbar.TABBED_PANE_BOTTOM);
            }
         }else if (nl.item(i).getNodeName().equalsIgnoreCase("SAVE_DIRECTORY")){
            try{
               defaultSaveDirectory = new String(DOM.getTextFromDOMElement(nl.item(i)));
            }catch(NumberFormatException ex){
            }
         }


      }
      Font newFont = new Font(fontName, fontStyle, fontSize);
      textArea.setFont( newFont );
      // set toolbar to this defaults
      toolbar.setcbFont(fontName);
      toolbar.setcbSize(fontSize);
      toolbar.setBold( (fontStyle & Font.BOLD) == Font.BOLD);
      toolbar.setItalic( (fontStyle & Font.ITALIC) == Font.ITALIC);
      toolbar.setTabSize(textArea.getTabSize());

   }

   /**
    * Saves the editor settings (font, font size, colors,...) to file "mdxeditor.defaults.xml".
    */
   private void saveDefaults(){
      TransformerFactory tFactory =
          TransformerFactory.newInstance();
      try{
         Transformer transformer = tFactory.newTransformer();
         DOMSource source = new DOMSource(document);
         StreamResult result = new StreamResult(new File("mdxeditor.defaults.xml"));
//         S.out("Saving defualts defaults:");
         transformer.transform(source, result);
      } catch (Exception e){
         S.out("Unable to save defaults:");
         e.printStackTrace();
      }
   }


   /**
    * Sets the Mdx editor's BOLD attribute to specified value.
    * @@param isBold boolean
    */
   void setTextToBold(boolean isBold){
      Font font = textArea.getFont();
      String name = font.getName();
      int style = font.getStyle();
      int size = font.getSize();
      if (isBold)
         style |= Font.BOLD;
      else
         style &= ~Font.BOLD;
      Font newFont = new Font(name, style, size);
      textArea.setFont( newFont );
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "BOLD");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(isBold ? "true" : "false"));
      saveDefaults();
   }

   /**
    * Sets the Mdx editor's ITALIC attribute to specified value.
    * @@param isItalic boolean
    */
   void setTextToItalic(boolean isItalic){
      Font font = textArea.getFont();
      String name = font.getName();
      int style = font.getStyle();
      int size = font.getSize();
      if (isItalic)
         style |= Font.ITALIC;
      else
         style &= ~Font.ITALIC;
      Font newFont = new Font(name, style, size);
      textArea.setFont( newFont );
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "ITALIC");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(isItalic ? "true" : "false"));
      saveDefaults();
   }

   /**
    * Sets the Mdx editor's FONTNAME attribute to specified value.
    * @@param fontName String
    */
   void setFontName(String fontName){
      Font font = textArea.getFont();
      int style = font.getStyle();
      int size = font.getSize();
      Font newFont = new Font(fontName, style, size);
      textArea.setFont( newFont );
//      S.out("setFontName:");
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "FONT_NAME");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(fontName));
      saveDefaults();
//    Necessary here to transfer focus back to textArea or the user
//    can't keep on typing in textArea after selection in cbFonts.
      textArea.requestFocus();
   }

   /**
    * Sets the Mdx editor's FONTSIZE attribute to specified value.
    * @@param fontSize int
    */
   void setFontSize(int fontSize){
      Font font = textArea.getFont();
      int style = font.getStyle();
      String name = font.getName();
      Font newFont = new Font(name, style, fontSize);
      textArea.setFont( newFont );
//    Necessary here to transfer focus back to textArea or the user
//    can't keep on typing in textArea after selection in cbFonts.
      textArea.requestFocus();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "FONT_SIZE");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(Integer.toString(fontSize)));
      saveDefaults();
   }

   /**
    * Sets the Mdx editor's TABSIZE attribute to specified value.
    * @@param tabSize int
    */
   void setTabSize(int tabSize){
      textArea.setTabSize(tabSize);
      textArea.requestFocus();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "TAB_SIZE");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(Integer.toString(tabSize)));
      saveDefaults();
   }

   /**
    * Sets the Mdx editor's FOREGROUND COLOR attribute to specified value.
    * @@param newColor Color
    */
   void setForegroundColor(Color newColor){
      textArea.setForeground(newColor);
      textArea.requestFocus();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "FOREGROUND_COLOR");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(Integer.toString(newColor.getRGB())));
      saveDefaults();
   }

   /**
    * Sets the Mdx editor's BACKGROUND COLOR attribute to specified value.
    * @@param newColor Color
    */
   void setBackgroundColor(Color newColor){
      textArea.setBackground(newColor);
      textArea.requestFocus();
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "BACKGROUND_COLOR");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(Integer.toString(newColor.getRGB())));
      saveDefaults();
   }
   /**
    * Returns default save directory for the mdx builder queries
    * @@return String
    */
   public String getDefaultSaveDirectory(){
      return defaultSaveDirectory;
   }

   /**
    * Sets the default save directory for the mdx builder queries
    * @@param dir String
    */
   public void setDefaultSaveDirectory(String dir){
      defaultSaveDirectory = dir;
      Node n = DOM.getFirstChildNodeWithName(document.getDocumentElement(), "SAVE_DIRECTORY");
      n.removeChild(n.getChildNodes().item(0));
      n.appendChild(document.createTextNode(dir));
      S.out("saving: " + defaultSaveDirectory);
      saveDefaults();
   }


   /**
    * Sets the display of column totals to specified value.
    * @@param newValue boolean
    */
   protected void setShowColumnTotalsOn(boolean newValue){
      if (resultViewer != null) resultViewer.setShowColumnTotalsOn(newValue);
   }

   /**
    * Sets the display of row totals to specified value.
    * @@param newValue boolean
    */
   protected void setShowRowTotalsOn(boolean newValue){
      if (resultViewer != null)  resultViewer.setShowRowTotalsOn(newValue);
   }


   /**
    * Executes the specified query and displays the results.
    * @@param q String
    */
   void runQuery(String q){
      resultViewer = new MdxResultViewer( restrictions
                                               , properties
                                               , smd
                                               , q
                                               , statusBar
                                               , toolbar.getShowRowTotalsOn()
                                               , toolbar.getShowColumnTotalsOn()
                                               , this  );
     resultPane.removeAll();
     resultPane.add(resultViewer);
     resultPane.invalidate();
     resultPane.revalidate();
     resultPane.repaint();
     if (isTabbed && !resultViewer.getErrorOccured()) {
        // don't feel like holding a reference just for this
        // anyway, getComponentCount() is small, like 3 or 4
        for(int i=0; i < this.getComponentCount(); i++ ){
           if (this.getComponent(i) instanceof JTabbedPane){
              // there are ylaways exactly 2 tabs, so this is safe to do:
              ((JTabbedPane)this.getComponent(i)).setSelectedIndex(1);
           }
        }
     }
   }

   /**
    * Executes all queries in the textArea and displays the results..
    */
   void runAllQuery(){
      if (textArea.getText().trim().length() > 0)
         runQuery(textArea.getText());
   }
   /**
    * Executes selected query (in the textArea) and displays the results.
    */
   void runSelectedQuery(){
      if (textArea.getSelectedText() != null){
         runQuery(textArea.getSelectedText());
      }
   }

   /**
    * Insert a code skeleton (the most common basis of an mdx query) into the textArea.
    */
   void insertCodeSkeleton(){
      textArea.setText(""
                       + textArea.getText()
                       + "SELECT \nNON EMPTY\n{\n   Measures.AllMembers\n}\n ON COLUMNS,\nNON EMPTY\n{\n   \n}\nON ROWS\nFROM " + cubeName
                       );
   }

   /**
    * Returns the DimensionTree.
    * @@return DimensionTree
    */
   DimensionTree getDimensionTree(){
      return dimTree;
   }

   /**
    * Returns the cube name.
    * @@return String
    */
   String getCubeName(){
      return cubeName;
   }

   /**
    * Refreshes (and displays) the MDX statement generated with MdxBuilder.
    * @@param newMdx String
    */
   public void mdxChanged(String newMdx){
      // setup a tagged area in a textArea and update the tagged area with new mdx
      // whatever user types outide the area  should be intact
      //
      int istart = textArea.getText().indexOf(MdxBuilderTree.OPEN_MDX_GENERATED_EXPRESSION_TAG);
      int iend   = textArea.getText().indexOf(MdxBuilderTree.CLOSE_MDX_GENERATED_EXPRESSION_TAG);

      if (istart != -1 && iend != -1){
         textArea.setText( textArea.getText().substring(0, istart)
                         + MdxBuilderTree.OPEN_MDX_GENERATED_EXPRESSION_TAG
                         + "\n-- ********* Generated(" + GregorianCalendar.getInstance().getTime() + "):  ********** \n"
                         + "\n" + newMdx
                         + "\n" + textArea.getText().substring(iend)
                         );
      }else{
         textArea.setText(MdxBuilderTree.OPEN_MDX_GENERATED_EXPRESSION_TAG
                         + "\n-- ****** Generated(" + GregorianCalendar.getInstance().getTime() + "):  ****** \n"
                         + "\n" + newMdx
                         + "\n" + MdxBuilderTree.CLOSE_MDX_GENERATED_EXPRESSION_TAG
                         + "\n\n" + textArea.getText()
                         );
      }

   }

   /**
    * Inserts specified text into the current prompt position in the textArea.
    * @@param s String
    */
   public void addTextToCurrentPosition(String s){
      textArea.insert(s, textArea.getCaretPosition());
   }

   /**
    * Appends specified text to the textArea.
    * <br>(Specified text is an MDX statement generated with user's actions on the result table, e.g. drilldown on some meber)
    * @@param s String
    */
   public void appendGeneratedMDX(String s){
      if (toolbar.getAppendGeneratedMDX())
         textArea.append(s);
   }

   /**
    * Inner class that displays the pop-up menu.
    * @@author Igor Mekterovic
    * @@version 0.3
    */
   class PopupListener extends MouseAdapter {
       public void mousePressed(MouseEvent e) {
//          jspTextAndTree.setDividerLocation(1.);
          maybeShowPopup(e);
       }

       public void mouseReleased(MouseEvent e) {
           maybeShowPopup(e);
       }

       private void maybeShowPopup(MouseEvent e) {
           if (e.isPopupTrigger()) {
               popup.show(e.getComponent(),
                          e.getX(), e.getY());
           }
       }
   }


   /**
    * Inner class that displays the Color menu for setting the foreground color.
    * @@author Igor Mekterovic
    * @@version 0.3
    */
   class ForegroundListener implements ActionListener {
      public void actionPerformed(ActionEvent e) {
         ColorMenu m = (ColorMenu) e.getSource();
         setForegroundColor(m.getColor());
      }
   }

   /**
    * Inner class that displays the Color menu for setting the background color.
    * @@author Igor Mekterovic
    * @@version 0.3
    */
   class BackgroundListener implements ActionListener {
      public void actionPerformed(ActionEvent e) {
         ColorMenu m = (ColorMenu) e.getSource();
         setBackgroundColor(m.getColor());
      }
   }

   /**
    * Inner class that listens to the key actions in the textArea and replaces the keywords
    * with properly cased keywords. (e.g. seLECT -> SELECT)
    * @@author Igor Mekterovic
    * @@version 0.3
    */
   class TextAreaKeyListener extends KeyAdapter {


      public void keyPressed(KeyEvent e){
         if (e.isControlDown() &&  e.isShiftDown() && e.getKeyCode() == KeyEvent.VK_ENTER){
            runAllQuery();
         }else if (e.isControlDown() &&  e.getKeyCode() == KeyEvent.VK_ENTER){
            runSelectedQuery();
         }
         if (   e.getKeyCode() == KeyEvent.VK_SPACE
             || e.getKeyCode() == KeyEvent.VK_ENTER
             || e.getKeyCode() == KeyEvent.VK_TAB
             || e.getKeyCode() == KeyEvent.VK_COMMA
             || e.getKeyCode() == KeyEvent.VK_RIGHT
             || e.getKeyCode() == KeyEvent.VK_LEFT
             || e.getKeyCode() == KeyEvent.VK_UP
             || e.getKeyCode() == KeyEvent.VK_DOWN){
            int start = textArea.getCaretPosition() - 1;
            while (start > 0){
               char ch = textArea.getText().charAt(start);
               if ((ch == ' ') || (ch =='\n') || (ch == '\t')){
                  start++;
                  break;
               }
               start--;
            }
            if (start >= 0){
               if (keywords.get(textArea.getText().substring(start, textArea.getCaretPosition()).toUpperCase()) != null){
                  textArea.replaceRange( (String) keywords.get(textArea.getText().substring(start, textArea.getCaretPosition()).toUpperCase())
                                        , start
                                        , textArea.getCaretPosition());

               }
            }
         }
         if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_V){
         // this is paste! I should parse whole text now for keywords!
         // I'll do that in next version should there be an interest in it.

         }

      }
      public void keyTyped(KeyEvent e){

      }
   }


   /**
    * Main class used for testing the Mdx Editor.
    * @@param args String[]
    */
   public static void main(String[] args){
      String url = JOptionPane.showInputDialog("Please input an Foodmart 2000 service URL", "http://localhost:8080/xmla/msxisapi.dll");
      ServerMetadata svm = new ServerMetadata( url);

      ClsXMLAProxDiscoverRestrictions restrictions = new ClsXMLAProxDiscoverRestrictions();
      ClsXMLAProxDiscoverProperties properties = new ClsXMLAProxDiscoverProperties();
      ClsXMLAProxDiscoverPropertyList pl = new ClsXMLAProxDiscoverPropertyList();
      ClsXMLAProxDiscoverRestrictionList rl = new ClsXMLAProxDiscoverRestrictionList();


      pl.setDataSourceInfo("Local Analysis Server");
      rl.setCatalog("Foodmart 2000");
      rl.setCubeName("Sales");

      restrictions.setRestrictionList(rl);

      pl.setCatalog("Foodmart 2000");
      pl.setFormat("Tabular");
      pl.setContent("SchemaData");

      properties.setPropertyList(pl);

      JFrame frame = new JFrame("Test mdx editor");

      frame.getContentPane().add(new MdxEditor(restrictions, properties, svm, "Sales"), BorderLayout.CENTER);

      frame.addWindowListener(new WindowAdapter() {
         public void windowClosing(WindowEvent e) {
            System.exit(0);
         }
      });
      frame.pack();
//      frame.setExtendedState(frame.MAXIMIZED_BOTH);
      frame.setVisible(true);

   }
}
@


1.4
log
@*** empty log message ***
@
text
@@


1.3
log
@*** empty log message ***
@
text
@@


1.2
log
@*** empty log message ***
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d46 17
d64 1
a64 1
public class MdxEditor extends JPanel{
d71 5
d86 1
a86 1
   JSplitPane jspTextAndTree;
d266 8
a273 2
                                                   ,(int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight()/1.1)));

a277 2
//      textArea.setPreferredSize(new Dimension( (int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth() - dimTree.getPreferredSize().getWidth() - 8)  // 8 = divider size
//                                            ,(int)(Toolkit.getDefaultToolkit().getScreenSize().getHeight()/2.4)));
d283 9
a291 4
      MdxFunctionTree ftree = new MdxFunctionTree(this);
      jspTextAndTree = new JSplitPane(   JSplitPane.HORIZONTAL_SPLIT
                                                        , new JScrollPane(textArea)
                                                        , ftree
d293 2
a294 2
      jspTextAndTree.setOneTouchExpandable(true);
      jspTextAndTree.setDividerSize(8);
d297 3
a299 3
      JSplitPane jsp = new JSplitPane(   JSplitPane.HORIZONTAL_SPLIT
                                       , dimTree
                                       , jspTextAndTree
d301 8
a308 1
      jsp.setDividerSize(8);
d310 1
a310 1
      editorPane.add(jsp, BorderLayout.CENTER);
d312 12
a323 3
      resultPane = new JPanel();
      resultPane.setBackground(Color.WHITE);
      resultPane.setLayout(new BorderLayout());
d339 8
a346 5
      jspTextAndTree.setDividerLocation((int)(Toolkit.getDefaultToolkit().getScreenSize().getWidth()
                                              - ftree.getPreferredSize().getWidth()
                                              - dimTree.getPreferredSize().getWidth()
                                              - jspTextAndTree.getDividerSize()
                                              - jsp.getDividerSize()));
d350 4
a353 6
//   public void addNotify() {
//      super.addNotify();
//      S.out("addNotify()");
//      jspTextAndTree.setDividerLocation(1.);
//   }

d376 5
d404 7
a411 1
   private void initDefaults(){
d463 6
d536 5
d543 1
d555 4
d573 6
d595 5
d616 5
d627 1
a627 1
      S.out("setFontName:");
d636 5
d655 5
d669 4
d681 5
d694 7
d702 18
a719 3
//   JTextArea getTextArea(){
//      return textArea;
//   }
d723 5
d732 5
d747 1
a747 1
     resultPane.add(resultViewer, BorderLayout.CENTER);
d762 4
d770 3
d778 4
d788 5
d796 5
d804 34
d841 6
a846 3
//   public void appendText(String s){
//      textArea.append(s);
//   }
d852 5
a856 1

d859 1
a859 1
          jspTextAndTree.setDividerLocation(1.);
d874 7
d887 6
d899 7
d954 4
d959 2
a960 1
      ServerMetadata svm = new ServerMetadata("http://skladiste.zpm.fer.hr/xmla/msxisapi.dll");
d990 1
a990 1
      frame.setExtendedState(frame.MAXIMIZED_BOTH);
@

