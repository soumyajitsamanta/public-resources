head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2006.01.13.12.21.32;	author igorludi;	state dead;
branches;
next	1.3;

1.3
date	2005.10.18.14.04.42;	author igorludi;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.18.13.40.57;	author igorludi;	state dead;
branches;
next	1.1;

1.1
date	2005.06.28.14.11.32;	author igorludi;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@package rex.metadata;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;

import rex.utils.S;
import rex.graphics.Viewer;
import rex.graphics.dimensiontree.elements.DimensionTreeElement;
import rex.metadata.resultelements.Member;
import java.util.ListIterator;
import rex.graphics.dimensiontree.DimensionTreeModel;
import rex.graphics.filtertree.FilterTree;
import rex.graphics.filtertree.FilterTreeModel;
import javax.swing.JTree;
import rex.graphics.mdxeditor.MdxResultViewer;
import rex.graphics.IViewer;
import javax.swing.JOptionPane;

/**
 * <p>Title: WHEX</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: </p>
 * @@author igor
 * @@version 1.0
 */

public class Query {
   private boolean queryCanExecute;
   private LinkedList onColumns;
   private LinkedList onRows;
   private LinkedList onPages;
   private LinkedList onMeasures;
   private LinkedList filters;
   private String cubeName;
   private IViewer viewer;

   private Member memberToSortBy;
   private String sortType;
   private String lastQueryGenerated;

// this method is used from MDX Editor
// when there already exists an ExecuteResult object:
   public void setQuery( ExecuteResult er) { //, MdxResultViewer _v
      queryCanExecute = true;
      onColumns.clear();
      onMeasures.clear();
      onRows.clear();
      onPages.clear();
      for(int axis = 0; axis < er.getAxisCount(); axis++){
         for (int i = 0; i < er.getTupleCount(axis); i++) {
            for (int j = 0; j < er.getAxis("Axis" + axis).getTupleAt(i).getMemberCount() ; j++) {
               QueryElement qe = new QueryElementImpl(  er.getAxis("Axis" + axis).getTupleAt(i).getMemberAt(j).getQueryMembersExpression()
                                                      , er.getAxis("Axis" + axis).getTupleAt(i).getMemberAt(j).getHierarchyUniqueName() );
               if (qe.getHierarchyUniqueName().toLowerCase().indexOf("measures") > 0 ){
                  addToMeasuresNoRun(qe);
               }else{
                  switch(axis){
                     case 0: addToColumnsNoRun(qe); break;
                     case 1: addToRowsNoRun(qe);    break;
                     case 2: addToPagesNoRun(qe);   break;
                  }
               }
            }
         }
      }
//      S.out("Constructed:\n" + getQuery());
   }


   public Query(String _cubeName, IViewer _v) {
      viewer = _v;
      queryCanExecute = false;
      onColumns  = new LinkedList();
      onRows     = new LinkedList();
      onPages    = new LinkedList();
      onMeasures = new LinkedList();
      cubeName = _cubeName;
   }
   public void addToColumns(QueryElement qe){
      addToColumnsNoRun(qe);
      checkRunQuery();
   }
   public void addToColumnsNoRun(QueryElement qe){
//      S.out("add to columns");
      QueryDimensionElement qde;
      Iterator it = onColumns.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (qde.getHierarchyUniqueName().startsWith(qe.getHierarchyUniqueName())
             || qe.getHierarchyUniqueName().startsWith(qde.getHierarchyUniqueName())){
//         if (qde.getHierarchyUniqueName().equals(qe.getHierarchyUniqueName())){
            // a) if there was only e.g. Time.Year.Members(i.e. QueryDimensionElement.members==null)
            //   , and we're trying to add Time.Year.2002 then Time.Year.Members will be lost,
            //     and produced MDX will be only Time.Year.2002
            // b) if there was Time.Year.2001 already in list (i.e. QueryDimensionElement.members!=null)
            //   then Time.Year.2002 will be added to list, and produced MDX will be:
            //    {Time.Year.2001, Time.Year.2002}
            qde.addMemberToList(qe);
            return;
         }
      }
      onColumns.addLast(new QueryDimensionElement(qe));
   }

   public void addToRows(QueryElement qe){
      addToRowsNoRun(qe);
      checkRunQuery();
   }
   public void addToRowsNoRun(QueryElement qe){
//      S.out("add to rows");
      QueryDimensionElement qde;
      Iterator it = onRows.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
//         S.out(qde.getHierarchyUniqueName() + " == " + qe.getHierarchyUniqueName() + " ?");
         if (qde.getHierarchyUniqueName().startsWith(qe.getHierarchyUniqueName())
             || qe.getHierarchyUniqueName().startsWith(qde.getHierarchyUniqueName())){
//         if (qde.getHierarchyUniqueName().equals(qe.getHierarchyUniqueName())){
            // see comment at addToColumns
            qde.addMemberToList(qe);
            return;
         }
      }
      onRows.addLast(new QueryDimensionElement(qe));

   }
   public void addToPages(QueryElement qe){
      addToPagesNoRun(qe);
      checkRunQuery();
   }
   public void addToPagesNoRun(QueryElement qe){
//      S.out("add to pages");
      QueryDimensionElement qde;
      Iterator it = onPages.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (qde.getHierarchyUniqueName().startsWith(qe.getHierarchyUniqueName())
             || qe.getHierarchyUniqueName().startsWith(qde.getHierarchyUniqueName())){
//         if (qde.getHierarchyUniqueName().equals(qe.getHierarchyUniqueName())){
            // see comment at addToColumns
            qde.addMemberToList(qe);
            return;
         }
      }
      onPages.addLast(new QueryDimensionElement(qe));
   }

   public void addToMeasures(QueryElement qe){
      addToMeasuresNoRun(qe);
      checkRunQuery();
   }
   public void addToMeasuresNoRun(QueryElement qe){
//      S.out("add to measures");
      QueryDimensionElement qde;
      Iterator it = onMeasures.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (qde.getHierarchyUniqueName().startsWith(qe.getHierarchyUniqueName())
             || qe.getHierarchyUniqueName().startsWith(qde.getHierarchyUniqueName())){
//         if (qde.getHierarchyUniqueName().equals(qe.getHierarchyUniqueName())){
            qde.addMemberToList(qe);
            // unlike addToRows and Pages I must checkRun it :
//            checkRunQuery();
            return;
         }
      }
      onMeasures.addLast(new QueryDimensionElement(qe));
   }
   public String getCaptionForRows(){
      Iterator it = onRows.iterator();
      String retVal = "";
      if (!it.hasNext()) return "drop rows here...";
      while (it.hasNext()) {
         retVal += ((QueryElement) it.next()).getHierarchyUniqueName() + " * ";
      }
      return retVal.substring(0, retVal.length() - 3);

   }
   public String getCaptionForPages(){
      Iterator it = onPages.iterator();
      String retVal = "";
      if (!it.hasNext()) return "drop rows here...";
      while (it.hasNext()) {
         retVal += ((QueryElement) it.next()).getHierarchyUniqueName() + " * ";
      }
      return retVal.substring(0, retVal.length() - 3);

   }
   public String getCaptionForColumns(){
      Iterator it = onColumns.iterator();
      String retVal = "";
      if (!it.hasNext()) return "drop columns here...";
      while(it.hasNext()){
         retVal += ((QueryElement)it.next()).getHierarchyUniqueName() + " * ";
      }
      return retVal.substring(0, retVal.length() - 3);

   }
   public String getCaptionForMeasures(){
      Iterator it = onMeasures.iterator();
      String retVal = "";
      if (!it.hasNext()) return "drop measures here...";
      while (it.hasNext()) {
         retVal += ( (QueryElement) it.next()).getHierarchyUniqueName() + " * ";
      }
      return retVal.substring(0, retVal.length() - 3);

   }

   public void checkRunQuery(){
//      S.out("Query:\n" + this.toString());
      //if (canExecute()){
         viewer.refreshQuery();
      //}
   }

   public boolean canExecute(){
//      S.out("onColumns.size()=" + onColumns.size()
//            + " onRows.size()=" + onRows.size()
//            + " onMeasures.size()=" + onMeasures.size() );
      if (onRows.size() * onMeasures.size() > 0 ) // onColumns.size() *
         return true;
      else
         return false;
   }
   private String getAxisQueryExpression(LinkedList axDims){
      Iterator it = axDims.iterator();
      String retVal = "     ";
      while(it.hasNext()){
         retVal += "{" + ((QueryDimensionElement)it.next()).getQueryMembersExpression() + "}\n * ";
      }
      return retVal.substring(0, retVal.length()-3);
   }

   public void toggleRowsDrillState(Member member){
      QueryDimensionElement qde;
      Iterator it = onRows.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
//         S.out("checking..." + qde.getHierarchyUniqueName()
//               + "==" + qe.getHierarchyUniqueName()
//               + "==" + ((Member)qe).getUName() );
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())){
            qde.toggleDrillState(member);
            break;
         }
      }
      checkRunQuery();
   }
   public void togglePagesDrillState(Member member){
      QueryDimensionElement qde;
      Iterator it = onPages.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())){
            qde.toggleDrillState(member);
            break;
         }
      }
      checkRunQuery();
   }
   public void toggleColumnsDrillState(Member member){
      QueryDimensionElement qde;
      Iterator it = onColumns.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())){
            qde.toggleDrillState(member);
            break;
         }
      }
      checkRunQuery();
   }

   public void moveColumnDimensionUp(Member member){
      moveDimensionUp(member, onColumns);
   }
   public void moveRowDimensionUp(Member member){
      moveDimensionUp(member, onRows);
   }
   public void movePageDimensionUp(Member member){
      moveDimensionUp(member, onPages);
   }
   private void moveDimensionUp(Member member, LinkedList linkList){
      QueryDimensionElement qde;
      Object element, previousElement;
      ListIterator it = linkList.listIterator();
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            element =  it.previous();
            if (it.hasPrevious()){
               previousElement = it.previous();
//               S.out("previous=" + previousElement.toString());
//               S.out("element=" + element.toString());
               it.remove();
               it.next();
               it.add(previousElement);
               checkRunQuery();
            }
            break;
         }
      }

   }

   public void moveColumnDimensionFirst(Member member){
      moveDimensionFirst(member, onColumns);
   }
   public void moveRowDimensionFirst(Member member){
      moveDimensionFirst(member, onRows);
   }
   public void movePageDimensionFirst(Member member){
      moveDimensionFirst(member, onPages);
   }
   private void moveDimensionFirst(Member member, LinkedList linkList){
      QueryDimensionElement qde;
      Object element, previousElement;
      ListIterator it = linkList.listIterator();
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            element =  it.previous();
            if (it.hasPrevious()){
               it.remove();
               linkList.addFirst(element);
               checkRunQuery();
            }
            break;
         }
      }

   }

   public void moveColumnDimensionLast(Member member){
      moveDimensionLast(member, onColumns);
   }
   public void moveRowDimensionLast(Member member){
      moveDimensionLast(member, onRows);
   }
   public void movePageDimensionLast(Member member){
      moveDimensionLast(member, onPages);
   }
   private void moveDimensionLast(Member member, LinkedList linkList){
      QueryDimensionElement qde;
      Object element, previousElement;
      ListIterator it = linkList.listIterator();
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            if (it.hasNext()){
               it.previous();
               it.remove();
               linkList.addLast(qde);
               checkRunQuery();
            }
            break;
         }
      }

   }
   public void removeFilterRowDimensionFromQuery(Member member){
      // don't enable this dim. because if it is in a filter it cannot be on an axis
      removeDimensionFromQuery(member, onRows, false);
   }
   public void removeFilterColumnDimensionFromQuery(Member member){
      // don't enable this dim. because if it is in a filter it cannot be on an axis
      removeDimensionFromQuery(member, onColumns, false);
   }
   public void removeFilterPageDimensionFromQuery(Member member){
      // don't enable this dim. because if it is in a filter it cannot be on an axis
      removeDimensionFromQuery(member, onPages, false);
   }
   public void removeRowDimensionFromQuery(Member member){
      removeDimensionFromQuery(member, onRows, true);
   }
   public void removeColumnDimensionFromQuery(Member member){
      removeDimensionFromQuery(member, onColumns, true);
   }
   public void removePageDimensionFromQuery(Member member){
      removeDimensionFromQuery(member, onPages, true);
   }
   private void removeDimensionFromQuery(Member member, LinkedList linkList, boolean enableTreeElements){
      QueryDimensionElement qde;
      ListIterator it = linkList.listIterator();
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
//         S.out(member.getUniqueName() + " starts with " + qde.getHierarchyUniqueName() + "?");
         if (member.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            it.previous();
            it.remove();
            if (enableTreeElements){
               viewer.enableTreeElements( (QueryElement) qde);
            }
            checkRunQuery();
            break;
         }
      }

   }

   public void removeRowMemberFromQuery(Member memberToRemove){
      removeMemberFromQuery(memberToRemove, onRows);
   }
   public void removeColumnMemberFromQuery(Member memberToRemove){
      removeMemberFromQuery(memberToRemove, onColumns);
   }
   public void removeMeasureMemberFromQuery(Member memberToRemove){
      removeMemberFromQuery(memberToRemove, onMeasures);
   }
   public void removePageMemberFromQuery(Member memberToRemove){
      removeMemberFromQuery(memberToRemove, onPages);
   }
   public void removeMemberFromQuery(Member memberToRemove, LinkedList linkList){
      // this HAS to be a member, cannot be a level, so it's not QueryElement but Member var.
      QueryDimensionElement qde;
      ListIterator it = linkList.listIterator();
      if (memberToSortBy!=null && memberToSortBy== memberToRemove){
         loseSort();
      }
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
         S.out("memberToRemove.getUniqueName() = " + memberToRemove.getUniqueName());
         S.out("qde.getHierarchyUniqueName()=" + qde.getHierarchyUniqueName());
         if (memberToRemove.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            qde.removeMember((QueryElement)memberToRemove);
            // this could have been a last member in a dimension
            // which renders it invalid and should be removed from a query
            if (!qde.isValid()){
               it.previous();
               it.remove();
            }
            break;
         }
      }
      viewer.enableTreeElements((QueryElement)memberToRemove);
      checkRunQuery();
   }
   public void keepThisMemberOnlyOnRows(Member memberToKeep){
      keepThisMemberOnly(memberToKeep, onRows);
   }
   public void keepThisMemberOnlyOnColumns(Member memberToKeep){
      keepThisMemberOnly(memberToKeep, onColumns);
   }
   public void keepThisMemberOnlyOnMeasures(Member memberToKeep){
      keepThisMemberOnly(memberToKeep, onMeasures);
   }
   public void keepThisMemberOnlyOnPages(Member memberToKeep){
      keepThisMemberOnly(memberToKeep, onPages);
   }

   public void keepThisMemberOnly(Member memberToKeep, LinkedList linkList){
      QueryDimensionElement qde;
      ListIterator it = linkList.listIterator();
      if (   memberToSortBy!=null
          && memberToSortBy.getSortingExpression().equals(memberToKeep.getSortingExpression())){
         loseSort();
      }
      while (it.hasNext()) {
         qde = (QueryDimensionElement)it.next();
         if (memberToKeep.getUniqueName().startsWith(qde.getHierarchyUniqueName())) {
            qde.keepThisMemberOnly((QueryElement)memberToKeep);
            break;
         }
      }
      checkRunQuery();
   }

   public void clearRowAxis(){
      // enable these guys first:
      enableAxisMembers(onRows);
      onRows.clear();
      checkRunQuery();
   }
   public void clearColumnAxis(){
      enableAxisMembers(onColumns);
      enableAxisMembers(onMeasures);
      onColumns.clear();
      onMeasures.clear();
      checkRunQuery();
   }
   private void enableAxisMembers(LinkedList list){
      Iterator it = list.iterator();
      while (it.hasNext()) {
         viewer.enableTreeElements( (QueryElement) it.next());
      }
   }
   public void sortByThisMember(Member _memberToSortBy, String _sortType){
      memberToSortBy = _memberToSortBy;
      sortType = _sortType;
      checkRunQuery();
   }
   public void loseSort(){
      memberToSortBy = null;
   }

   public void addRowMemberToFilter(Member filterMember){
      if (onRows.size() == 1 && (viewer instanceof MdxResultViewer)){
         JOptionPane.showMessageDialog(   null
                                        , "You cannot send last dimension to filter(there must be at least one dimension left)!\n"
                                        , "Send member to filter"
                                        , JOptionPane.INFORMATION_MESSAGE);

         return;
      }
      if (filters == null){
         filters = new LinkedList();
      }
      filters.add(viewer.addMemberToFilter(filterMember));
      removeFilterRowDimensionFromQuery(filterMember);
//      checkRunQuery(); --> removeFilterRowDim... will do that
   }
   public void addColumnMemberToFilter(Member filterMember){
      if (onColumns.size() == 1 && (viewer instanceof MdxResultViewer)){
         JOptionPane.showMessageDialog(   null
                                        , "You cannot send last dimension to filter(there must be at least one dimension left)!\n"
                                        , "Send member to filter"
                                        , JOptionPane.INFORMATION_MESSAGE);

         return;
      }
      if (filters == null){
         filters = new LinkedList();
      }
      filters.add(viewer.addMemberToFilter(filterMember));
      removeFilterColumnDimensionFromQuery(filterMember);
//      checkRunQuery();  --> removeFilterColumnDim... will do that
   }
   public void addPageMemberToFilter(Member filterMember){
      if (filters == null){
         filters = new LinkedList();
      }
      filters.add(viewer.addMemberToFilter(filterMember));
      removeFilterPageDimensionFromQuery(filterMember);
//      checkRunQuery();  --> removeFilterColumnDim... will do that
   }

   public void dropFilterFromQuery(FilterTree filterToDrop){
      FilterTreeModel ftm;
      ListIterator it = filters.listIterator();
      while(it.hasNext()){
         ftm = (FilterTreeModel)it.next();
         if( ftm == (FilterTreeModel)filterToDrop.getTree().getModel()){
            it.previous();
            it.remove();
            viewer.dropFilterTree(filterToDrop);
            viewer.enableTreeElements(ftm.getAnyQueryElement());
            checkRunQuery();
            return;
         }
      }
      S.out("assert: Query:dropFilterFromQuery:Couldn't find filter to drop!");
   }
// ****************************************************************************************************
// When query is executed, I must update it with results that I get in the following cases:
//  1. (previous) query contained ToggleDrillState function, and now one of the QueryDimensionElements
//      is toggled, i.e. I must update it, and remove toggle flag
//  2. ?
   public void updateQueryWithResults(ExecuteResult er){
      QueryDimensionElement qde;
      Iterator it = onRows.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (qde.isToggled()){
            qde.updateWithResult(er.getAxis("Axis1"));
         }
      }
      it = onColumns.iterator();
      while(it.hasNext()){
         qde = (QueryDimensionElement)it.next();
         if (qde.isToggled()){
            qde.updateWithResult(er.getAxis("Axis0"));
         }
      }
      if (onPages.size()>0){
         it = onPages.iterator();
         while (it.hasNext()) {
            qde = (QueryDimensionElement) it.next();
            if (qde.isToggled()) {
               qde.updateWithResult(er.getAxis("Axis2"));
            }
         }
      }
   }

   public String getQuery(){
      String mdx  = "";
      String axMembers;
      if (canExecute()){
         // Query generation
         if (filters != null && filters.size()>0){
            ListIterator it = filters.listIterator();
            mdx += "WITH";
            while(it.hasNext()){
               // getQueryWithMemberExpression is indented by default:
               mdx += "\n" + ( (FilterTreeModel) it.next()).getQueryWithMemberExpression();
            }
            mdx += "\n";
         }

         mdx += "SELECT ";
         mdx += "\nNON EMPTY\n";
         if (onColumns.size()>0){
            mdx += "{\n"
               + "      {" + getAxisQueryExpression(onColumns) + "}"
               + "\n    * {" + getAxisQueryExpression(onMeasures) + "}"
               + "\n}  ON COLUMNS, \n";
         }else{
            mdx += "{\n"
               + "\n   {" + getAxisQueryExpression(onMeasures) + "}"
               + "\n}  ON COLUMNS, \n";
         }
         mdx += "\nNON EMPTY\n";

         if (memberToSortBy == null){
            mdx += "{\n"
                + getAxisQueryExpression(onRows)
                + "\n} ON ROWS";
         }else{
            mdx += "{\n"
                +  "   Order( {\n"
                +  getAxisQueryExpression(onRows)
                +  "\n       }"
                +  "\n   , " + memberToSortBy.getSortingExpression()
                +  "\n   , " + sortType + ")"
                +  "\n} ON ROWS";
         }

         if (onPages.size()>0){
            mdx += ",";
            mdx += "\nNON EMPTY\n";
            mdx += "   {\n"
               + getAxisQueryExpression(onPages)
               + "\n   } ON PAGES";
         }

         mdx += "\nFROM [" + cubeName + "]";

         if (filters != null && filters.size()>0){
            ListIterator it = filters.listIterator();
            mdx += "\nWHERE\n   (";
            while(it.hasNext()){
               // getQueryWithMemberExpression is indented by default:
               if (!it.hasPrevious()){
                  mdx += "\n    " + ( (FilterTreeModel) it.next()).getQueryWhereExpression();
               }else{
                  mdx += "\n    , " + ( (FilterTreeModel) it.next()).getQueryWhereExpression();
               }
            }
            mdx += "\n    )\n";
         }

         S.out("GENERATED QUERY:\n---------------------------\n\n" + mdx + "\n\n------------------------------");
         lastQueryGenerated = mdx;
         return mdx;
      }else{
         return null;
      }
   }
   public String toString(){
      return getQuery();
   }
   public String getLastQueryGenerated(){
      return lastQueryGenerated;
   }



}
@


1.3
log
@*** empty log message ***
@
text
@@


1.2
log
@*** empty log message ***
@
text
@@


1.1
log
@*** empty log message ***
@
text
@@

