head	1.52;
access;
symbols;
locks; strict;
comment	@# @;


1.52
date	2004.05.06.00.25.02;	author michald;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.03.09.06.45;	author michald;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.13.12.42.37;	author michald;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.09.07.04.39;	author michald;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.22.06.50.03;	author michald;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.21.07.01.13;	author michald;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.16.15.29.05;	author jiri_schmid;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.12.16.11.27;	author michald;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.11.07.59.00;	author michald;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.16.09.44.48;	author vacula;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.02.09.14.07;	author michald;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.29.13.20.52;	author jiri_schmid;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.16.05.44.58;	author michald;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.03.12.03.09;	author jiri_schmid;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.03.06.46.45;	author michald;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.01.04.33.09;	author michald;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.28.20.25.55;	author michald;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.28.16.56.06;	author jiri_schmid;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.28.11.39.13;	author michald;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.28.07.06.09;	author michald;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.20.08.17.34;	author michald;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.13.16.27.50;	author jiri_schmid;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.13.07.29.49;	author michald;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.11.14.03.19;	author jiri_schmid;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.10.20.52.35;	author michald;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.10.20.37.26;	author michald;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.10.18.51.59;	author michald;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.10.06.35.57;	author michald;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.07.09.35.11;	author jiri_schmid;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.07.07.36.43;	author michald;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.07.05.48.01;	author michald;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.29.05.43.19;	author michald;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.25.12.00.20;	author jiri_schmid;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.25.11.53.42;	author jiri_schmid;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.18.05.50.55;	author michald;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.15.10.59.39;	author michald;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.06.09.36.32;	author michald;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.04.05.12.23;	author michald;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.31.06.47.24;	author michald;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.30.07.46.09;	author michald;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.29.16.56.56;	author michald;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.29.14.36.42;	author jiri_schmid;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.29.06.52.46;	author michald;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.18.10.51.01;	author jiri_schmid;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.17.03.04.21;	author michald;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.11.05.40.58;	author michald;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.04.06.19.19;	author michald;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.23.08.59.38;	author michald;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.21.16.13.10;	author michald;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.20.08.42.32;	author michald;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.28.15.33.34;	author michald;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.27.12.18.12;	author michald;	state Exp;
branches;
next	;


desc
@@


1.52
log
@fix creation of the report without explicit format definition
@
text
@#-----------------------------------------------------
#  SQL Generator Library for the Bear Daemon
#-----------------------------------------------------
# $Id: SQLGen.pm,v 1.51 2004/05/03 09:06:45 michald Exp $

package SQLGen;

use strict;
use utf8;
binmode(STDOUT, ':utf8');
binmode(STDIN, ':utf8');

use Graph::Directed;
use Data::Dumper;

use ArrComb;	# provide combinations of array

my $tempG = {};	# temporary directed graph for physical objects
my $tempGa = {};	# temporary directed graph for logical objects
my $tempGo = {};	# temporary directed graph for objects dependency

#---------------------------------------

sub GraphTempInit {
	my $hs=shift;	# host/source
	$tempG->{$hs} = new Graph::Directed;	# init temporary Directed Graph of physical relations
}

#---------------------------------------

sub GraphPNInit {
	my $pn=shift;	# Project Name
	$tempGa->{$pn} = new Graph::Directed;	# init temporary Directed Graph of logical object (attributes and facts) relations
}

#---------------------------------------

sub GenAPSP {
	# make All-pairs Shortest Paths graph (MDg, MDga) from the temporary graphs ($tempG, tempGa)
	my $pn = shift;	# project name

	$main::MDga->{$pn} = $tempGa->{$pn}->TransitiveClosure_Floyd_Warshall;
	@@{$main::MDgaV->{$pn}} = _MDga2V($pn, $tempGa->{$pn});	# set array of the original attribute vertices, needed for Graph Viz as part of the Debug functions
	delete($tempGa->{$pn});	# delete temporary graph

	foreach my $src (keys %{$tempG}) {	# foreach source
		$main::MDg->{$pn}->{$src} = $tempG->{$src}->APSP_Floyd_Warshall;	# this add 'path' attribute to the MDg as well
		my ($s,$e);
		my @@edg = $tempG->{$src}->edges;
		while (@@edg) {	# copy joins into MDg
			$e = pop(@@edg);
			$s = pop(@@edg);
			$main::MDg->{$pn}->{$src}->set_attribute('join', $s, $e, $tempG->{$src}->get_attribute('join', $s, $e))
		}
		delete($tempG->{$src});	# delete temporary graph

		# add joins for vertices not directly connected
		foreach my $v ( $main::MDg->{$pn}->{$src}->vertices() ) {	# for each graph vertice
			foreach my $e ( $main::MDg->{$pn}->{$src}->successors($v) ) {	# for each successors of $v
				my @@p = @@{$main::MDg->{$pn}->{$src}->get_attribute('path',$v,$e)};	# get path
				if ( $#p>1 ) {	# if path has more than one vertex
					my $j = {};	# temporary hash for joins
					my @@allj = {};	# array of the joins for '*' role (means all roles)
					for my $i (1..$#p) {	# foreach member of the path
						my $join = $main::MDg->{$pn}->{$src}->get_attribute('join', $p[$i-1], $p[$i]);
						foreach my $r (keys %{$join}) {	# for each attribute role included in the join
							foreach (@@{$join->{$r}}) {	# for each join. Usually there is only one join per vertex, however it is possible to define multiple joins explicitly by hreference tag in meta-data
								push (@@{$j->{$r}}, $_);
							}
						}
					}

					my @@rolek = keys %{$j};	# array of all attribute roles included in the temporary join
					if ((exists $j->{'*'}) && ($#rolek >0)) {	# there is mix of specific real roles and '*' role (means all roles)
						foreach my $r (keys %{$j}) {	# for each attribute role included in the join
							next if $r eq '*';
							foreach (@@{$j->{'*'}}) {	# for each global join
								push (@@{$j->{$r}}, $_);
							}
						}
						delete $j->{'*'};
					}
										
					$main::MDg->{$pn}->{$src}->set_attribute('join', $v, $e, $j);

				}	# if path has more than one vertex
			}	# for each successors of $v
		}	# for each graph vertice

	}	# foreach source
	
}

#---------------------------------------

sub _MDga2V {	# set array of the vertices from the Directed Graph object
	my $pn = shift;	# project name
	my $dg = shift;	# directed graph
	
	my @@e = $dg->edges();
	my @@ret;
	my $v;
	while (@@e) {
		my $f = shift @@e; my ($fa,$fr) = ($f =~ /\./) ? ($f =~ /^(.+)(\..*)$/) : ($f,'');
		my $t = shift @@e; my ($ta,$tr) =  ($t =~ /\./) ? ($t =~ /^(.+)(\..*)$/) : ($t,''); #$t =~ s/\..*$//;
		next if $f eq $t;
		$v->{$fa}->{$ta}="$fr|$tr";
	}
	foreach my $f (keys %{$v}) {
		foreach my $t (keys %{$v->{$f}}) {
			push @@ret, $f;
			push @@ret, $t;
			push @@ret, $v->{$f}->{$t};
		}
	}
	return @@ret
}

#---------------------------------------

sub MD2graph {
# create edges for Directed Graph accordingly to PK/FK relations, vertexes are tables
	my $pn=shift;	# new object Project Name
	my $id=shift;	# new object ID
	
	my $nMD = $main::MD->{$pn}->{attr}->{$id};	# new metadata has to be of attribute type
	my ($role) = ($id =~ /\.(\w+)$/);	# get attribute role
	$role = '*' if !$role;
	my ($src1,$t1,$k1);
	if (defined @@{$nMD->{pk}}[0]) {
		# !!! temporary solution for @@{$nMD->{pk}}[0]
		# it's necessary make a cycle for all pk
		($src1,$t1,$k1) = (@@{$nMD->{pk}}[0] =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# PK source/table/column
		push(@@{$main::MDl->{$pn}->{$id}}, "$src1/$t1");
	} else {
		Bearlib::WriteLog("Attribute has no PK","AttrID=$id",2) if ($Const::LogLevel>1);
	}
	if ((ref($nMD->{fk}) eq 'ARRAY')&&(defined @@{$nMD->{fk}}[0])) {	# if there at least one FK presented
		foreach my $fk (@@{$nMD->{fk}}) {	# for each FK
			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
			push(@@{$main::MDl->{$pn}->{$id}}, "$src2/$t2");

			# !!! temporary solution for @@{$nMD->{pk}}[0]
			# it's necessary to try find PK in array, next only if PK from the same source not exists
			next if (!defined @@{$nMD->{pk}}[0]);	# if PK not exists
			if (($src1) && ($src2) && ($src1 eq $src2)) {	# only relations between tables located in the same sources is implemented in present
			# add edge to the Graph

				# add edge to $tempG - source of MDg
				$tempG->{$src1}->add_weighted_edge($t1, WGHT::weight($t1, $t2), $t2);
				my $join = $tempG->{$src1}->get_attribute('join', $t1, $t2);

				$join->{$role} = ["$t1.$k1=$t2.$k2"]; 
				next if (!exists $join->{$role});
				if (!$tempG->{$src1}->set_attribute('join', $t1, $t2, $join)) {
					Bearlib::WriteLog("Directed Graph Set Attribute Fails",join(', ',@@{$join->{$role}}),1) if ($Const::LogLevel>0);
				}
				# add attribute edge to $tempGa
				foreach my $id2 (@@{$main::MDk->{$pn}->{$src2}->{$t2}->{pk}}) {	# for each object mapped into $t2 as PK
					my ($r2) = ($id2 =~ /\.(\w+)$/);	# role of object mapped into $t2
					$r2 = '*' if !$r2;
					next if (($role ne '*')&&($r2 ne '*')&&($role ne $r2));	# don't add edge if attr has role and it is different from role of object mapped into $t2
					add_tmp_attr_edge($pn, $id, $id2);
				}

			} else {
				Bearlib::WriteLog("Wrong Relation Definition for $fk",'',1) if ($Const::LogLevel>0);
			}
		}					
	} else {
		Bearlib::WriteLog("Attribute has no FK","AttrID=$id",2) if ($Const::LogLevel>1);
	}
}

#---------------------------------------

sub MDh2graph {
# create edges for Directed Graph accordingly to hrelations
	my $pn = shift;		# project name
	my $hri = shift;	# hrelation ID
	my $md = shift;		# metadata directly loaded from file, attr are not expanded into "attr.role" form
	
	my $hr = $main::MD->{$pn}->{hrelation}->{$hri};
	my $groupFrom = $md->{attr}->{$hr->{from}->{id}}->{group} if exists $md->{attr}->{$hr->{from}->{id}}->{group};
	my $groupTo = $md->{attr}->{$hr->{to}->{id}}->{group} if exists $md->{attr}->{$hr->{to}->{id}}->{group};
	my @@roleFrom = keys %{$main::MD->{$pn}->{group}->{$groupFrom}->{role}} if exists $main::MD->{$pn}->{group}->{$groupFrom}->{role};
	my @@roleTo= keys %{$main::MD->{$pn}->{group}->{$groupTo}->{role}} if exists $main::MD->{$pn}->{group}->{$groupTo}->{role};
	if (@@roleFrom && @@roleTo) {
		if ($groupFrom eq $groupTo) {	# both attributes has the same role
			foreach my $r (@@roleFrom) {
				add_tmp_attr_edge($pn, "$hr->{from}->{id}.$r", "$hr->{to}->{id}.$r") if $hr->{to}->{card} eq 'N';
				add_tmp_attr_edge($pn, "$hr->{to}->{id}.$r", "$hr->{from}->{id}.$r") if $hr->{from}->{card} eq 'N';

				my ($src,$t,$k);
				foreach my $fk (@@{$main::MD->{$pn}->{attr}->{"$hr->{from}->{id}.$r"}->{fk}}) {	# for each FK for "from" table
					($src,$t,$k) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
					last if (exists $hr->{join}) && ($t eq $hr->{join}->{table});	# we've found FK in the table "from" specified in hrelation
				}
				foreach my $fk (@@{$main::MD->{$pn}->{attr}->{"$hr->{to}->{id}.$r"}->{fk}}) {	# for each FK for "to" table
					($src,$t,$k) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
					last if (exists $hr->{join}) && ($t eq $hr->{join}->{table});	# we've found FK in the table "to" specified in hrelation
				}
			}
		} else {	# hrelation is connecting attributes with different roles
			foreach my $rf (@@roleFrom) {
				foreach my $rt (@@roleTo) {
					add_tmp_attr_edge($pn, "$hr->{from}->{id}.$rf", "$hr->{to}->{id}.$rt") if $hr->{to}->{card} eq 'N';
					add_tmp_attr_edge($pn, "$hr->{to}->{id}.$rf", "$hr->{from}->{id}.$rt") if $hr->{from}->{card} eq 'N';
					add_tmp_tab_edge($hr, $rt);	# this aproach (usage of the specific role in his context) is not clear !!!
				}
			}
		}
	} elsif  (@@roleFrom) {	# only From Attr has role defined
		foreach my $r (@@roleFrom) {
			add_tmp_attr_edge($pn, "$hr->{from}->{id}.$r", $hr->{to}->{id}) if $hr->{to}->{card} eq 'N';
			add_tmp_attr_edge($pn, "$hr->{to}->{id}.$r", $hr->{from}->{id}) if $hr->{from}->{card} eq 'N';
		}
	} elsif  (@@roleTo) {	# only To Attr has role defined
		foreach my $r (@@roleFrom) {
			add_tmp_attr_edge($pn, $hr->{from}->{id}, "$hr->{to}->{id}.$r") if $hr->{to}->{card} eq 'N';
			add_tmp_attr_edge($pn, $hr->{to}->{id}, "$hr->{from}->{id}.$r") if $hr->{from}->{card} eq 'N';
		}
	} else {	# no roles are presented
		add_tmp_attr_edge($pn, $hr->{from}->{id}, $hr->{to}->{id}) if $hr->{to}->{card} eq 'N';
		add_tmp_attr_edge($pn, $hr->{to}->{id}, $hr->{from}->{id}) if $hr->{from}->{card} eq 'N';
	}
	add_tmp_tab_edge($hr, '*');
}

#---------------------------------------------------

sub add_tmp_tab_edge {	# add edge in DG of the $tempG (physical model)
	my $hr = shift;
	my $role = shift;
	foreach my $attr ($hr->{from}->{id}, $hr->{to}->{id}) {
		next if (!exists $hr->{join}) || (!exists $hr->{join}->{table});
		my ($src,$table) = ($hr->{join}->{table} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)$/);	# source/table

		my $lutable = "lu_$attr";	# should be set acordingly to attr PK !!!
		my $lutableid = "id";	# should be set acordingly to attr FK !!!
		my $tableid = "${attr}_id";	# should be set acordingly to attr PK !!!

		my $join;
		$tempG->{$src}->add_weighted_edge($table, 1, $lutable);	# !!! there should be caled WGHT::weight($t1, $t2)
		$join->{$role} = ["$lutable.$lutableid=$table.$tableid"];
		$tempG->{$src}->set_attribute('join', $table, $lutable, $join);
		if (exists $hr->{join}->{constrain}) {
			my $join_spec;
			$join_spec->{$role} = [$hr->{join}->{constrain}];	# this key will be used infrequently
			$tempG->{$src}->set_attribute('join_spec', $table, $lutable, $join_spec);
		}
	}
}

sub add_tmp_attr_edge {	# add edge into $tempGa
	my $pn = shift;	# project name
	my $id1 = shift;	# vertex from
	my $id2 = shift;	# vertex to
	$tempGa->{$pn}->add_edge($id1, $id2);
}
	
#---------------------------------------------------

sub get_obj_lnk {
	# returns specific object hash from report definition, the same if object is stored locally in report or if is there ID pointer only
	my $obj = shift;	# hash of report object
	my $el = shift;		# name of required element
	if (ref($obj->{$el}) eq 'HASH') {	# object is stored localy
		return $obj->{$el}
	} elsif (ref($obj->{$el}) eq 'ARRAY') {	# array of IDs is expected
		my @@a;
		foreach (@@{$obj->{$el}}) {
			my $o = Bear::GetMetadata(undef, $_);
			my $k = (keys %{$o})[0];
			push @@a, $o->{$k}->{$_};
		}
		return @@a
	} else {	# there is link to independent object (saved in $obj->{$el})
		return if (!$obj->{$el});
		my $o = Bear::GetMetadata(undef, $obj->{$el});
		my $k = (keys %{$o})[0];
		return $o->{$k}->{$obj->{$el}}
	}
}

#-----------------------------------------------------

sub PrepareSQL {
	# returns host/source and SQL Statement
	my $ID = shift;
	my $SQL = {};	# hash for output

	my $rep = Bear::GetMetadata(undef,$ID);
	my $pn = Bear::GetProjectName(undef,$ID);
	
	my $grid = get_obj_lnk($rep->{report}->{$ID}, 'var_def');
	$SQL->{Filter} = get_obj_lnk($rep->{report}->{$ID}, 'filter_def');
	my $attr={};

	if ( $rep->{report}->{$ID}->{report_type} eq 'grid' or $rep->{report}->{$ID}->{report_type} eq 'graph2d' ) {
		@@{$SQL->{Metric}} = @@{$grid->{metric}};	# array of metric IDs
		foreach (@@{$grid->{col}}, @@{$grid->{row}}) {	# set $attr hash keys to set of attributes involved
			next if ($_ eq $Const::MetricsIdent);	# don't include metric group identifier
			my $a;
			($a = $_) =~ s/~.*$//;	# cut attribute display (rest of string next to ~)
			$attr->{$a}++;
		}
	} elsif ( $rep->{report}->{$ID}->{report_type} eq 'graph3d' ) {
		foreach ( @@{$grid->{x}{items}}, @@{$grid->{y}{items}}, @@{$grid->{z}{items}},@@{$grid->{shape}{items}},@@{$grid->{diameter}{items}},@@{$grid->{transparency}{items}},@@{$grid->{color}{items}} ) {	# set $attr hash keys to set of attributes involved
			if ( Bear::GetObjectType(undef,$_) eq 'metric' ) {
				push(@@{$SQL->{Metric}},$_);
			}
			#elsif ( Bear::GetObjectType(undef,$_) eq 'attr' ) {	# ??? has each object defined object type(attr,metric) ?
			else {
				my $a;
				($a = $_) =~ s/~.*$//;	# cut attribute display (rest of string next to ~)
				$attr->{$a}++;
			}	
		}
	}

#	$SQL->{Report} = $rep;
	$SQL->{Grid} = $grid;
	@@{$SQL->{Attr}} = sort (keys %{$attr});

	my $m={};	# hash with specific key for each filtered or dimensionaled group of metrics
	foreach my $mid (@@{$SQL->{Metric}}) {	# make groups of metrics with same Dimensionality/Filtration
		my $mm = ${$main::MDi->{$mid}->{ptr}};
print Dumper($mm);
		my $dim = '';
		# if (aggr_type eq 'report') or (aggr_type eq 'specific') and aggr_def is not defined
		if ($mm->{aggr_type} eq 'specific') {
			$dim = join('|', @@{$mm->{aggr_def}});	# metric dimensionality
#!!! should be used only lower parent attributes of attributes already used in te report
		} elsif ($mm->{aggr_type} eq 'report') {
			$dim = '';
		} elsif ($mm->{aggr_type} eq 'none') {
			$dim = '_NONE_';
		}
		my $filt = get_obj_lnk($mm, 'filter_def');	# metric filter expression
		$filt = $filt->{expr} if ref($filt) eq 'HASH';	# ??? is it necessary if we've used get_obj_lnk ?

		push @@{$m->{$dim}->{$filt}->{$mm->{filter_intersect}}->{metr}}, $mid;	# put it into hash to consolidate uniform expresions
	}

print Dumper($m);


	foreach my $dim (keys %{$m}) {	# for each dimensional group of metrics
	
		my $suc;
		if ($dim) {	# if Metric Dimensionality is used let set string of attributes related to specific dimensionality
			$suc = '|'.join('|', grep {!/^$dim$/} $main::MDga->{$pn}->successors($dim)).'|';	# all successors of this dimensionality attribute
		}
		
		foreach my $filt (keys %{$m->{$dim}}) {	# for each filtered group of metrics
			foreach my $filtT (keys %{$m->{$dim}->{$filt}}) {	# for each type of filtation

				my $myDimFilt = $m->{$dim}->{$filt}->{$filtT};
				# select metrics involved in this Dimensionality/Filtration
				foreach my $mid (@@{$myDimFilt->{metr}}) {
					push @@{$myDimFilt->{mex}}, ${$main::MDi->{$mid}->{ptr}}->{expr};
				}

				# find facts involved in metrics
				my %f;
				foreach my $e (@@{$myDimFilt->{mex}}) {	# for each metric expression involved in this Dimensionality/Filtration
					foreach ($e=~/\[(.*?)\]/g) {	# add facts involved in this Dimensionality/Filtration
						$f{$_}++;
					}
				}

				# select attributes involved in this Dimensionality/Filtration
				my %att_v;	# attributes to view
				my %att_j;	# attributes to join
				foreach my $a (@@{$SQL->{Attr}}) {	# for each attribute
					next if $suc =~ /\|$a\|/;	# exclude attributes in relation to dimensionality attribute
					$att_v{$a}++;
					$att_j{$a}++;
				}

				if ($filt) {	# Metric has filter
					if ($filtT eq 'all') {	# join Report and Metric Level filters
						if ($SQL->{Filter}->{expr}) {
							$filt = "($filt) AND ($SQL->{Filter}->{expr})";
						}
					} elsif ($filtT eq 'non_rel') {	# cut Report Filter parts related to Metric level filter
						# !!! not implemented yet
					} elsif ($filtT eq 'na') {	# use Metric level filter only
					}
				} else {
					$filt = $SQL->{Filter}->{expr};
				}

				# report has filter
				if ($filt) {
					my @@obj;
					(@@obj) = ( $filt=~/\[(.+?)\]/g );	# array of the objects involved in filter
#print ">>>>$filt|".join(',',@@obj)."\n\n";
					foreach my $id (@@obj) {	# for each object involved in filter
						if ($main::MDi->{$id}->{type} eq 'attr') {	# filter object is a attribute
							$att_j{$id}++;
						} elsif ($main::MDi->{$id}->{type} eq 'fact') {
							$f{$id}++;
						} elsif ($main::MDi->{$id}->{type} eq 'metric') {
						} elsif ($main::MDi->{$id}->{type} eq 'def') {
						} else {	# error - disallowed object in filter
						}
					}
					# there is $filt definition complete (in form "... [attr.form]=3 ...") on this point
print ">>>>>>>> |$filt|\n\n";
					if ($Bear::lePO->decomposeLE($filt)) {
printf ">>>>>>>> %s\n\n", $Bear::lePO->printLE();
					} else {
print ">>>>>>>> Error on line ".$Bear::lePO->error->{LINE}.", char ".$Bear::lePO->error->{POS}.", near \"".$Bear::lePO->error->{STR}."\"\n";
					}
				}
				
				@@{$myDimFilt->{attr_j}} = sort keys %att_j;
				@@{$myDimFilt->{attr_g}} = sort keys %att_v;
				@@{$myDimFilt->{fact}} = sort keys %f;
				
				# make table combinations
				my $tcomb = tableCombinations([@@{$myDimFilt->{attr_j}}, @@{$myDimFilt->{fact}}], $main::MDl->{$pn});

				# get table involved in facts
				$myDimFilt->{ftbl} = getTablesFromObj($myDimFilt->{fact}, $pn);
#print Dumper($myDimFilt);
#print Dumper($tcomb);

				# find table combination with lower weigth
				my $tempMin = {};	# temporrary hash to store minimal combinations
				my $minW = 2**64;	# set machine infinity for minimal weight

				foreach my $src (keys %{$tcomb}) {	# for each data source
					my $comb = mkSelCombArr($myDimFilt->{ftbl}->{$src}, $tcomb->{$src});	# split list of table combinations into separate list of lookups and facts
#print Dumper($comb);
					foreach my $ti (sort keys %{$comb}) {	# get set of combinations, let start with lowest number of tables involved
						foreach my $fti (sort keys %{$comb->{$ti}}) {	# get set of combinations, let start with lowest number of fact tables involved
							foreach my $lti (sort keys %{$comb->{$ti}->{$fti}}) {	# get set of combinations, let start with lowest number of lookup tables involved
								foreach my $tc (@@{$comb->{$ti}->{$fti}->{$lti}}) {	# for each table combination
									my $w = 0;	# weight of join
									my @@js;	# array of join description strings
									my $jh = {};	# hash of joins
									C: foreach my $f (@@{$tc->{fa}}) {	# for each fact table
										foreach my $a (@@{$tc->{lu}}, @@{$tc->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
											my ($at,$ar)=split('\.', $a);	# split between attribute and role
#print ">>>at:$at, ar:$ar, a:$a, f:$f, pn:$pn, src:$src\n";
											if (!$main::MDg->{$pn}->{$src}->has_edge($at, $f)) {
#print ">0<\n";
												$w = -1; last C;	# let escape if there is no edge available
											}
											$w += $main::MDg->{$pn}->{$src}->get_attribute('weight', $at, $f);

											my $join = $main::MDg->{$pn}->{$src}->get_attribute('join', $at, $f);
											my $path = $main::MDg->{$pn}->{$src}->get_attribute('path', $at, $f);
#print "join: $join, path: $path\n";
											if (ref($join->{'*'}) eq 'ARRAY') {
#print '<'.join(':',@@{$tc->{fa}}).">1<\n";
												push @@js, mkJoinPath($path, $join->{'*'}, $ar, $tc->{fa}, $jh);
											} elsif (ref($join->{$ar}) eq 'ARRAY') {
#print '<'.join(':',@@{$tc->{fa}}).">2<\n";
												push @@js, mkJoinPath($path, $join->{$ar}, $ar, $tc->{fa}, $jh);
											} elsif ($at eq $f) {	# attribute and fact are stored in the same table
#print '<'.join(':',@@{$tc->{fa}}).">3<\n";
												push @@js, mkJoinPath($path, undef, $ar, $tc->{fa}, $jh);
											} else {
#print ">3<\n";
#												$w = -1; last C;	# let escape in case join for actual role is not defined
											}

											if ($w>$minW) {
												$w = -1; last C;	# let escape if weight is more than current minimal weight
											}
										}
									}
									if (($w>=0)&&($w<$minW)) {	# we've found current minimum
										$minW = $w;
#										my $temph = {'tc' => $tc, 'join' => [@@js], 'jh' => $jh};
										my $temph = {'join' => [@@js], 'jh' => $jh};
										push (@@{$myDimFilt->{c}->{$w}->{$src}}, $temph);
#										push (@@{$myDimFilt->{c}->{$w}->{$src}}, {'tbl' => $tc});
#										$tempMin->{$w}->{$src} = $tc;
										$tempMin->{$w}->{$src} = $temph;
									}
								}
							}
						}
					}
				}
#print $minW."\n";
#print Dumper($tempMin->{$minW});

				my $src = LB::src2run($tempMin->{$minW});	# choose data source to run query
				$myDimFilt->{comb}->{src} = $src;
				my $comb = $tempMin->{$minW}->{$src};	# get set of tables to join with minimal weight
				@@{$myDimFilt->{comb}->{join}} = keys %{$comb->{jh}->{join}};
				@@{$myDimFilt->{comb}->{table}} = keys %{$comb->{jh}->{table}};

				my %atr;
				foreach my $atrID (@@{$myDimFilt->{attr_j}}) {	# for each attribute
					my $a = attr2tableCol($atrID, $src, $comb->{jh}->{table});
					$atr{$atrID} = $a;
					push @@{$myDimFilt->{comb}->{attr_j}}, $a;
					push @@{$myDimFilt->{comb}->{attr_g}}, $a if exists $att_v{$atrID};
				}
				foreach my $atr (keys %atr) {	# substitute attr ID to table.col in filter
					$filt =~ s/\[$atr\]/$atr{$atr}/g;
				}
#print "///////////",Dumper($myDimFilt->{mex});

				my %fa;
#				foreach my $metr (@@{$myDimFilt->{mex}}) {	# collect facts for each metric
#					foreach my $fact ($metr =~ /\[(\w+)\]/g) {
#						$fa{$fact} = fact2tableCol($fact, $src, $comb->{jh}->{table}) if !exists $fa{$fact};	# we are setting hash to handle metrics based on the same facts effectively
#					}
#				}
				foreach my $fact (@@{$myDimFilt->{fact}}) {	# foreach fact involved in filter
					$fa{$fact} = fact2tableCol($fact, $src, $comb->{jh}->{table}) if !exists $fa{$fact};
				}
				foreach my $metr (@@{$myDimFilt->{mex}}) {	# for each metric
					foreach my $fact (keys %fa) {
						$metr =~ s/\[$fact\]/$fa{$fact}/g;
					}
					push @@{$myDimFilt->{comb}->{metr}}, $metr;
				}
				foreach my $fct (keys %fa) {	# substitute attr ID to table.col in filter
					$filt =~ s/\[$fct\]/$fa{$fct}/g;
				}
#print "...........",Dumper($myDimFilt->{mex});
				delete $myDimFilt->{mex};	# delete temporary array of Metric Expressions

#				foreach my $f (@@{$comb->{tc}->{fa}}) {	# for each fact table
#					foreach my $a (@@{$comb->{tc}->{lu}}, @@{$comb->{tc}->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
#							$myDimFilt->{comb}->{join}->{"$a -> $f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
#					}
#				}
				$myDimFilt->{comb}->{filter} = $filt;
				$myDimFilt->{comb}->{having} = undef;
				@@{$myDimFilt->{comb}->{order}} = ();
				$myDimFilt->{comb}->{limit} = '';	# in form "[offset,] rows"

print Dumper($myDimFilt->{comb});

				my $sql = SQL::queryGen($pn, $myDimFilt->{comb});	# call specific plugin

#				$myDimFilt->{SQL} = $sql;

				push @@{$SQL->{res}}, { 
					'SQL'=>$sql, 
					'SRC'=>$myDimFilt->{comb}->{src}, 
					'METR'=>$myDimFilt->{metr}, 
					'ATTR'=>$myDimFilt->{attr_g} 
				}
			} # for each type of filtation
		} # for each filtered group of metrics
	} # for each dimensional group of metrics

#print Dumper($SQL->{res});
#	$SQL->{m} = $m;

	return $SQL->{res};
#	return { ATTR=>[@@{$SQL->{Attr}}],
#			METRIC=>[@@{$SQL->{Grid}->{metric}}],
#			FILTER=>$SQL->{Filter},
#			SQL=>$SQL->{Filter},
#			DEBUG=>$SQL->{m} };	# !!! DEBUG hash is for debuging purposes only

}

#-----------

sub attr2tableCol {
# returns "table:role.column' (PK of FK) for specific attribute which source is located in one of available tables
	my $ID = shift;		# attribute ID
	my $src = shift;	# data source
	my $tabs = shift;	# hash of available tables

print "============== $ID = $src ===== ".join(',',keys %{$tabs})."\n";

	my ($atr, $role) = split('\.', $ID);

	# !!! temporary solution for @@{$nMD->{pk}}[0]
	# it's necessary make a cycle for all pk
	my ($h, $d, $t, $c) = split('/', @@{${$main::MDi->{$ID}->{ptr}}->{pk}}[0]);
	if ($role) { $t = "$t:$role" };	# add role to table identifier in consodance with key structure in $tabs hash
#print "==============$t\n";
	if (($src eq "$h/$d") && (exists $tabs->{$t})) {
		return "$t.$c"
	}
	
	foreach (@@{${$main::MDi->{$ID}->{ptr}}->{fk}}) {
		my ($h, $d, $t, $c) = split('/', $_);
		if ($role) { $t = "$t:$role" };	# add role to table identifier in consodance with key structure in $tabs hash
#print "==============$t\n";
		if (($src eq "$h/$d") && (exists $tabs->{$t})) {
			return "$t.$c"
		}
	}

	return "'ERROR for ID=$ID'";	# available table not found
}

#-----------

sub fact2tableCol {
# returns "table.column' (PK of FK) for specific fact which source is located in one of @@tabs
	my $ID = shift;		# fact ID
	my $src = shift;	# data source
	my $tabs = shift;	# hash of available tables

#print "ID: $ID, $src".Dumper($tabs);
	foreach (@@{${$main::MDi->{$ID}->{ptr}}->{expr}}) {
		my ($h, $d, $t, $c) = split('/', $_);
		if (($src eq "$h/$d") && (exists $tabs->{$t})) {
			$t =~ s/:\w*//;	# cut role part of table name
			return "$t.$c"
		}
	}

	return -1;	# available table not found
}

#-----------

sub mkJoinPath {	
	my $path = shift;	# array of tables on the path
	my $join = shift;	# array of joins
	my $role = shift;	# role of the attribute
	my $ft = shift;		# array of the fact table
	my $jh = shift;		# hash for output
	
#print " ........... $path, $join, $role, $ft, $jh ........\n";
	$role = ':'.$role if $role;
	my $i = 0;
#	my $ftre = '^'.join('^|$', @@{$ft}).'$';	# RE for recognition of Fact Tables
	my $ftre = '\b'.join('\b|\b', @@{$ft}).'\b';	# RE for recognition of Fact Tables
	my $ret = @@{$path}[$i].$role;	# return string in form table{join}table{join}table
	$jh->{table}->{@@{$path}[$i].$role}++;	# add table[:role] to $jh hash
	foreach my $j (@@{$join}) {	# for each join
		$i++;
		my $r = (@@{$path}[$i]!~$ftre) ? $role : '';	# don't add role to fact table
#print "\n$ftre: $j";
		my $jj = $j;
		$jj =~ s/([^.= ]+)\.([^.= ]+)/$1$role.$2/g;	# !!! # add role to table name in join definition
		$jj =~ s/($ftre)$role/$1/g;	# drop role from fact table
#print "---$jj\n";
		$ret .= '{'.$jj.'}'.@@{$path}[$i].$r;
		$jh->{table}->{@@{$path}[$i].$r}++;
		$jh->{join}->{$jj}++;
	}
	return $ret

}

#-----------

sub mkSelCombArr {	
# take table combinations and split it into two separate arrays, one for lookups an second for facts
# result is arranged into hash with keys representing number of tables presented in lookup and fact separate arrays
	my $fact = shift;
	my $comb = shift;

	my $fre = '^'.join('(\.\w+)?$|^', @@{$fact}).'(\.\w+)?$';	# prepare RE to cut role from table name if table is recognized as fact table
	my $res = {};	# hash for results
	foreach (@@{$comb}) {
		my @@fa=();	# array for fact tables
		my @@lu=();	# array for lookup tables
		foreach (@@{$_}) {
			if ($_=~/$fre/) {
				push @@fa, $_;
			} else {
				push @@lu, $_;
			}
		}
		my $t={};
		@@{$t->{lu}} = @@lu;
		@@{$t->{fa}} = @@fa;
		push @@{$res->{$#fa+$#lu+2}->{$#fa+1}->{$#lu+1}}, $t;
	}
	return $res;
}

#-----------

sub tableCombinations {
# make combinations of physical tables able to cover join of specific logical objects
# in case attribute has role, role name is connected to table in form table.role
	my $attr = shift;	# array of attributes
	my $lut = shift;	# hash of physical tables which covers definitions of logical objects
	my $h={};	# temporary hash to store arrays of tables for each attribute
	
	my $i=0;	# attribute index in @@attr
	foreach my $a (@@{$attr}) {	# for each attribute
		my ($role) = ($a =~ /(\.\w+)/);
		foreach my $tbl (@@{$lut->{$a}}) {	# for each table containing key definition of attribute
			my ($src,$t) = ($tbl =~ /(.+)\/(.+?)$/);	# split source and table
			push @@{$h->{$src}[$i]}, $t.$role;
		}
		$i++;
	}
	# $h is set at this point
#print "///////////// arrays of tables for each attribute\n";
#print Dumper($h);

	my $res = {};	# hash for results
	foreach my $src (keys %{$h}) {	# for each data source presented in $h
		my @@i;	# array of cardinalities of arays of tables
		foreach (@@{$h->{$src}}) {
			push @@i, scalar @@{$_} if defined $_;
		}
		next if scalar @@i != scalar @@{$attr};	# next if not all attributes has physical table definition on this data source
		# @@i is set at this point
		
		ArrComb::init(@@i);

		my $comb={};	# hash for temporary store of lookup table combinations
		for (my $i=0; $i<$ArrComb::rep; $i++) {	# for each possible combination of indexes
			my $hh={};
			my $j=0;
			foreach (ArrComb::getIndex()) {	# for each index from this combination
				$hh->{$h->{$src}[$j][$_]}++;
				$j++;
			}
			$comb->{join('|',sort keys %{$hh})}++;	# put it into the hash to avoid redundand combinations
		}
		my $i=0;
		foreach (keys %{$comb}) {
			push @@{$res->{$src}}, [split('\|',$_)];	# prepare resulting hash
			$i++;
		}
	}
#print "///////////// results of tableCombinations\n";
#print Dumper($res);
	return $res;
}

#-----------

sub getTablesFromObj {
	my $f=shift;
	my $pn=shift;
	my $ft={};
	my $ftt={};
	foreach my $f (@@{$f}) {	# for each table containing specific object
		foreach (@@{$main::MDl->{$pn}->{$f}}) {
			my ($src,$t) = ($_ =~ /(.+)\/(.+?)$/);	# split source and table
			$ft->{$src}->{$t}++
		}
	}
	foreach (keys %{$ft}) {
		@@{$ftt->{$_}} = sort keys %{$ft->{$_}};
	}
	return $ftt;
}

#---------------------------------------

1

__END__
@


1.51
log
@N:M implementation, foundation for slowly changing dimensions
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.50 2004/04/13 12:42:37 michald Exp $
d296 2
a297 3
	my $form = get_obj_lnk($rep->{'report'}->{$ID}, 'format_def');
	my $grid = get_obj_lnk($rep->{'report'}->{$ID}, 'var_def');
	$SQL->{Filter} = get_obj_lnk($rep->{'report'}->{$ID}, 'filter_def');
d300 1
a300 1
	if ( $form->{type} eq "grid" or $form->{type} eq "graph2d" ) {	# !!! this should be better to identify in accordance with grid form
d308 1
a308 1
	} elsif ( $form->{type} eq "graph3d" ) {	# !!! this should be better to identify in accordance with grid form
a322 1
#	$SQL->{Format} = $form;
@


1.50
log
@foundation for N:M relations
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.49 2004/04/09 07:04:39 michald Exp $
d104 2
a105 2
		my $f = shift @@e; $f =~ s/\..*$//;
		my $t = shift @@e; $t =~ s/\..*$//;
d107 1
a107 1
		$v->{$f}->{$t}++;
d113 1
d180 1
a180 1
	my $hri = shift;	# hrelation
d193 10
d209 1
d227 1
a227 10

#!!!!!!!!!!!
=block
foreach ('typ_dne', 'datum') {
	my $join;
	$tempG->{'localhost/demo_bee'}->add_weighted_edge('r_datum_typ_dne', 1, "lu_$_");
	$join->{'*'} = ["lu_$_.id=r_datum_typ_dne.${_}_id"];
	$tempG->{'localhost/demo_bee'}->set_attribute('join', 'r_datum_typ_dne', "lu_$_", $join);
}
=cut
d232 23
@


1.49
log
@Directed Graph visualization for debugging purposes implemented - need to install GraphViz (look at README)
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.48 2004/03/22 06:50:03 michald Exp $
d39 1
a39 1
	# make All-pairs Shortest Paths graph for $tempG temp graph
d43 1
a43 1
	@@{$main::MDgaV->{$pn}} = _MDga2V($pn, $tempGa->{$pn});	# set array of the original attribute vertices
d47 1
a47 1
		$main::MDg->{$pn}->{$src} = $tempG->{$src}->APSP_Floyd_Warshall;
d62 6
a67 7
					my $j = {};
					my $rch;
					for my $i (1..$#p) {
						my $tmp = $main::MDg->{$pn}->{$src}->get_attribute('join', $p[$i-1], $p[$i]);
						foreach my $r (keys %{$tmp}) {	# for each attribute role
							$rch->{$r}++;
							foreach (@@{$tmp->{$r}}) {	# for each join, usually there is only one join per vertex, however is it possible to define multiple joins explicitly by hreference tag in meta-data
d72 8
a79 3
					foreach (keys %{$rch}) {	# has all roles equivalent number of joins?
						if ($rch->{$_}++ != $#p) {
							Bearlib::WriteLog("Joins are not fully defined for specific path","Path: $v->$e, Role: $_",1) if ($Const::LogLevel>0);
d81 1
d83 1
a84 3
				}
			}
		}
d86 5
a90 1
	}
d96 1
a96 1
sub _MDga2V {
d124 1
d126 1
a126 1
	my ($role) = ($id =~ /^[0-9a-f]{1,10}\.(\w+)$/);	# get attribute role
d145 2
a146 2
			if (($src1) && ($src2)) {		# add edge to the Graph
				next if ($src1 ne $src2);	# only relations between tables located in the same sources is implemented in present
a152 1
#				@@{$join->{$role}} = [$nMD->{join}] if $nMD->{join};	# !!! need reimplementation: explicit join can be part of hrelation
a156 1

d159 3
a161 2
					my ($r2) = ($id2 =~ /^[0-9a-f]{1,10}\.(\w+)$/);	# role of object mapped into $t2
					next if ($role&&$r2&&($role ne $r2));	# don't add edge if attr has role and it is different from role of object mapped into $t2
d174 53
d275 1
a275 1
	if ( $form->{type} eq "grid" or $form->{type} eq "graph2d" ) {
d283 1
a283 1
	} elsif ( $form->{type} eq "graph3d" ) {
d606 2
a607 2
	my $ft = shift;	# array of the fact table
	my $jh = shift;	# hash for output
@


1.48
log
@Weight Estimator Plug-In intrduction
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.47 2004/03/21 07:01:13 michald Exp $
d43 1
d89 24
d129 1
a129 1
	if ((ref($nMD->{fk}) eq 'ARRAY')&&(defined @@{$nMD->{fk}}[0])) {
d170 3
a172 3
	my $pn = shift;
	my $id1 = shift;
	my $id2 = shift;
d326 1
a326 2
				}
				# there is $filt definition complete (in form "... [attr.form]=3 ...") on this point
d328 1
a328 1
				if ($Bear::lePO->decomposeLE($filt)) {
d330 1
a330 1
				} else {
d332 1
@


1.47
log
@slight modification of the Metric Filter Intersection MD presentation
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.45 2004/03/12 16:11:27 michald Exp $
d116 1
a116 1
				$tempG->{$src1}->add_weighted_edge($t1, 1, $t2);
@


1.46
log
@filter and aggregation level handling rules on metric page changed
@
text
@a14 1
use DecompLE;
a20 1
my $lePO = DecompLE->new("$Const::PWD/$Const::LEGrm");	# create object for filter logical expresion parsing and decomposition
a184 2
	$lePO->metricHash(\$main::MD->{metric});	# set metrics hash for further filter decomposition

d304 2
a305 2
				if ($lePO->decomposeLE($filt)) {
printf ">>>>>>>> %s\n\n", $lePO->printLE();
d307 1
a307 1
print ">>>>>>>> Error on line ".$lePO->error->{LINE}.", char ".$lePO->error->{POS}.", near \"".$lePO->error->{STR}."\"\n";
@


1.45
log
@minor fixes and some comments
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.44 2004/03/11 07:59:00 michald Exp $
d22 1
a22 1
my $lePO = DecompLE->new($Const::LEGrm);	# create object for filter logical expresion parsing and decomposition
@


1.44
log
@initial implementation of caches in the local DB
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.43 2004/02/16 09:44:48 vacula Exp $
a192 2
	my $sql;
	my $m={};	# hash with specific key for each filtered or dimensionaled group of metrics
d202 1
a202 2
	}
	elsif ( $form->{type} eq "graph3d" ) {
d221 1
d224 1
d228 2
a229 1
			$dim = join('|', @@{$mm->{aggr_def}}) if $#{$mm->{aggr_def}};	# metric dimensionality
d469 1
a469 1
# returns "table:role.column' (PK of FK) for specific attribute which source is located in one of @@tabs
@


1.43
log
@added graph3d to function PrepareSQL
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.42 2004/02/02 09:14:07 michald Exp $
d15 1
d22 1
d186 2
a187 1

d241 1
a241 1
#print Dumper($m);
a255 1
	#			@@{$myDimFilt->{mex}} = sort keys %{$myDimFilt->{metr}};
a258 1
	#			delete $myDimFilt->{metr};
d293 1
a293 1
					(@@obj) = ( $filt=~/\[(.+?)\]/g );
d306 8
d315 1
a315 1
				@@{$myDimFilt->{attr_v}} = sort keys %att_v;
d317 1
a317 1

d332 1
a332 1
#	print Dumper($comb);
d343 1
a343 1
#	print ">>>at:$at, ar:$ar, a:$a, f:$f, pn:$pn, src:$src\n";
d345 1
a345 1
#	print ">0<\n";
d352 1
a352 1
#	print "join: $join, path: $path\n";
d354 1
a354 1
	#print '<'.join(':',@@{$tc->{fa}}).">1<\n";
d357 1
a357 1
#	print '<'.join(':',@@{$tc->{fa}}).">2<\n";
d360 1
a360 1
#	print '<'.join(':',@@{$tc->{fa}}).">3<\n";
d363 2
a364 2
	#print ">3<\n";
	#											$w = -1; last C;	# let escape in case join for actual role is not defined
d374 1
a374 1
	#									my $temph = {'tc' => $tc, 'join' => [@@js], 'jh' => $jh};
d377 2
a378 2
	#									push (@@{$myDimFilt->{c}->{$w}->{$src}}, {'tbl' => $tc});
	#									$tempMin->{$w}->{$src} = $tc;
d392 2
a393 1
				$myDimFilt->{comb}->{tbl} = $comb;
d400 1
a400 1
					push @@{$myDimFilt->{comb}->{attr_v}}, $a if exists $att_v{$atrID};
d405 1
a405 1
	#print "///////////",Dumper($myDimFilt->{mex});
d425 1
a425 1
	#print "...........",Dumper($myDimFilt->{mex});
d428 5
a432 5
	#			foreach my $f (@@{$comb->{tc}->{fa}}) {	# for each fact table
	#				foreach my $a (@@{$comb->{tc}->{lu}}, @@{$comb->{tc}->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
	#						$myDimFilt->{comb}->{join}->{"$a -> $f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
	#				}
	#			}
d434 3
d438 1
a438 1
	#print Dumper($myDimFilt->{comb});
d442 1
a442 1
	#			$myDimFilt->{SQL} = $sql;
d448 5
a452 5
					'ATTR'=>$myDimFilt->{attr_v} 
				};
			}
		}
	}
@


1.42
log
@Make independent project specific spaces in MDk, MDl
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.41 2004/01/29 13:20:52 jiri_schmid Exp $
d185 1
a188 1
	@@{$SQL->{Metric}} = @@{$grid->{metric}};	# array of metric IDs
d190 24
a213 5
	foreach (@@{$grid->{col}}, @@{$grid->{row}}) {	# set $attr hash keys to set of attributes involved
		next if ($_ eq $Const::MetricsIdent);	# don't include metric group identifier
		my $a;
		($a = $_) =~ s/~.*$//;	# cut attribute display (rest of string next to ~)
		$attr->{$a}++;
a220 3
	my $sql;
	my $m={};	# hash with specific key for each filtered or dimensionaled group of metrics

d234 1
a234 1
		
d240 1
d379 1
@


1.41
log
@collected tab implemented
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.40 2003/12/16 05:44:58 michald Exp $
d100 1
a100 1
		push(@@{$main::MDl->{$id}}, "$src1/$t1");
d107 1
a107 1
			push(@@{$main::MDl->{$id}}, "$src2/$t2");
d127 1
a127 1
				foreach my $id2 (@@{$main::MDk->{$src2}->{$t2}->{pk}}) {	# for each object mapped into $t2 as PK
d293 1
a293 1
				my $tcomb = tableCombinations([@@{$myDimFilt->{attr_j}}, @@{$myDimFilt->{fact}}], $main::MDl);
d296 1
a296 1
				$myDimFilt->{ftbl} = getTablesFromObj($myDimFilt->{fact});
d443 1
a443 1
#print "============== $ID = $src ===== ".join(',',keys %{$tabs})."\n";
d606 1
d610 1
a610 1
		foreach (@@{$main::MDl->{$f}}) {
@


1.40
log
@filter on fact implementation
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.39 2003/12/03 12:03:09 jiri_schmid Exp $
a94 1

d118 1
a118 1
				
@


1.39
log
@fixed generating header in grid, minor visual improvments
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.38 2003/12/03 06:46:45 michald Exp $
a249 1
				@@{$myDimFilt->{fact}} = sort keys %f;
d282 1
d291 1
d381 7
a387 5
				foreach my $metr (@@{$myDimFilt->{mex}}) {	# collect facts for each metric
					foreach my $fact ($metr =~ /\[(\w+)\]/g) {
	#print ">>>	$fact\n";
						$fa{$fact} = fact2tableCol($fact, $src, $comb->{jh}->{table}) if !exists $fa{$fact};	# we are setting hash to handle metrics based on the same facts effectively
					}
a388 1

d394 3
@


1.38
log
@fix for selects from only the fact table
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.37 2003/12/01 04:33:09 michald Exp $
d223 1
a223 1
print Dumper($m);
d278 1
a278 1
print ">>>>$filt|".join(',',@@obj)."\n\n";
d297 2
a298 2
print Dumper($myDimFilt);
print Dumper($tcomb);
d306 1
a306 1
	print Dumper($comb);
d317 1
a317 1
	print ">>>at:$at, ar:$ar, a:$a, f:$f, pn:$pn, src:$src\n";
d319 1
a319 1
	print ">0<\n";
d326 1
a326 1
	print "join: $join, path: $path\n";
d331 1
a331 1
	print '<'.join(':',@@{$tc->{fa}}).">2<\n";
d334 1
a334 1
	print '<'.join(':',@@{$tc->{fa}}).">3<\n";
d360 2
a361 2
print $minW."\n";
print Dumper($tempMin->{$minW});
d493 1
a493 1
print " ........... $path, $join, $role, $ft, $jh ........\n";
@


1.37
log
@filters (attribute ID constrains)
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.36 2003/11/28 20:25:55 michald Exp $
d220 1
a220 3
#		$m->{$dim}->{$filt}->{metr}->{$mm->{expr}}++;	# put it into hash to consolidate uniform expresions
		push @@{$m->{$dim}->{$filt}->{metr}}, $mid;	# put it into hash to consolidate uniform expresions
#		$m->{$dim}->{$filt}->{metr}->{$mm} = $mm->{expr};	# put it into hash to be able to sort it by metric ID lately
d223 1
a223 2
#use Data::Dumper;
#print Dumper($m);
d233 1
d235 25
a259 7
			my $myDimFilt = $m->{$dim}->{$filt};
			# select metrics involved in this Dimensionality/Filtration
#			@@{$myDimFilt->{mex}} = sort keys %{$myDimFilt->{metr}};
			foreach my $mid (@@{$myDimFilt->{metr}}) {
				push @@{$myDimFilt->{mex}}, ${$main::MDi->{$mid}->{ptr}}->{expr};
			}
#			delete $myDimFilt->{metr};
d261 11
a271 5
			# find facts involved in metrics
			my %f;
			foreach my $e (@@{$myDimFilt->{mex}}) {	# for each metric expression involved in this Dimensionality/Filtration
				foreach ($e=~/\[(.*?)\]/g) {	# add facts involved in this Dimensionality/Filtration
					$f{$_}++;
d273 5
a277 23
			}
			@@{$myDimFilt->{fact}} = sort keys %f;
			
			# select attributes involved in this Dimensionality/Filtration
			my %att_v;	# attributes to view
			my %att_j;	# attributes to join
			foreach my $a (@@{$SQL->{Attr}}) {	# for each attribute
				next if $suc =~ /\|$a\|/;	# exclude attributes in relation to dimensionality attribute
				$att_v{$a}++;
				$att_j{$a}++;
			}
			
			# join Report and Metric Level filters
			if ($filt && $SQL->{Filter}->{expr}) {
				$filt = "($filt) AND ($SQL->{Filter}->{expr})";
			} elsif (!$filt && $SQL->{Filter}->{expr}) {
				$filt = $SQL->{Filter}->{expr};
			}
			
			# metric has filter
			if ($filt) {
				my @@obj;
				(@@obj) = ( $filt=~/\[(.+?)\]/g );
d279 8
a286 7
				foreach my $id (@@obj) {	# for each object involved in filter
					if ($main::MDi->{$id}->{type} eq 'attr') {	# filter object is a attribute
						$att_j{$id}++;
					} elsif ($main::MDi->{$id}->{type} eq 'fact') {
					} elsif ($main::MDi->{$id}->{type} eq 'metric') {
					} elsif ($main::MDi->{$id}->{type} eq 'def') {
					} else {	# error - disallowed object in filter
d289 2
a290 6
			}
			@@{$myDimFilt->{attr_j}} = sort keys %att_j;
			@@{$myDimFilt->{attr_v}} = sort keys %att_v;
			
			# make table combinations
			my $tcomb = tableCombinations([@@{$myDimFilt->{attr_j}}, @@{$myDimFilt->{fact}}], $main::MDl);
d292 2
a293 26
			# get table involved in facts
			$myDimFilt->{ftbl} = getTablesFromObj($myDimFilt->{fact});
		
			# find table combination with lower weigth
			my $tempMin = {};	# temporrary hash to store minimal combinations
			my $minW = 2**64;	# set machine infinity for minimal weight

			foreach my $src (keys %{$tcomb}) {	# for each data source
				my $comb = mkSelCombArr($myDimFilt->{ftbl}->{$src}, $tcomb->{$src});	# split list of table combinations into separate list of lookups and facts
#print Dumper($comb);
				foreach my $ti (sort keys %{$comb}) {	# get set of combinations, let start with lowest number of tables involved
					foreach my $fti (sort keys %{$comb->{$ti}}) {	# get set of combinations, let start with lowest number of fact tables involved
						foreach my $lti (sort keys %{$comb->{$ti}->{$fti}}) {	# get set of combinations, let start with lowest number of lookup tables involved
							foreach my $tc (@@{$comb->{$ti}->{$fti}->{$lti}}) {	# for each table combination
								my $w = 0;	# weight of join
								my @@js;	# array of join description strings
								my $jh = {};	# hash of joins
								C: foreach my $f (@@{$tc->{fa}}) {	# for each fact table
									foreach my $a (@@{$tc->{lu}}, @@{$tc->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
										my ($at,$ar)=split('\.', $a);	# split between attribute and role
#print ">>>$at, $ar, $a, $f, $pn, $src";
										if (!$main::MDg->{$pn}->{$src}->has_edge($at, $f)) {
#print ">0<\n";
											$w = -1; last C;	# let escape if there is no edge available
										}
										$w += $main::MDg->{$pn}->{$src}->get_attribute('weight', $at, $f);
d295 49
a343 15
										my $join = $main::MDg->{$pn}->{$src}->get_attribute('join', $at, $f);
										my $path = $main::MDg->{$pn}->{$src}->get_attribute('path', $at, $f);
										if (ref($join->{'*'}) eq 'ARRAY') {
#print '<'.join(':',@@{$tc->{fa}}).">1<\n";
											push @@js, mkJoinPath($path, $join->{'*'}, $ar, $tc->{fa}, $jh);
										} elsif (ref($join->{$ar}) eq 'ARRAY') {
#print '<'.join(':',@@{$tc->{fa}}).">2<\n";
											push @@js, mkJoinPath($path, $join->{$ar}, $ar, $tc->{fa}, $jh);
										} else {
#print ">3<\n";
#											$w = -1; last C;	# let escape in case join for actual role is not defined
										}

										if ($w>$minW) {
											$w = -1; last C;	# let escape if weight is more than current minimal weight
d345 9
a355 9
								if (($w>=0)&&($w<$minW)) {	# we've found current minimum
									$minW = $w;
#									my $temph = {'tc' => $tc, 'join' => [@@js], 'jh' => $jh};
									my $temph = {'join' => [@@js], 'jh' => $jh};
									push (@@{$myDimFilt->{c}->{$w}->{$src}}, $temph);
#									push (@@{$myDimFilt->{c}->{$w}->{$src}}, {'tbl' => $tc});
#									$tempMin->{$w}->{$src} = $tc;
									$tempMin->{$w}->{$src} = $temph;
								}
d360 18
a377 19
			}
#print $minW."\n";
#print Dumper($tempMin->{$minW});
			my $src = LB::src2run($tempMin->{$minW});	# choose data source to run query
			$myDimFilt->{comb}->{src} = $src;
			my $comb = $tempMin->{$minW}->{$src};	# get set of tables to join with minimal weight
			$myDimFilt->{comb}->{tbl} = $comb;

			my %atr;
			foreach my $atrID (@@{$myDimFilt->{attr_j}}) {	# for each attribute
				my $a = attr2tableCol($atrID, $src, $comb->{jh}->{table});
				$atr{$atrID} = $a;
				push @@{$myDimFilt->{comb}->{attr_j}}, $a;
				push @@{$myDimFilt->{comb}->{attr_v}}, $a if exists $att_v{$atrID};
			}
			foreach my $atr (keys %atr) {	# substitute attr ID to table.col in filter
				$filt =~ s/\[$atr\]/$atr{$atr}/g;
			}
#print "///////////",Dumper($myDimFilt->{mex});
d379 6
a384 5
			my %fa;
			foreach my $metr (@@{$myDimFilt->{mex}}) {	# collect facts for each metric
				foreach my $fact ($metr =~ /\[(\w+)\]/g) {
#print ">>>	$fact\n";
					$fa{$fact} = fact2tableCol($fact, $src, $comb->{jh}->{table}) if !exists $fa{$fact};	# we are setting hash to handle metrics based on the same facts effectively
a385 1
			}
d387 5
a391 3
			foreach my $metr (@@{$myDimFilt->{mex}}) {	# for each metric
				foreach my $fact (keys %fa) {
					$metr =~ s/\[$fact\]/$fa{$fact}/g;
d393 22
a414 1
				push @@{$myDimFilt->{comb}->{metr}}, $metr;
a415 21
#print "...........",Dumper($myDimFilt->{mex});
			delete $myDimFilt->{mex};	# delete temporary array of Metric Expressions

#			foreach my $f (@@{$comb->{tc}->{fa}}) {	# for each fact table
#				foreach my $a (@@{$comb->{tc}->{lu}}, @@{$comb->{tc}->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
#						$myDimFilt->{comb}->{join}->{"$a -> $f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
#				}
#			}
			$myDimFilt->{comb}->{filter} = $filt;
#use Data::Dumper;
#print Dumper($myDimFilt->{comb});
			my $sql = SQL::queryGen($pn, $myDimFilt->{comb});	# call specific plugin

#			$myDimFilt->{SQL} = $sql;
			
			push @@{$SQL->{res}}, { 
				'SQL'=>$sql, 
				'SRC'=>$myDimFilt->{comb}->{src}, 
				'METR'=>$myDimFilt->{metr}, 
				'ATTR'=>$myDimFilt->{attr_v} 
			};
d493 1
a493 1
#print " ........... $path, $join, $role, $ft, $jh ........\n";
@


1.36
log
@HTML map optimization
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.35 2003/11/28 16:56:06 jiri_schmid Exp $
d357 1
d360 1
d363 3
@


1.35
log
@drill up and down fixed
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.34 2003/11/28 11:39:13 michald Exp $
d297 1
a297 2
#use Data::Dumper;
#print Dumper($myDimFilt);
@


1.34
log
@minor fixes
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.33 2003/11/28 07:06:09 michald Exp $
d293 1
a293 1
			
d297 2
d351 2
a352 1

d388 2
@


1.33
log
@report/metric filter join
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.32 2003/11/20 08:17:34 michald Exp $
d262 2
d269 3
a271 1
			if ($filt) {	# metric has filter
d384 1
@


1.32
log
@fix of LDM, cleanup of some obsolete files
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.31 2003/11/13 16:27:50 jiri_schmid Exp $
a177 18
sub PrepareSQLXXX {
	# returns host/source and SQL Statement
	my $ID = shift;
	my $SQL = PrepareJoin($ID);
	
	foreach my $dim (keys %{$SQL->{m}}) {	# for each dimensional group of metrics
		foreach my $filt (keys %{$SQL->{m}->{$dim}}) {	# for each filtered group of metrics
			my $sql = 'SELECT';
			$sql .= ' FROM';
			$SQL->{m}->{$dim}->{$filt}->{comb}->{sql} = $sql;
		}
	}
	
	return $SQL;
}

#-----------------------------------------------------

d188 2
a189 3
	my $filter = get_obj_lnk($rep->{'report'}->{$ID}, 'filter_def');
#	my @@metric = get_obj_lnk($grid, 'metric');
	@@{$SQL->{Metric}} = sort @@{$grid->{metric}};	# array of metric IDs
a200 2
	$SQL->{Filter} = $filter;
#	@@{$SQL->{Metric}} = @@metric;
d262 5
d270 1
a270 1
#print ">>>>$filt|".join(',',@@obj)."\n\n";
@


1.31
log
@fixed bugs and dynamicparam finder implemeted
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.30 2003/11/13 07:29:49 michald Exp $
d258 1
d260 3
a262 3
#			@@{$m->{$dim}->{$filt}->{mex}} = sort keys %{$m->{$dim}->{$filt}->{metr}};
			foreach my $mid (@@{$m->{$dim}->{$filt}->{metr}}) {
				push @@{$m->{$dim}->{$filt}->{mex}}, ${$main::MDi->{$mid}->{ptr}}->{expr};
d264 1
a264 1
#			delete $m->{$dim}->{$filt}->{metr};
d267 2
a268 2
			my $f={};
			foreach my $e (@@{$m->{$dim}->{$filt}->{mex}}) {	# for each metric expression involved in this Dimensionality/Filtration
d270 1
a270 1
					$f->{$_}++;
d273 1
a273 1
			@@{$m->{$dim}->{$filt}->{fact}} = sort keys %{$f};
d276 2
d280 2
a281 1
				push @@{$m->{$dim}->{$filt}->{attr}}, $a;
d289 1
a289 1
						push @@{$m->{$dim}->{$filt}->{attr}}, $_;
d297 2
d301 1
a301 1
			my $tcomb = tableCombinations([@@{$m->{$dim}->{$filt}->{attr}}, @@{$m->{$dim}->{$filt}->{fact}}], $main::MDl);
d304 1
a304 1
			$m->{$dim}->{$filt}->{ftbl} = getTablesFromObj($m->{$dim}->{$filt}->{fact});
d310 1
a310 1
				my $comb = mkSelCombArr($m->{$dim}->{$filt}->{ftbl}->{$src}, $tcomb->{$src});	# split list of table combinations into separate list of lookups and facts
d351 2
a352 2
									push (@@{$m->{$dim}->{$filt}->{c}->{$w}->{$src}}, $temph);
#									push (@@{$m->{$dim}->{$filt}->{c}->{$w}->{$src}}, {'tbl' => $tc});
d363 1
a363 1
			$m->{$dim}->{$filt}->{comb}->{src} = $src;
d365 1
a365 1
			$m->{$dim}->{$filt}->{comb}->{tbl} = $comb;
d367 4
a370 2
			foreach my $atrID (@@{$m->{$dim}->{$filt}->{attr}}) {	# for each attribute
				push @@{$m->{$dim}->{$filt}->{comb}->{attr}}, attr2tableCol($atrID, $src, $comb->{jh}->{table});
d372 1
a372 2
#print "///////////",Dumper($m->{$dim}->{$filt}->{mex});
			my $fa = {};
d374 2
a375 1
			foreach my $metr (@@{$m->{$dim}->{$filt}->{mex}}) {	# collect facts for each metric
d378 1
a378 1
					$fa->{$fact} = fact2tableCol($fact, $src, $comb->{jh}->{table}) if !exists $fa->{$fact};	# we are setting hash to handle metrics based on the same facts effectively
d382 3
a384 3
			foreach my $metr (@@{$m->{$dim}->{$filt}->{mex}}) {	# for each metric
				foreach my $fact (keys %{$fa}) {
					$metr =~ s/\[$fact\]/$fa->{$fact}/g;
d386 1
a386 1
				push @@{$m->{$dim}->{$filt}->{comb}->{metr}}, $metr;
d388 2
a389 2
#print "...........",Dumper($m->{$dim}->{$filt}->{mex});
#			delete $m->{$dim}->{$filt}->{mex};	# delete temporary array of Metric Expressions
d393 1
a393 1
#						$m->{$dim}->{$filt}->{comb}->{join}->{"$a -> $f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
d396 1
a396 1
			my $sql = SQL::queryGen($pn, $m->{$dim}->{$filt}->{comb});	# call specific plugin
d398 1
a398 1
#			$m->{$dim}->{$filt}->{SQL} = $sql;
d402 3
a404 3
				'SRC'=>$m->{$dim}->{$filt}->{comb}->{src}, 
				'METR'=>$m->{$dim}->{$filt}->{metr}, 
				'ATTR'=>$m->{$dim}->{$filt}->{attr} 
@


1.30
log
@fix of wrong attribute order in RCache
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.29 2003/11/11 14:03:19 jiri_schmid Exp $
d282 1
a282 1
print ">>>>$filt|".join(',',@@obj)."\n\n";
@


1.29
log
@creating report - minor bugs fixed, seems to be working properly
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.28 2003/11/10 20:52:35 michald Exp $
d279 14
a292 8
#			if ($filt) {	# metric has filter
#				my @@atr;
#				(@@atr) = ( $filt=~/\[(.+?)\]/g );
#print ">>>>$filt|".join(',',@@atr)."\n\n";
#				foreach (@@atr) {
#					push @@{$m->{$dim}->{$filt}->{attr}}, $_;
#				}
#			}
d343 2
a344 1
									my $temph = {'tc' => $tc, 'join' => [@@js], 'jh' => $jh};
d381 1
a381 1
			delete $m->{$dim}->{$filt}->{mex};
d383 6
a388 6
			foreach my $f (@@{$comb->{tc}->{fa}}) {	# for each fact table
				foreach my $a (@@{$comb->{tc}->{lu}}, @@{$comb->{tc}->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
						$m->{$dim}->{$filt}->{comb}->{join}->{"$a -> $f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
				}
			}
			my $sql = SQL::queryGen($pn, $m->{$dim}->{$filt}->{comb});
d390 1
a390 1
			$m->{$dim}->{$filt}->{SQL} = $sql;
d392 6
a397 1
			push @@{$SQL->{res}}, { 'SQL'=>$sql, 'SRC'=>$m->{$dim}->{$filt}->{comb}->{src}, 'METR'=>$m->{$dim}->{$filt}->{metr}, 'ATTR'=>$m->{$dim}->{$filt}->{attr} };
d402 1
a402 2

	$SQL->{m} = $m;
d405 5
a409 5
	return { ATTR=>[@@{$SQL->{Attr}}],
			METRIC=>[@@{$SQL->{Grid}->{metric}}],
			FILTER=>$SQL->{Filter},
			SQL=>$SQL->{Filter},
			DEBUG=>$SQL->{m} };	# !!! DEBUG hash is for debuging purposes only
@


1.28
log
@temporary removing of the filter
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.27 2003/11/10 20:37:26 michald Exp $
d389 1
a389 1
print Dumper($SQL->{res});
d443 1
a443 1
print "ID: $ID, $src".Dumper($tabs);
@


1.27
log
@README update
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.26 2003/11/10 18:51:59 michald Exp $
d279 8
a286 8
			if ($filt) {	# metric has filter
				my @@atr;
				(@@atr) = ( $filt=~/\[(.+?)\]/g );
print ">>>>$filt|".join(',',@@atr)."\n\n";
				foreach (@@atr) {
					push @@{$m->{$dim}->{$filt}->{attr}}, $_;
				}
			}
@


1.26
log
@.pl to .pm transition
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.25 2003/11/10 06:35:57 michald Exp $
d279 8
a286 6
#			if ($filt) {	# metric has filter
#				my $atr = $filt;
#				$atr =~ s/\[(.*)\]/$1/;
#print ">>>>$filt|$atr\n\n";
#				push @@{$m->{$dim}->{$filt}->{attr}}, $atr;
#			}
@


1.25
log
@map graph prototype
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.24 2003/11/07 09:35:11 jiri_schmid Exp $
d279 6
@


1.24
log
@saving rights of attr and fact fixed
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.23 2003/11/07 07:36:43 michald Exp $
d74 1
a74 1
							main::WriteLog("Joins are not fully defined for specific path","Path: $v->$e, Role: $_",1) if ($main::LogLevel>0);
d103 1
a103 1
		main::WriteLog("Attribute has no PK","AttrID=$id",2) if ($main::LogLevel>1);
d124 1
a124 1
					main::WriteLog("Directed Graph Set Attribute Fails",join(', ',@@{$join->{$role}}),1) if ($main::LogLevel>0);
d135 1
a135 1
				main::WriteLog("Wrong Relation Definition for $fk",'',1) if ($main::LogLevel>0);
d139 1
a139 1
		main::WriteLog("Attribute has no FK","AttrID=$id",2) if ($main::LogLevel>1);
d211 1
a211 1
		next if ($_ eq $main::MetricsIdent);	# don't include metric group identifier
d381 2
d386 2
a387 2
	return { ATTR=>[sort(@@{$SQL->{Attr}})],
			METRIC=>[sort(@@{$SQL->{Grid}->{metric}})],
@


1.23
log
@fix for not numeric fact ID
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.22 2003/10/07 05:48:01 michald Exp $
d246 3
d291 1
a291 1
print Dumper($comb);
d302 1
a302 1
print ">>>$at, $ar, $a, $f, $pn, $src";
d304 1
a304 1
print ">0<\n";
d312 1
a312 1
print '<'.join(':',@@{$tc->{fa}}).">1<\n";
d315 1
a315 1
print '<'.join(':',@@{$tc->{fa}}).">2<\n";
d318 1
a318 1
print ">3<\n";
d340 1
a340 1
			
d351 1
d358 1
a358 2
#print "///////////",Dumper($m->{$dim}->{$filt}->{mex});
#print "fa///",Dumper($fa);
d365 1
a365 1
print "...........",Dumper($m->{$dim}->{$filt}->{mex});
d400 1
a400 1
print "============== $ID = $src ===== ".join(',',keys %{$tabs})."\n";
@


1.22
log
@loading RCache from DB
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.21 2003/09/29 05:43:19 michald Exp $
d288 1
d299 1
a299 1
#print ">>>$at,$ar";
d301 1
a301 1
#print ">0<\n";
d309 1
a309 1
#print '<'.join(':',@@{$tc->{fa}}).">1<\n";
d312 1
a312 1
#print '<'.join(':',@@{$tc->{fa}}).">2<\n";
d315 1
a315 1
#print ">3<\n";
d346 1
d349 2
a350 1
				foreach my $fact ($metr =~ /\[(\d+)\]/g) {
d354 2
d362 1
d397 1
a397 1
#print "==============$ID, $src, =====".join(',',keys %{$tabs})."\n";
d430 1
@


1.21
log
@new version of the metadata - multiple attribute PK implementation; improvement of the PrepareSQL
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.18 2003/08/18 05:50:55 michald Exp $
d278 1
a278 1
			my $tcomb = tableCombinations([@@{$m->{$dim}->{$filt}->{attr}},@@{$m->{$dim}->{$filt}->{fact}}], $main::MDl);
d367 2
d374 1
d378 2
a379 1
			DEBUG=>$SQL };	# !!! DEBUG hash is for debuging purposes only
d391 1
a391 1
print "==============$ID, $src, =====".join(',',keys %{$tabs})."\n";
d399 1
a399 1
print "==============$t\n";
d407 1
a407 1
print "==============$t\n";
d444 1
@


1.20
log
@return to previuos SQLgen, because of involuntary commit
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.19 2003/09/25 11:53:42 jiri_schmid Exp $
d97 4
a100 2
	if ($nMD->{pk}) {
		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# PK source/table/column
d102 2
d105 1
a105 1
	if (ref($nMD->{fk}) eq 'ARRAY') {
d110 3
a112 1
			next if (!exists $nMD->{pk});	# if PK not exists
d138 2
d178 18
d207 2
a208 1
	my @@metric = get_obj_lnk($grid, 'metric');
d221 2
a222 2
	@@{$SQL->{Metric}} = @@metric;
	@@{$SQL->{Attr}} = keys %{$attr};
d227 2
a228 1
	foreach (@@metric) {	# make groups of metrics with same Dimensionality/Filtration
d231 3
a233 3
		if ($_->{aggr_type} eq 'specific') {
			$dim = join('|', @@{$_->{aggr_def}}) if $#{$_->{aggr_def}};	# metric dimensionality
		} elsif ($_->{aggr_type} eq 'report') {
d235 1
a235 1
		} elsif ($_->{aggr_type} eq 'none') {
d238 1
a238 1
		my $filt = get_obj_lnk($_, 'filter_def');	# metric filter expression
d241 3
a243 1
		$m->{$dim}->{$filt}->{me}->{$_->{expr}}++;	# put it into hash to consolidate uniform expresions
d256 5
a260 2
			@@{$m->{$dim}->{$filt}->{metr}} = sort keys %{$m->{$dim}->{$filt}->{me}};
			delete $m->{$dim}->{$filt}->{me};
d264 1
a264 1
			foreach my $e (@@{$m->{$dim}->{$filt}->{metr}}) {	# for each metric expression involved in this Dimensionality/Filtration
d272 1
a272 1
			foreach my $a (sort(@@{$SQL->{Attr}})) {	# for each attribute
d285 1
a285 1
			my $minW = 2**64;	# minimal weight
a286 1
print Dumper($tcomb->{$src});
d298 1
a298 1
print ">>>$at,$ar";
d300 1
a300 1
print ">0<\n";
d308 1
a308 1
print join(':',$tc->{fa}).">1<\n";
d311 1
a311 1
print '<'.join(':',@@{$tc->{fa}}).">2<\n";
d314 1
a314 1
print ">3<\n";
d328 2
a329 1
									$tempMin->{$w}->{$src} = $tc;
d341 21
a361 3
			foreach my $f (@@{$comb->{fa}}) {	# for each fact table
				foreach my $a (@@{$comb->{lu}}, @@{$comb->{fa}}) {	# for each lookup table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
						$m->{$dim}->{$filt}->{comb}->{join}->{"$a-$f"}++; # = $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
d364 1
a364 1
#			my $sql = SQL::queryGen($pn, $tempMin->{$minW});
d366 1
a366 1
#			push @@{$SQL->{SQL}}, $sql;
d372 55
a426 1
	return $SQL;
d428 1
d449 1
a449 1
print "\n$ftre: $j";
d453 1
a453 1
print "---$jj\n";
d509 2
a510 2
print "///////////// arrays of tables for each attribute\n";
print Dumper($h);
d531 1
a531 1
			$comb->{join('|',sort keys %{$hh})}++;	# put it into hash to avoid redundand combinations
d539 2
a540 2
print "///////////// results of tableCombinations\n";
print Dumper($res);
@


1.19
log
@operational commit for vladis
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.18 2003/08/18 05:50:55 michald Exp $
d96 4
a99 13
#	my ($src1,$t1,$k1);
#	if ($nMD->{pk}) {
#		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# PK source/table/column
#		push(@@{$main::MDl->{$id}}, "$src1/$t1");
#	}
	
	if (exists $nMD->{pk}) {
		foreach my $pk (@@{$nMD->{pk}}) {
			if (defined $pk) {
				my ($src1,$t1,$k1) = ($pk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
				push(@@{$main::MDl->{$id}}, "$src1/$t1");
			}
		}
a100 1
	
d103 2
a104 14
#			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
#			push(@@{$main::MDl->{$id}}, "$src2/$t2");

			if (exists $nMD->{pk}) {
				if (defined $fk) {
					my ($src2,$t2,$k2) = ($fk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
					push(@@{$main::MDl->{$id}}, "$src2/$t2");
				} else {
					next
				}
			} else {
				next
			}

d106 1
a106 1
#			next if (!exists $nMD->{pk});	# if PK not exists
@


1.18
log
@some ACL improvement
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.17 2003/08/15 10:59:39 michald Exp $
d96 13
a108 4
	my ($src1,$t1,$k1);
	if ($nMD->{pk}) {
		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# PK source/table/column
		push(@@{$main::MDl->{$id}}, "$src1/$t1");
d110 1
d113 14
a126 2
			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
			push(@@{$main::MDl->{$id}}, "$src2/$t2");
d128 1
a128 1
			next if (!exists $nMD->{pk});	# if PK not exists
@


1.17
log
@initial ACL implementation
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.16 2003/08/06 09:36:32 michald Exp $
d254 1
d264 1
a264 1
									foreach my $a (@@{$tc->{lu}}, @@{$tc->{fa}}) {	# for each lookups table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
d276 1
a277 1
print ">1<\n";
d279 1
a280 1
print ">2<\n";
d309 1
a309 1
				foreach my $a (@@{$comb->{lu}}, @@{$comb->{fa}}) {	# for each lookups table and fact table (fact tables are used to prevent situation if log. objects are covered fully by fact tables only, but those tables are not joinable. We are using fact that there is edge between table and table itself presented in directed graph MDg))
d336 5
a340 4
	my $ftre = '^'.join('^|$', @@{$ft}).'$';
	my $ret = @@{$path}[$i].$role;
	$jh->{table}->{@@{$path}[$i].$role}++;
	foreach my $j (@@{$join}) {
d343 6
a348 4
print "\n$j";
		$j =~ s/([^.= ]+)\.([^.= ]+)/$1$role.$2/g;	# !!! 
print "---$j\n";
		$ret .= '{'.$j.'}'.@@{$path}[$i].$r;
d350 1
a350 1
		$jh->{join}->{$j}++;
d403 1
d433 1
@


1.16
log
@filter call implementation to GetAttrElements
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.15 2003/08/04 05:12:23 michald Exp $
d260 2
d264 5
a268 3
										if (!$main::MDg->{$pn}->{$src}->has_edge($a, $f)) {
											$w = -1;
											last C;	# let escape if there is no edge available
d270 15
a284 1
										$w += $main::MDg->{$pn}->{$src}->get_attribute('weight', $a, $f);
d286 1
a286 2
											$w = -1;
											last C;	# let escape if weight is more than current minimal weight
d291 5
a295 3
										$minW = $w;
										push (@@{$m->{$dim}->{$filt}->{c}->{$w}->{$src}}, $tc);
										$tempMin->{$w}->{$src} = $tc;
d326 28
d360 1
a360 2
	my $fre = '^'.join('$|^', @@{$fact}).'$';

d384 1
d391 1
d394 1
a394 1
			push @@{$h->{$src}[$i]}, $t;
d399 1
d428 1
@


1.15
log
@Plug-Ins implementation
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.14 2003/07/31 06:47:24 michald Exp $
d275 1
a275 1
#										push (@@{$m->{$dim}->{$filt}->{comb}->{$w}->{$src}}, $tc);
@


1.14
log
@search for optimal combination of physical tables for join
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.13 2003/07/30 07:46:09 michald Exp $
d244 2
a245 1
			my $comb = tableCombinations([@@{$m->{$dim}->{$filt}->{attr}},@@{$m->{$dim}->{$filt}->{fact}}], $main::MDl);
d247 1
d250 42
a291 2
			foreach (keys %{$comb}) {	# for each data source
				$m->{$dim}->{$filt}->{comb}->{$_} = mkSelCombArr($m->{$dim}->{$filt}->{ftbl}->{$_}, $comb->{$_});
d293 1
d295 1
a295 7
			my $mm = join(',',sort @@{$m->{$dim}->{$filt}->{metr}});
			my $attrl = join(',',sort @@{$m->{$dim}->{$filt}->{attr}});	# list of attributes
			$sql = "SELECT $attrl";
			$sql .= ", $mm";
			$sql .= " FROM ...";
			$sql .= " GROUP BY $attrl";
			push @@{$SQL->{SQL}}, $sql;
d307 3
a309 1
sub mkSelCombArr {
d329 1
a329 1
		push @@{$res->{$#fa+1}->{$#lu+1}}, $t;
d337 1
d339 1
a339 1
	my $lut = shift;	# hash of 
@


1.13
log
@creation of lookup table combinations
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.12 2003/07/29 16:56:56 michald Exp $
d244 1
a244 2
			my $comb = tableCombinations($m->{$dim}->{$filt}->{attr}, $main::MDl);
			$m->{$dim}->{$filt}->{comb} = $comb;
d246 1
a246 2
			@@{$m->{$dim}->{$filt}->{ftbl}} = getTablesFromObj($m->{$dim}->{$filt}->{fact});
			@@{$m->{$dim}->{$filt}->{atbl}} = getTablesFromObj($m->{$dim}->{$filt}->{attr});
d248 4
d270 27
d347 1
d354 4
a357 1
	return $ft;
@


1.12
log
@ArrComb.pl introduction
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.11 2003/07/29 14:36:42 jiri_schmid Exp $
d16 1
a16 1
require 'ArrComb.pl';	# provide combinations of array
a199 1
	my @@atr = sort(@@{$SQL->{Attr}});
d239 1
a239 3
#			my $tt={};	# temporary hash
			my $i=0;	# attribute index in @@attr
			foreach my $a (@@atr) {	# for each attribute
a241 11
				
				foreach my $tbl (@@{$main::MDl->{$a}}) {	# for each table containing key definition of attribute
					my ($src,$t) = ($tbl =~ /(.+)\/(.+?)$/);	# split source and table
#					$tt->{$src}++;
#					push @@{$m->{$dim}->{$filt}->{attr_tbl}->{$src}->{$a}}, $t;
#					push @@{@@{$m->{$dim}->{$filt}->{attr_tbl}->{$src}}[$i]}, $t;
				}
#				foreach (keys %{$tt}) {
#					push @@{$m->{$dim}->{$filt}->{attr_tn}->{$_}}, --$tt->{$_};	# number of tables containing key definition of attribute
#				}
				$i++;
d243 3
d265 49
@


1.11
log
@code improvments
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.10 2003/07/29 06:52:46 michald Exp $
d16 1
a16 1
#require 'ArrComb.pl';	# provide combinations of array
d240 2
a245 1
				my $tt={};
d248 8
a255 6
					$tt->{$src}++;
					push @@{$m->{$dim}->{$filt}->{attr_tbl}->{$src}->{$a}}, $t;
				}
				foreach (keys %{$tt}) {
					push @@{$m->{$dim}->{$filt}->{attr_tn}->{$_}}, --$tt->{$_};	# number of tables containing key definition of attribute
				}
@


1.10
log
@Cache::GetAttrElements implementation
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.9 2003/07/18 10:51:01 jiri_schmid Exp $
d16 1
a16 1
require 'ArrComb.pl';	# provide combinations of array
@


1.9
log
@format3d implemented, format changed all dependencies fixed
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.8 2003/07/17 03:04:21 michald Exp $
d16 2
d201 3
a203 2
	foreach (@@metric) {	# let group metrics with same Dimensionality/Filtration
		my $dim = '';	# if (aggr_type eq 'report') or (aggr_type eq 'specific') and aggr_def is not defined
d226 1
d229 2
d239 1
d243 10
a253 2
#			push @@{$m->{$dim}->{$filt}->{attr}}, $dim;

d255 2
a256 2
			my @@ft = getFactTables($m->{$dim}->{$filt}->{fact});
#!!!			my @@at = getAttrTables($m->{$dim}->{$filt}->{attr});
d274 7
a280 8
sub getFactTables {
	my @@f=@@_;
	my $f1 = shift @@f;
return;
	foreach my $ft1 (@@{$main::MDl->{$f1}}) {	# for each table containing specific fact
		foreach my $f (@@f) {
			foreach my $ft (@@{$main::MDl->{$f}}) {	# for each table containing specific fact
			}
d283 1
@


1.8
log
@fix of ObjInvolved func
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.7 2003/07/11 05:40:58 michald Exp $
d177 1
a177 1
	my $grid = get_obj_lnk($rep->{'report'}->{$ID}, 'grid_def');
@


1.7
log
@minor fixes
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.6 2003/07/04 06:19:19 michald Exp $
d145 1
a145 1
	# returns specific object hash from report definition, same if object is stored locally in report or if is there ID pointer only
d181 1
a181 1
	foreach (@@{$grid->{col}}, @@{$grid->{row}}) {
@


1.6
log
@some fixes for proper utf8 encoding, see README for details
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.5 2003/06/23 08:59:38 michald Exp $
d31 1
a31 1
	$tempGa->{$pn} = new Graph::Directed;	# init temporary Directed Graph of logical object (attributes and facts)relations
a85 48
sub MD2graphAttr {
# obsolete function
# create edges for Directed Graph acordingly to PK/FK relations, vertexes are attributes/facts
# new metadata has to be of attribute type
	my $nMD=shift;	# new metadata
	my $id=shift;	# new object ID

#	return if !($nMD->{pk});	# return if pk is not defined, attributes without pk has to be solved separately
	
	my ($src1,$t1,$k1);
	if ($nMD->{pk}) {
		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# PK source/table/column
	}
	if (ref($nMD->{fk}) eq 'ARRAY') {
		foreach my $fk (@@{$nMD->{fk}}) {	# for each FK

			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);	# FK source/table/column
			if (!exists $nMD->{pk}) {	# if PK not exists
				$src1 = $src2;			# set both src equivalent to path through next checks smoothly
			}
			if (($src1) && ($src2)) {	# add edge to the Graph
				if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
					my ($r1) = ($id =~ /^[0-9a-f]{1,10}\.(\w+)$/);
					foreach my $id2 (@@{$main::MDk->{$src2}->{$t2}}) {	# for each object mapped into $t2
						my ($r2) = ($id2 =~ /^[0-9a-f]{1,10}\.(\w+)$/);
						next if ($r1&&$r2&&($r1 ne $r2));
						$tempG->add_weighted_edge($id, 1, $id2);
						my @@join;
						next if (!exists $nMD->{pk});	# don't set join if PK not exists and join is not defined explicitly in hrelation
						@@join = ["$t1.$k1=$t2.$k2"]; 
						@@join = [$nMD->{join}] if $nMD->{join};	# !!! need reimplementation: explicit join can be part of hrelation
						next if (!@@join);
						if (!$tempG->set_attribute('join', $id, $id2, @@join)) {
							main::WriteLog("Directed Graph Set Attribute Fails",join(', ',@@join),1) if ($main::LogLevel>0);
						}
					}
				} else {
					main::WriteLog("Wrong Relation Definition for $fk","Relation between Different Sources",1) if ($main::LogLevel>0);
				}
			} else {
				main::WriteLog("Wrong Relation Definition for $fk",'',1) if ($main::LogLevel>0);
			}
		}					
	}
}

#---------------------------------------

d135 1
a135 1
sub add_tmp_attr_edge {
d200 9
a208 2
		my $dim = $_->{aggr};	# metric dimensionality
		my $filt = get_obj_lnk($_, 'filter_id');	# metric filter expression
d214 1
a214 1
	foreach my $dim (keys %{$m}) {	# for each dimensionaled group of metrics
@


1.5
log
@new debug func: Obj Dependency
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.4 2003/06/21 16:13:10 michald Exp $
d10 2
a11 2
binmode(STDOUT, ":utf8");
binmode(STDIN, ":utf8");
d256 1
d259 1
a259 1
			$suc = '|'.join('|', $main::MDga->{$pn}->successors($dim)).'|';	# all successors of this dimensionality attribute
d261 1
d278 1
@


1.4
log
@improvement of object dependency directed graph
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.3 2003/06/20 08:42:32 michald Exp $
d252 1
a252 1
		$m->{$dim}->{$filt}->{me}->{$_->{expr}}++;	# put it into hash to consolidate same expresions
@


1.3
log
@introduction of new directed graph structures MDga and MDgo
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.2 2003/05/28 15:33:34 michald Exp $
d135 1
a135 1
# create edges for Directed Graph acordingly to PK/FK relations, vertexes are tables
d139 1
a139 1
	my ($role) = ($id =~ /^[0-9a-f]{1,10}\.(\w+)$/);	# $role is attribute role
d167 5
a171 5
				# add edge to $tempGa
				foreach my $id2 (@@{$main::MDk->{$src2}->{$t2}}) {	# for each object mapped into $t2
					my ($r2) = ($id2 =~ /^[0-9a-f]{1,10}\.(\w+)$/);
					next if ($role&&$r2&&($role ne $r2));
					$tempGa->{$pn}->add_edge($id, $id2);
d183 9
d193 3
a195 3
	# returns specific object hash from report definition
	my $obj = shift;	# hash of specific report object
	my $el = shift;		# name of element
a220 4
#	my $SQL = "SELECT lu_date.year_id, lu_date.month_id, SUM(objem_prodeje_agr2.ks), SUM(objem_prodeje_agr2.cenaXks) FROM objem_prodeje_agr2 INNER JOIN lu_date ON objem_prodeje_agr2.date_id=lu_date.date_id WHERE month_id IN (200002, 200003, 200004, 200102, 200104) GROUP BY lu_date.year_id, lu_date.month_id";
#	$SQL .= "\n\n<p>".join('|',@@$attr).':'.join ('|',@@$metric)."\n";
#main::WriteLog(">>>",$ID,1);;

d222 1
d242 1
a242 4
#	foreach (keys %{$attr}) {
#		push @@{$SQL->{Attr}}, $_;
#	}
	
a243 1
	my $a = join(',',sort @@{$SQL->{Attr}});	# list of attributes
d247 1
a247 2
	my $fct = {};
	foreach (@@metric) {
d249 10
a258 7
		my $filt;
		$filt = get_obj_lnk($_, 'filter_id');	# metric filter expression
		$filt = $filt->{expr} if ref($filt) eq 'HASH';	# metric filter expression
		push @@{$m->{$dim}->{$filt}->{metr}}, $_->{expr};
		@@{$m->{$dim}->{$filt}->{attr}} = @@atr;	# in case of dimensional metrics here should be related attributes excluded
		foreach ($_->{expr}=~/\[(.*?)\]/g) {	# facts
			$fct->{$_}++
d260 16
a275 1
	}
a276 2
	foreach my $dim (keys %{$m}) {	# for each filtered group of metrics
		foreach my $filt (keys %{$m->{$dim}}) {	# for each dimensionaled group of metrics
a277 1
			(@@{$m->{$dim}->{$filt}->{fact}}) = sort(keys %{$fct});
d282 2
a283 1
			$sql = "SELECT $a";
d286 1
a286 1
			$sql .= " GROUP BY $a";
@


1.2
log
@move of some code into separate modules
@
text
@d4 1
a4 1
# $Id: SQLGen.pm,v 1.1 2003/05/27 12:18:12 michald Exp $
a8 1
use Graph::Directed;
d13 6
a18 1
my $tempG = {};	# temporary directed graph
d24 8
a31 1
	$tempG->{$hs} = new Graph::Directed;	# init Directed Graph of physical relations
d39 4
d47 1
a47 1
		while (@@edg) {	# copy join constrains into MDg
d55 6
a60 5
		foreach my $v ( $main::MDg->{$pn}->{$src}->vertices() ) {	# for each grapg vertice
			foreach my $e ( $main::MDg->{$pn}->{$src}->successors($v) ) {
				my @@p = @@{$main::MDg->{$pn}->{$src}->get_attribute('path',$v,$e)};
				if ( $#p>1 ) {
					my $j;
d62 12
a73 1
						push (@@{$j}, @@{$main::MDg->{$pn}->{$src}->get_attribute('join',$p[$i-1],$p[$i])}[0]) if ($main::MDg->{$pn}->{$src}->get_attribute('join',$p[$i-1],$p[$i]));
d86 4
a89 2
sub MD2graph {
# create relation for Directed Graph, new metadata has to be of attribute type
d97 1
a97 1
		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
d102 1
a102 1
			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
d112 1
a112 1
						$tempG->{$src1}->add_weighted_edge($id, 1, $id2);
d118 1
a118 1
						if (!$tempG->{$src1}->set_attribute('join', $id, $id2, @@join)) {
d129 160
@


1.1
log
@joins for not directly connected vertexes
@
text
@d4 1
a4 1
# $Id$
a34 1
#print ">>>$e----------------$s<<<\n";
d90 1
a90 1
							WriteLog("Directed Graph Set Attribute Fails",join(', ',@@join),1) if ($main::LogLevel>0);
d94 1
a94 1
					WriteLog("Wrong Relation Definition for $fk","Relation between Different Sources",1) if ($main::LogLevel>0);
d97 1
a97 1
				WriteLog("Wrong Relation Definition for $fk",'',1) if ($main::LogLevel>0);
@

