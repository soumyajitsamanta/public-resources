head	1.15;
access;
symbols;
locks; strict;
comment	@# @;


1.15
date	2004.05.03.09.07.07;	author michald;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.12.16.11.35;	author michald;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.11.07.59.01;	author michald;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.12.13.40.22;	author michald;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.01.12.21.10;	author jiri_schmid;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.01.04.33.17;	author michald;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.28.13.03.22;	author jiri_schmid;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.28.11.39.19;	author michald;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.20.16.34.14;	author jiri_schmid;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.20.08.17.47;	author michald;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.13.16.27.50;	author jiri_schmid;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.13.07.29.59;	author michald;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.07.05.48.01;	author michald;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.29.05.43.19;	author michald;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.04.05.42.36;	author michald;	state Exp;
branches;
next	;


desc
@@


1.15
log
@N:M implementation, foundation for slowly changing dimensions
@
text
@#-----------------------------------------------------
#  Basic SQL Query Generator for MySQL Plug-In
#-----------------------------------------------------
# $Id: MySQL_simple.pm,v 1.14 2004/03/12 16:11:35 michald Exp $

package SQL;

use strict;
use utf8;

my $version = '0.1';
my $copyright = '(C) Insight Strategy, a. s., 2003';

my $max_query_size = 1048573;
my $max_conections = 100;
my $max_tbl_row_length = 65502;


#---------------------------------------

sub about {                    
  return "Basic SQL Query Generator for MySQL v$version ($copyright)"  
}

#---------------------------------------

sub queryGen {
	my $pn=shift;	# project name
	my $comb=shift;	# hash with selected minimal set of tables for select

#use Data::Dumper;
#print Dumper($comb);
	my $mm = join(', ', @@{$comb->{metr}});	# list of metrics
	my $attr_g = join(', ', @@{$comb->{attr_g}});	# list of attributes to see
	$attr_g =~ s/:/_/g;	# change form of "table:role" to "table_role" to keep consistency with table aliases

	my $sql = "SELECT $attr_g";
	$sql .= ", $mm" if $mm;
	$sql .= ' FROM';
	foreach my $table (@@{$comb->{table}}) {	# keys represents list of tables covering required objects
		$table =~ s/(\w+):(\w+)/$1 AS $1_$2/g;	# let use alias in case attribute role is presented
		$sql .= " $table,";
	}
	$sql =~ s/,$//;
	$sql .= ' WHERE';
	if ($comb->{filter}) {
		$comb->{filter} =~ s/:/_/g;	# change form of "table:role" to "table_role" to keep consistency with table aliases
		$sql .= " $comb->{filter} AND";
	}
	foreach my $join (@@{$comb->{join}}) {	# keys represents list of joins
		$join =~ s/(\w+):(\w+)/$1_$2/g;	# refer to table alias
		$sql .= " $join AND";
	}
	$sql =~ s/\s+AND$//;	# cut latest AND
	$sql =~ s/WHERE\s*$//;	# cut WHERE clause in case it is empty
	$sql .= " GROUP BY $attr_g";

	$sql .= " HAVING $comb->{having}" if $comb->{having};
	if (@@{$comb->{order}}) {	# list of columns to order by
		$sql .= " ORDER BY ".join(', ', @@{$comb->{order}})
	}
	$sql .= " LIMIT $comb->{limit}" if $comb->{limit};

	my @@SQL;
	push @@SQL, $sql;
#	return @@SQL;
	return $sql;

}

#---------------------------------------

1

__END__

=head1 SQL Gereration Plug-In

=head2 Structure of the select definition

$comb = {
          'filter' => 'lu_vyrobek.skupina_id IN (7,9,34,37)',
          'attr_g' => [
                      'lu_datum:dodani.kvartal_id',
                      'lu_vyrobek.skupina_id'
                    ],
          'attr_j' => [
                      'lu_datum:dodani.kvartal_id',
                      'lu_vyrobek.skupina_id'
                    ],
          'src' => 'localhost/demo_bee',
          'table' => [
                     'faktura:dodani',
                     'lu_vyrobek',
                     'polozky_dodak',
                     'lu_datum:dodani'
                   ],
          'metr' => [
                    'SUM(polozky_dodak.ks)'
                  ],
          'having' => undef,
          'join' => [
                    'faktura:dodani.id=polozky_dodak.faktura_id',
                    'lu_datum:dodani.id=faktura:dodani.datum_id_objednani',
                    'lu_vyrobek.id=polozky_dodak.vyrobek_id'
                  ],
          'order' => [],
          'limit' => '10,20'
        };

=head2 Syntax of the object definition

table[:alias].column


=cut

@


1.14
log
@minor fixes and some comments
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.13 2004/03/11 07:59:01 michald Exp $
d14 5
@


1.13
log
@initial implementation of caches in the local DB
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.12 2004/01/12 13:40:22 michald Exp $
d71 42
@


1.12
log
@fix of buggy roles in filters
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.11 2003/12/01 12:21:10 jiri_schmid Exp $
d29 2
a30 2
	my $attr_v = join(', ', @@{$comb->{attr_v}});	# list of attributes to see
	$attr_v =~ s/:/_/g;	# change form of "table:role" to "table_role" to keep consistency with table aliases
d32 1
a32 1
	my $sql = "SELECT $attr_v";
d35 1
a35 1
	foreach my $table (keys %{$comb->{tbl}->{jh}->{table}}) {	# keys represents list of tables covering required objects
d45 1
a45 1
	foreach my $join (keys %{$comb->{tbl}->{jh}->{join}}) {	# keys represents list of joins
d51 7
a57 1
	$sql .= " GROUP BY $attr_v";
@


1.11
log
@pivoting implemented
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.10 2003/12/01 04:33:17 michald Exp $
d26 1
a26 1
use Data::Dumper;
d41 4
a44 1
	$sql .= " $comb->{filter} AND" if $comb->{filter};
@


1.10
log
@filters (attribute ID constrains)
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.9 2003/11/28 13:03:22 jiri_schmid Exp $
d27 1
a27 1
print Dumper($comb);
@


1.9
log
@MD5 hashing implemented, sorting menus implemented etc...
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.8 2003/11/28 11:39:19 michald Exp $
d27 1
a27 1
#print Dumper($comb);
d41 1
@


1.8
log
@minor fixes
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.7 2003/11/20 16:34:14 jiri_schmid Exp $
d27 1
a27 1
print Dumper($comb);
@


1.7
log
@fixed naming of unlocalized objects
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.6 2003/11/20 08:17:47 michald Exp $
d27 1
a27 1
#print Dumper($comb);
@


1.6
log
@fix of LDM, cleanup of some obsolete files
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.5 2003/11/13 16:27:50 jiri_schmid Exp $
d27 1
a27 1
print Dumper($comb);
@


1.5
log
@fixed bugs and dynamicparam finder implemeted
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.4 2003/11/13 07:29:59 michald Exp $
d26 2
a27 2
#use Data::Dumper;
#print Dumper($comb);
d29 2
a30 2
	my $attrl = join(', ', @@{$comb->{attr}});	# list of attributes to see
	$attrl =~ s/:/_/g;	# change form of "table:role" to "table_role" to keep consistency with table aliases
d32 1
a32 1
	my $sql = "SELECT $attrl";
d47 1
a47 1
	$sql .= " GROUP BY $attrl";
@


1.4
log
@fix of wrong attribute order in RCache
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.3 2003/10/07 05:48:01 michald Exp $
d26 2
a27 2
use Data::Dumper;
print Dumper($comb);
@


1.3
log
@loading RCache from DB
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.2 2003/09/29 05:43:19 michald Exp $
d26 4
a29 2
	my $mm = join(', ',sort @@{$comb->{metr}});	# list of metrics
	my $attrl = join(', ',sort @@{$comb->{attr}});	# list of attributes
@


1.2
log
@new version of the metadata - multiple attribute PK implementation; improvement of the PrepareSQL
@
text
@d4 1
a4 1
# $Id: MySQL_simple.pm,v 1.1 2003/08/04 05:42:36 michald Exp $
d49 2
a50 1
	return @@SQL;	# return 
@


1.1
log
@first simple plugins
@
text
@d4 1
a4 1
# $Id$
d22 1
a22 1
sub getTablesFromObj {
a24 9
	return "OK";


#		my $mm = join(',',sort @@{$m->{$dim}->{$filt}->{metr}});
#		my $attrl = join(',',sort @@{$m->{$dim}->{$filt}->{attr}});	# list of attributes
#		$sql = "SELECT $attrl";
#		$sql .= ", $mm";
#		$sql .= " FROM ...";
#		$sql .= " GROUP BY $attrl";
d26 24
@

