head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2004.03.21.07.01.21;	author michald;	state dead;
branches;
next	1.3;

1.3
date	2004.03.12.16.11.35;	author michald;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.11.07.59.01;	author michald;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.25.05.09.24;	author michald;	state Exp;
branches;
next	;


desc
@@


1.4
log
@slight modification of the Metric Filter Intersection MD presentation
@
text
@#-----------------------------------------------------
#  Grammar definition
#-----------------------------------------------------
# $Id: le.grm,v 1.3 2004/03/12 16:11:35 michald Exp $

%right   OR
%right   AND
%right  '='
%left   '-' '+'
%left   '*' '/'
%left   NEG
%left  '^'

%%

input:  #empty
	|	lexp '\n'	{ ++$_[0]->YYData->{LINE}; \@@Calc::filt }
	|	error '\n'	{ ++$_[0]->YYData->{LINE}; $_[0]->YYErrok }
;

lexp:	soq
	|	soe
	|	lexp OR lexp	{
			my @@la = 'OR';
			for my $i ($_[1], $_[3]) {
				if ($Calc::filt[$i][0] eq 'OR') {
					push @@la, @@{$Calc::filt[$i]}[1..$#{$Calc::filt[$i]}];
					splice @@Calc::filt, $i, 1;
				} else {
					push @@la, $i
				}
			}
			push @@Calc::filt, [@@la];
			scalar(@@Calc::filt)-1 }
	|	lexp AND lexp	{
			my @@la = 'AND';
			for my $i ($_[1], $_[3]) {
				if ($Calc::filt[$i][0] eq 'AND') {
					push @@la, @@{$Calc::filt[$i]}[1..$#{$Calc::filt[$i]}];
					splice @@Calc::filt, $i, 1;
				} else {
					push @@la, $i
				}
			}
			push @@Calc::filt, [@@la];
			scalar(@@Calc::filt)-1 }
	|	NOT lexp %prec NEG	{
			if ($Calc::filt[$_[2]][0] eq '.') {
				push @@Calc::filt, ['NOT', @@{$Calc::filt[$_[2]]}[1]];
				splice @@Calc::filt, $_[2], 1;
			} else {
				push @@Calc::filt, ['NOT', $_[2]]
			}
			scalar(@@Calc::filt)-1 }
	|   '(' lexp ')'	{
			push @@Calc::filt, ['()', $_[2]];
			scalar(@@Calc::filt)-1 }
;

soq:	soe EQ soe	{
			push @@Calc::filt, [$_[2], $_[1], $_[3]];
			scalar(@@Calc::filt)-1 }
	|	soe LIKE soes	{
			push @@Calc::filt, ['LIKE', $_[1], $_[3]];
			scalar(@@Calc::filt)-1 }
	|	soe IN soel	{
			$_[3]=~s/\s//g;
			push @@Calc::filt, ['IN', $_[1], $_[3]];
			scalar(@@Calc::filt)-1 }
	|	NOT soq %prec NEG	{
			push @@Calc::filt, ['NOT', $_[2]];
			scalar(@@Calc::filt)-1 }
	|   soe	{ $_[1] }
;

soe:	NUM	{
			push @@Calc::filt, ['NUM', $_[1]];
			scalar(@@Calc::filt)-1 }
	|   OBJ	{
			push @@Calc::filt, ['OBJ', $_[1]];
			scalar(@@Calc::filt)-1 }
	|   soes	{ $_[1] }
;

soel:	LIST	{
			push @@Calc::filt, ['LIST', $_[1]];
			scalar(@@Calc::filt)-1 }
;

soes:	STR	{
			push @@Calc::filt, ['STR', $_[1]];
			scalar(@@Calc::filt)-1 }
;


%%

my @@filt;

# --------------------------------

sub Error {
    my($parser)=shift;
	$parser->YYData->{ERRLINE_NO} = $parser->YYData->{LINE};
	$parser->YYData->{ERRLINE} = $parser->YYData->{INPUT};
}

# --------------------------------

sub Lexer {
    my($parser)=shift;

	exists($parser->YYData->{LINE}) or $parser->YYData->{LINE}=1;
	$parser->YYData->{INPUT} or return('',undef);

    $parser->YYData->{INPUT}=~s/^[ \t]//;

    for ($parser->YYData->{INPUT}) {
        s/^\(((\s*(\d+|'.+?')\s*,)+(\s*(\d+|'.+?')\s*)|\s*\d+\s*|\s*'.+?'\s*)\)// && return('LIST',$1) ;
        s/^([0-9]+(?:\.[0-9]+)?)// && return('NUM',$1);
        s/^'(.+?)'// && return('STR',$1);
        s/^\[(.+?)\]// && return('OBJ',$1);
        s/^(AND|OR|NOT|LIKE|IN)// && return($1,$1);
        s/^(=|>=|>|<>|<=|<)// && return('EQ',$1);
        s/^(.)//s && return($1,$1);
    }
}

@


1.3
log
@minor fixes and some comments
@
text
@d4 1
a4 1
# $Id: beard.pl,v 1.18 2004/03/05 10:11:43 vasekd Exp $
@


1.2
log
@initial implementation of caches in the local DB
@
text
@d1 5
@


1.1
log
@Logical Expressions Decomposition Class
@
text
@d51 1
a51 1
#			push @@Calc::filt, ['.', $_[2]];
a107 1
#print Dumper($parser->YYData);
@

