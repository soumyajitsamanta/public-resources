head	1.71;
access;
symbols;
locks; strict;
comment	@# @;


1.71
date	2004.05.03.09.06.44;	author michald;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.14.09.06.43;	author jiri_schmid;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.13.12.42.37;	author michald;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.09.07.04.39;	author michald;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.05.05.43.52;	author michald;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.02.04.46.05;	author michald;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.29.06.04.55;	author michald;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.21.07.01.13;	author michald;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.12.16.11.26;	author michald;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.11.07.59.00;	author michald;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.27.16.00.03;	author jiri_schmid;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.25.16.05.07;	author jiri_schmid;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.24.10.21.48;	author jiri_schmid;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.19.13.26.07;	author jiri_schmid;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.18.16.19.16;	author jiri_schmid;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.16.14.55.22;	author jiri_schmid;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.13.17.09.40;	author jiri_schmid;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.12.16.24.26;	author jiri_schmid;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.10.14.47.16;	author jiri_schmid;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.09.14.26.41;	author jiri_schmid;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.05.08.54.01;	author jiri_schmid;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.02.09.14.07;	author michald;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.27.13.35.20;	author jiri_schmid;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.16.11.56.25;	author jiri_schmid;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.14.16.09.17;	author jiri_schmid;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.14.15.32.47;	author jiri_schmid;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.12.16.31.10;	author jiri_schmid;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.12.13.50.25;	author jiri_schmid;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.09.12.42.50;	author jiri_schmid;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.09.08.04.49;	author jiri_schmid;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.07.16.27.05;	author jiri_schmid;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.07.12.01.59;	author jiri_schmid;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.06.08.17.37;	author jiri_schmid;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.18.15.14.41;	author jiri_schmid;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.18.12.59.54;	author jiri_schmid;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.16.15.49.24;	author jiri_schmid;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.16.13.44.24;	author jiri_schmid;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.15.15.16.03;	author jiri_schmid;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.12.16.48.12;	author jiri_schmid;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.12.13.34.09;	author jiri_schmid;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.12.13.31.12;	author jiri_schmid;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.12.12.12.16;	author jiri_schmid;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.11.16.20.07;	author jiri_schmid;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.10.15.54.31;	author jiri_schmid;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.10.10.24.48;	author jiri_schmid;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.10.09.31.28;	author jiri_schmid;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.09.15.58.27;	author jiri_schmid;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.09.10.43.47;	author jiri_schmid;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.08.15.46.35;	author jiri_schmid;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.08.14.58.37;	author jiri_schmid;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.04.14.04.34;	author jiri_schmid;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.04.10.44.36;	author jiri_schmid;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.03.12.03.09;	author jiri_schmid;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.02.16.22.52;	author jiri_schmid;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.01.15.14.09;	author jiri_schmid;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.01.15.00.27;	author jiri_schmid;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.01.12.30.32;	author jiri_schmid;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.01.12.20.43;	author jiri_schmid;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.28.17.31.49;	author jiri_schmid;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.28.16.56.06;	author jiri_schmid;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.28.14.49.49;	author jiri_schmid;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.28.13.03.22;	author jiri_schmid;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.28.07.06.08;	author michald;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.27.16.41.09;	author jiri_schmid;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.27.08.52.44;	author jiri_schmid;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.26.05.36.27;	author michald;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.25.10.07.13;	author michald;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.20.08.17.34;	author michald;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.11.15.06.15;	author jiri_schmid;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.11.14.03.19;	author jiri_schmid;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.10.18.51.59;	author michald;	state Exp;
branches;
next	;


desc
@@


1.71
log
@N:M implementation, foundation for slowly changing dimensions
@
text
@#-----------------------------------------------------
#  Common Library for the Bear Daemon
#-----------------------------------------------------
# $Id: Bearlib.pm,v 1.70 2004/04/14 09:06:43 jiri_schmid Exp $

package Bearlib;

use strict;
use XML::Simple;
use Data::Dumper;
use DBlib;	# should be invoked on this place to ensure BEGIN procedure will be called after initialization of Const.pm in beard.pl
use FileHandle;
use Storable qw(dclone freeze);	#needed for creating independent copy of hash
use Digest::MD5 qw(md5_hex);	#creates unique string from definition
use Const;
use Date::Manip;

use utf8;
binmode(STDOUT, ':utf8');
binmode(STDIN, ':utf8');

# Log File Initialization
if ($Const::LogFile) {
	open(STDOUT, '>>', $Const::LogFile) || die "Can't redirect stdout";
	open(STDERR, ">&STDOUT")     || die "Can't dup stdout";
	select(STDERR); $| = 1;     # make unbuffered
	select(STDOUT); $| = 1;     # make unbuffered
}

#------------------Load Metadata Section---------------------

sub LoadMData {
# load metadata
	my $MDataDir=shift;	# metadata directory for load from
	
	foreach my $pn (GetFiles($MDataDir,$Const::MDataExt)) {	# for each Project Name
		my $md=LoadOneMData($MDataDir.$pn.$Const::MDataExt);
		SQLGen::GraphPNInit($pn);	# init temporary Directed Graph, MDga graph will be initiated as result of APSP_Floyd_Warshall function
		$main::MDgo->{$pn} = new Graph::Directed;	# init Directed Graph of objects dependencies
		
		foreach my $h (keys %{$md->{host}}) {	# for each host name
			foreach (keys %{$md->{host}->{$h}->{source}}) {	# for each data source
				OpenDBConnection($md->{host}, $h, $_);	# open connection for each host/source				
				SQLGen::GraphTempInit("$h/$_");	# init temporary Directed Graph, MDg graph will be initiated as result of APSP_Floyd_Warshall function
			}
		}
		
		JoinMetadata(\$main::MD->{$pn}, \$main::MDi, $md, undef, $pn);
		LoadMDataRecur($MDataDir.$pn."/", $pn) if (-d $MDataDir.$pn);  # each project metadata has corresponding directory as well

		foreach my $attr (keys %{$main::MD->{$pn}->{attr}}) {	# for each attribute ID
			SQLGen::MD2graph($pn, $attr);
		}
		
		foreach my $hri (keys %{$main::MD->{$pn}->{hrelation}}) {	# for each hrelation
			SQLGen::MDh2graph($pn, $hri, $md);	# we have to use $md instead of $main::MD as attr are not expanded into "attr.role" form in $md
		}

		SQLGen::GenAPSP($pn);	# make All-pairs Shortest Paths

	}
}

#---------------------------------------

sub OpenDBConnection {
# open DB Connection
	my $md=shift;	#metadata
	my $h=shift;	#host
	my $s=shift;	#source

	my $src = "$h/$s";
	my $conn = $md->{$h}->{source}->{$s}->{'src-conn'};
	return if ($conn->{driver} ne 'dbi:MySQL');
	DBlib::DBConnect($src, $conn->{'src-name'}->{content}, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content}, $conn->{enc}->{content},1);
	if (@@DBlib::SQLErrors) {
		WriteLog('DB Connection Falied', $src, 1) if ($Const::LogLevel>0);
	} else {
		WriteLog('Open DB Connection', "$conn->{'src-name'}->{content}:$conn->{user}->{content} as $src", 3) if ($Const::LogLevel>2);
	}
}

#---------------------------------------

sub LoadMDataRecur {
# load all metadata under specific directory
	my $MDataDir=shift;	# metadata directory for load from
	my $pName=shift;	# project name
	
	foreach (GetFiles($MDataDir,$Const::MDataExt)) {
		JoinMetadata(\$main::MD->{$pName}, \$main::MDi, LoadOneMData($MDataDir.$_.$Const::MDataExt), $MDataDir.$_.$Const::MDataExt, $pName);
		LoadMDataRecur($MDataDir.$_."/",$pName) if (-d $MDataDir.$_);  # folder's metadata has corresponding directory as well
	}
}

#---------------------------------------

sub JoinMetadata {
# add new metadata to existing metadata tree
	my $MD=shift;	# project specific subtree of metadata
	my $MDi=shift;	# project specific subtree of metadata index
	my $nMD=shift;	# new metadata
	my $path=shift;	# physical path to metadata in filesystem
	my $pName=shift;	# project name

	$path=~s/^$Const::MDataDir// if ($path);	# cut $Const::MDataDir from beginning of the path


	foreach my $typ ('subfolder','group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole','param','pacl') {	# for each object type
		next if (!exists $nMD->{$typ});

		foreach my $id (keys %{$nMD->{$typ}}) {	# foreach object ID

			if ($typ eq 'attr') {
				if (exists $nMD->{group} && ref($nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}) eq 'HASH') {	# attribute has multiple roles
					foreach my $r (keys %{$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}}) {	# make copy for each role of attribute
						my $lmd = {};	# temp. hash to store role copy
						my $i = "$id.$r";	# id of attr.role

						if (ref($nMD->{$typ}->{$id}->{fk}) eq 'ARRAY') {
							foreach (@@{$nMD->{$typ}->{$id}->{fk}}) {
								push @@{$lmd->{$typ}->{$i}->{fk}}, $_
							}
						}
						if (ref($nMD->{$typ}->{$id}->{role}->{$r}->{fk}) eq 'ARRAY') {
							foreach (@@{$nMD->{$typ}->{$id}->{role}->{$r}->{fk}}) {
								push @@{$lmd->{$typ}->{$i}->{fk}}, $_
							}
						}

						if (ref($nMD->{$typ}->{$id}->{name}) eq 'HASH') {		# if name contains localisation
							foreach (keys %{$nMD->{$typ}->{$id}->{name}}) {	# roles have to be localised as well
								$lmd->{$typ}->{$i}->{name}->{$_} = $nMD->{$typ}->{$id}->{name}->{$_}.' ('.$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}->{$r}->{name}->{$_}.')';
							}
						} else {
							$lmd->{$typ}->{$i}->{name} = $nMD->{$typ}->{$id}->{name}.' :'.$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}->{$r}->{name};
						}
						foreach ('link','group','pk','display') {
							$lmd->{$typ}->{$i}->{$_} = $nMD->{$typ}->{$id}->{$_} if exists $nMD->{$typ}->{$id}->{$_};
						}

						MD2mem($MD, $MDi, $lmd, $path, $pName, $typ, $i);
					}
				} else {	# attribute has no roles
					MD2mem($MD, $MDi, $nMD, $path, $pName, $typ, $id);
				}
			} elsif ($typ eq 'hrelation') {
				$$MD->{$typ}->{$id}->{from}->{id} = $nMD->{$typ}->{$id}->{from}->{content};
				$$MD->{$typ}->{$id}->{from}->{card} = $nMD->{$typ}->{$id}->{from}->{cardinality};
				$$MD->{$typ}->{$id}->{to}->{id} = $nMD->{$typ}->{$id}->{to}->{content};
				$$MD->{$typ}->{$id}->{to}->{card} = $nMD->{$typ}->{$id}->{to}->{cardinality};
				$$MD->{$typ}->{$id}->{join} = $nMD->{$typ}->{$id}->{join} if exists $nMD->{$typ}->{$id}->{join};
			} else {	# diffrent object type as attribute
				MD2mem($MD, $MDi, $nMD, $path, $pName, $typ, $id);
			}

			foreach (ObjInvolved($id, $typ, $nMD->{$typ}->{$id})) {	# for each object involved in object $id definition, has to run after seting of MDi by MD2mem
				$main::MDgo->{$pName}->add_edge($_, $id);	# add edge representing dependency of objects
			}
		}
	}
}

sub MD2mem {
# add new metadata into memory hashes
	my $MD=shift;	# project specific subtree of metadata
	my $MDi=shift;	# project specific subtree of metadata index
	my $nMD=shift;	# new metadata
	my $path=shift;	# physical path to metadata in filesystem
	my $pName=shift;	# project name
	my $typ=shift;	# object type
	my $id=shift;	# object ID

	if (exists $$MD->{$typ}->{$id}) {
		foreach my $k (keys %{$nMD->{$typ}->{$id}}) {
			$$MD->{$typ}->{$id}->{$k} = $nMD->{$typ}->{$id}->{$k};
		}
	} else {
		$$MD->{$typ}->{$id} = $nMD->{$typ}->{$id};
	}
	
	if ($typ=~/^attr$|^fact$|^folder$|^relation$/) {	# delete unneded parameters to save some space
		delete($$MD->{$typ}->{$id}->{'gui-presentation'}) if ($$MD->{$typ}->{$id}->{'gui-presentation'});
		delete($$MD->{$typ}->{$id}->{'directory'}) if ($$MD->{$typ}->{$id}->{'directory'});
	}
	$$MDi->{$id}->{ptr} = \$$MD->{$typ}->{$id};	#store pointer to object
	$$MDi->{$id}->{type} = $typ;	#store object type
	$$MDi->{$id}->{path} = $path;	#store object disk location
	$$MDi->{$id}->{proj} = $pName;	#store project name

	if ($typ eq 'urole') {
		foreach (@@{$$MD->{$typ}->{$id}->{uuser}}) {
			Acl::AddUserRoleToUsRL($pName, $id, $_);
		}
		foreach (@@{$$MD->{$typ}->{$id}->{ugroup}}) {
			foreach (@@{$Acl::Grp->{$_}{members}}) {
				Acl::AddUserRoleToUsRL($pName, $id, $_);
			}
		}
	}
	if ($typ eq 'attr') {	# set attributes into MDk
		if (exists $nMD->{$typ}->{$id}->{pk}) {
			foreach my $pk (@@{$nMD->{$typ}->{$id}->{pk}}) {
				if (defined $pk) {
					#my ($src,$t,$k) = ($pk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
					my ($src,$t,$k) = ($pk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
					push(@@{$main::MDk->{$pName}->{$src}->{$t}->{pk}}, $id);
				}
			}
		}
		if (exists $nMD->{$typ}->{$id}->{fk}) {
			foreach my $fk (@@{$nMD->{$typ}->{$id}->{fk}}) {
				if (defined $fk) {
					#my ($src,$t,$k) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
					my ($src,$t,$k) = ($fk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
					push(@@{$main::MDk->{$pName}->{$src}->{$t}->{fk}}, $id);
				}
			}
		}
	}
	if (($typ eq 'fact')&&(ref($nMD->{$typ}->{$id}->{expr}) eq 'ARRAY')) {	# set facts into MDk
		foreach (@@{$nMD->{$typ}->{$id}->{expr}}) {
			if ($_ =~ m{^(.*?/.*?)/(.*?)/(.*)$}) {
				my ($src,$t,$k) = ($1,$2,$3);
				push(@@{$main::MDk->{$pName}->{$src}->{$t}->{m}}, $id);
				push(@@{$main::MDl->{$pName}->{$id}}, "$src/$t");
			} else {
				print "$typ,$id,>> $_ <<\n"
			}
		}
	}
	
}

#---------------------------------------

sub ObjInvolved {
# returns list of objects on which object $Obj depends directly
	my $id = shift;
	my $typ = shift;
	my $Obj = shift;

	my %h;
	if ($typ eq 'grid') {
		foreach (@@{$Obj->{row}}, @@{$Obj->{col}}, @@{$Obj->{page}}) {
			my $r = $_;	#have to make copy to avoid change of original metadata
			next if ($r eq $Const::MetricsIdent);
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
		if ($Obj->{metric}) {
			foreach (@@{$Obj->{metric}}) {
				my $r = $_;	#have to make copy to avoid change of original metadata
				$r =~ s/~.*$//;	# cut display form
		 		$h{$r}++ if $r;
			}
		}
	} elsif ($typ eq 'filter') {
		foreach (getObjectsFromExpr($Obj->{expr})) {
			my $r = $_;	#have to make copy to avoid change of original metadata
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
	} elsif ($typ eq 'metric') {
		foreach (getObjectsFromExpr($Obj->{expr})) {
			my $r = $_;
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
		foreach my $r (@@{$Obj->{aggr_def}}) {	#aggr_def is an array
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
	 	$h{$Obj->{filter_def}}++ if $Obj->{filter_def};
	} elsif ($typ eq 'report') {
		foreach my $o ('format_def', 'var_def', 'filter_def') {
			if (ref($Obj->{$o}) eq 'HASH') {	# object is stored localy
				my $t = {'var_def'=>$Obj->{report_type}, 'filter_def'=>'filter'};	# mapping between type key and locally stored object type
				next if !exists $t->{$o};
				foreach (ObjInvolved($id, $t->{$o}, $Obj->{$o})) {
				 	$h{$_}++;
				}
			} else {	# def contains ID of global object
				my $r = $Obj->{$o};
			 	$h{$r}++ if $r;
			}
		}
	}
	return keys %h;
}

sub getObjectsFromExpr {
# returns list of object names from expression
	my $s = shift;
	return if !$s;
	return ($s=~/\[(.+?)\]/g);
}

#---------------------------------------

sub GetFiles {
# returns list of file names (without extension) with specific extension from specific directory
	my ($td, $fExt)=@@_;	# directory, file ext
	my @@fList=();

	if (opendir(DIR, $td) ) {
		@@fList = grep { /^\w.*$fExt$/ && -f "$td/$_" } readdir(DIR);
		closedir DIR;
	}
	foreach (@@fList) { s/$fExt$// };
	return sort @@fList
}

#---------------------------------------

sub LoadOneMData {
# returns hash of the metadate loaded from spesific file
	my $mdf=shift;	# metadata filename
	
	my $PData = new XML::Simple(rootname=>'project',KeyAttr=>['id','layer'],
					SuppressEmpty=>undef,
					forcearray=>['host','source','table','column',
					'view','connection','relation','signal','const','triger','gui-layer',
					'gui-presentation','transformation','constraint',
					'input','output','attr','fact','folder','hrelation',
					'metric','filter','format','grid','graph3d','format3d','format2d','row','col','page',
					'report','fk','pk','aggr_def','items','rules','urole','uuser','ugroup','param',
					'dates','commons','elements','objects','display','expr','constrain']);

	my $md = $PData->XMLin($mdf);

	WriteLog('Load Metadata',"Load from $mdf",4) if ($Const::LogLevel>3);
	return $md
}    

#------------------End of Load Metadata Section---------------------

sub SaveMData {
# Save metadata
	my $Obj=shift;	#object to save
	my $Rewrit=shift;	#force rewrite
	my $Path=shift;	#path (under $Const::MDataDir, started with project name) where object will be saved

	my $objT=(keys %{$Obj})[0];	# object type
	my $objI=(keys %{$Obj->{$objT}})[0];	#object ID
	my $fn;	# path and filename to save

	my $projN;	# project name
	if ($Path) {
		($projN)=($Path=~/^([^\/]+)\/.*$/);	# project name
		$fn = ($objI) ? $objI : IDGen();	# set filename appropiate to object ID or to generic ID in case ID is missing
		$fn=$Path.$fn.'.xml';
	} else {
		$projN = $main::MDi->{$objI}->{proj};
		$fn = $main::MDi->{$objI}->{path};
	}
	
	if ((-f $Const::MDataDir.$fn)&&(!$Rewrit)) {
		WriteLog('Unsuccessful Rewrite',"Attempt to involuntary rewrite $fn without",3) if ($Const::LogLevel>3);
		return -1	# file exists and $Rewrit flag was not set
	}

	if ($objT eq 'filter') {
		if (!defined $Bear::lePO) {	# file save failed 
			WriteLog('Save of Filter Metadata Falied',"LE Parser is not loaded",1) if ($Const::LogLevel>0);
			return 0
		}
		$Bear::lePO->metricHash(\$main::MD->{$projN}->{metric});	# set metrics hash for further filter decomposition
		if ($Obj->{$objT}->{$objI}->{expr}) {
			if ($Bear::lePO->decomposeLE($Obj->{$objT}->{$objI}->{expr})) {
				$Obj->{$objT}->{$objI}->{def} = $Bear::lePO->resultHash();
			} else {
				WriteLog('Save of Filter Metadata Falied',"Error in filter expression on line ".$Bear::lePO->error->{LINE}.", char ".$Bear::lePO->error->{POS}.", near \"".$Bear::lePO->error->{STR}."\"",1) if ($Const::LogLevel>0);
				return 0
			}
		}
	} elsif (($objT eq 'report') && (ref $Obj->{$objT}->{$objI}->{filter_def} eq 'HASH') && (exists $Obj->{$objT}->{$objI}->{filter_def}->{expr})) {	# local report filter
#print Dumper($Obj->{$objT}->{$objI}->{filter_def}->{expr});
	}

	my $PData = new XML::Simple(keyattr=>['id'], rootname=>'project');
	
	my $fh = new FileHandle;
	open($fh,">${Const::MDataDir}$fn") || print "failed:$Const::MDataDir$fn\n";
	binmode($fh,":utf8");
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$fh, xmldecl=>'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
	close($fh);

	if ($out) {	# file save succeed, let save into memory and create indexes
		WriteLog('Save Metadata',"$fn",4) if ($Const::LogLevel>3);

		if ($objT =~ /^attr$|^fact$/ ) {
			foreach my $k (keys %{$Obj->{$objT}->{$objI}}) {
				$main::MD->{$projN}->{$objT}->{$objI}->{$k} = $Obj->{$objT}->{$objI}->{$k};
			}
		} else {
			$main::MD->{$projN}->{$objT}->{$objI} = $Obj->{$objT}->{$objI};
		}
		$main::MDi->{$objI}->{ptr} = \$main::MD->{$projN}->{$objT}->{$objI};	#store pointer to object
		$main::MDi->{$objI}->{type} = $objT;	#store object type
		$main::MDi->{$objI}->{path} = $fn;	#store object disk location
		$main::MDi->{$objI}->{proj} = $projN;	#store project name

		foreach ($main::MDgo->{$projN}->predecessors($objI)) {	# for each predecessor of object $objI
			$main::MDgo->{$projN}->delete_edge($_, $objI);	# remove edge
		}
		foreach (ObjInvolved($objI, $objT, $Obj->{$objT}->{$objI})) {	# for each object involved in object $id definition
			$main::MDgo->{$projN}->add_edge($_, $objI);	# add edge representing dependency of objects
		}
		# !!! here should be test for cycle $main::MDgo->{$projN}->has_cycle($_, $objI)

		return $fn
	} else {	# file save failed 
		WriteLog('Save Metadata Falied',"$fn",1) if ($Const::LogLevel>0);
		return 0
	}
}

#-----------------------------------------------------

sub DropMData {
# Drop metadata data
	my $Proj=shift;	#project
	my $ID=shift;	#object ID to drop
	
	return if (!$ID);
	my @@suc = &Bear::GetObjSuccessors(undef,$ID); #bject has successors, break deleting
	return @@suc if @@suc > 0;
	if (unlink($Const::MDataDir.$main::MDi->{$ID}->{path})) {
		my $type=$main::MDi->{$ID}->{type};
		delete $main::MD->{$Proj}->{$type}->{$ID};
		delete $main::MDi->{$ID};
		$main::MDgo->{$Proj}->delete_vertex($ID);
		WriteLog('Drop Metadata',"Proj:$Proj, ID:$ID",4) if ($Const::LogLevel>3);
		return undef
	} else {
		WriteLog('Drop Metadata Falied',"$ID",1) if ($Const::LogLevel>0);
		return $ID
	}
}

#--------------------Metadata Definition Serialization-----------------------

sub ObjDefSerial {
# returns serialized object definition, olnly parts affecting data content will be included (e.g. name, description, ACL will be excluded)
	my $Obj = shift;	#object to save
	
}

sub ObjDefExpansion {
# expand all internall references to object definitions in specific object
	my $Obj = shift;	# object to save
	my $ArrSort = shift;	# do we want to sort arrays?

}

#--------------------Users and User Preferences Section-----------------------

sub SaveUserPref {
# save User Preferences Object, if succeeds then set $UserPref->{$User} cache and returns 1
	my $Obj=shift;	#object to save
	my $User=shift; #user name
	my $Path=shift;	#path (under $Const::MDataDir, started with project name) where object will be saved

	if ($Path) {$Path = $Const::MDataDir.$Path} 
	else {$Path = $Const::MDataDir.'Prefer/'};
	
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'preferences');

	my $fh = new FileHandle;
	open($fh,">$Path${User}.xml") || print "failed:$Path$User.xml\n";
	binmode($fh,":utf8");
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$fh, xmldecl=>'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
	close($fh);
	
	if ($out) {	# file save succeed 
		WriteLog('Save Preferences',$User.'.xml',4) if ($Const::LogLevel>3);
		$main::UserPref->{$User} = $Obj;
		return 1
	} else { 	# file save failed 
		WriteLog('Save Preferences Failed',$User.'.xml',1) if ($Const::LogLevel>0);
		return undef
	}

}
#---------------------------------------

sub LoadUserPref {
	my $User=shift;
	my $Path=shift;	# path to metadata file

	if (!$Path) {$Path = 'Prefer/'};
	my $fn = $Const::MDataDir.$Path.$User.'.xml';	 # preferences file

	my $md;
	
	if (-e $fn) {
		my $PData = new XML::Simple(keyattr=>'id', rootname=>'preferences', forcearray=>['report']);
		$md = $PData->XMLin($fn);
	};

	if ($md) {
		my $lang = lc($md->{Beard}->{language});
		if (exists $md->{Beard}->{report}) {
			foreach (keys(%{$md->{Beard}->{report}})) {
				$md->{Beard}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object ~$_", $lang, $Const::DefaultLanguage);
			}
		}
		WriteLog('Load Preferences', $fn, 4) if ($Const::LogLevel>3);
		$main::UserPref->{$User} = $md;
		return $md
	} else {
		WriteLog('Load Preferences Falied', $fn, 1) if ($Const::LogLevel>0);
		return undef
	}
}

#---------------------------------------

sub GetUserPref {
	my $User=shift;
	my $Project=shift;
	my $Item=shift;
	my $umd; #user meta data
	my $load;

	if ($User && $Project) {
		WriteLog('Get User Preferences', "$User/$Project/$Item", 4) if ($Const::LogLevel>3);
		if ($Item) {
			if ($main::UserPref->{$User}->{$Project}->{$Item}) {
				return $main::UserPref->{$User}->{$Project}->{$Item}
			} else {
				$umd = LoadUserPref($User,undef); #force reading user pref from disk
				return $umd->{$Project}->{$Item}
			};
		} else {
			if ($main::UserPref->{$User}->{$Project}) {
				if (exists $main::UserPref->{$User}{$Project}{report}) {
					foreach (keys(%{$main::UserPref->{$User}{$Project}{report}})) {
						$main::UserPref->{$User}{$Project}{report}{$_}{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object ~$_", lc($main::UserPref->{$User}->{$Project}->{language}), $Const::DefaultLanguage);
					}
				}
				return $main::UserPref->{$User}->{$Project}
			} else {
				$umd = LoadUserPref($User,undef); #force reading user pref from disk
				return $umd->{$Project}
			}
		}
	} else  {
		return undef
	};
}
#------------------End of User Preferences Section---------------------

sub LocalizedObj {		# returns localized description
						# $descr = LocalizedObj($descrObj, "NA", 'cz', 'en', ...);

	my $descr=shift;	# description with possible locale
	my $alter=shift;	# alternate description for case specific locale is not defined
	my @@lang=@@_;		# locale(s)
	
	if ($descr) {
		if (ref($descr)=~/HASH/) {
			foreach (@@lang) {
				if (exists ($descr->{$_})) {
					if (ref($descr->{$_})=~/HASH/) {	# empty string is presented as empty hash
						return ''
					} else {
						return $descr->{$_}
					}
				}
			}
		} else {
			return $descr
		}
	}
	return $alter

}

#-----------------------------------------------------

# Log Levels
# 0 ... nothing
# 1 ... Error & Start/Stop
# 2 ... Warning
# 3 ... Info
# 4 ... Trace

sub WriteLog {
	my($Header,$Txt,$Level) = @@_;
	$Header = '' if !$Header;
	$Txt = '' if !$Txt;
	$Level = 0 if !$Level;
	$Header = '* '.$Header if $Level==1;
	print &UnixDate('today','%Y-%m-%d %T')."\t".$Level."\t".$Header."\t".$Txt."\n";
}

#---------------------------------------

my $IDGen=0;
my $IDSt;
my $IDa='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';	# lenght 52 B
my $IDb=$IDa.'0123456789';	# lenght 62 B

sub IDGen {	# singular ID generator
# returns singular string (starting with letter) contains:
#   3 chars are representing sequence of ID (with period 199888)
#   4 chars are representing time (with period 171 days)
#   3 chars are representing PID (max PID should be 62**3)
	if (!$IDGen) {
		$IDSt = '';
		my $t=time%62**4;	# we are using only part of time information to save string space; resulting 171 days period seems enough to ensure ID singularity
		foreach (62**3, 62**2, 62) {	# we are setting 4 chars string depending on time
			$IDSt .= substr($IDb, int($t/$_), 1);
			$t = $t%$_;
		}
		$IDSt .= substr($IDb, $t, 1);
		$t=$$%62**3;
		foreach (62**2, 62) {	# we are setting 3 chars string depending on PID
			$IDSt .= substr($IDb, int($t/$_), 1);
			$t = $t%$_;
		}
		$IDSt .= substr($IDb, $t, 1);
	}
	if ($IDGen==199888) {$IDGen=0} else {$IDGen++};	# 199888=52*62*62; we are returning about 100000 IDs/s on P4/1.6 GHz into empty loop, so such 3 chars string seems enough to keep sequence

	my $i1 = int($IDGen/3844);	# 3844=62*62
	my $i2 = $IDGen%3844;
	return substr($IDa, $i1, 1).substr($IDb, int($i2/62), 1).substr($IDb, $i2%62, 1).$IDSt;	# we are converting $IDGen to 3 char string in space 'aaa','aab',...,'zzz'; returning string is starting with this string to ensure ID is not starting with number

}

#---------------------------------------

sub GetLocalizedRolesList {
	my $use_lang = lc( shift );
	my $project = shift;
	my @@rtrn;
	foreach (keys %{$main::MD->{$project}{urole}}) { push(@@rtrn,LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$use_lang,'en'));}
	return @@rtrn
}

#---------------------------------------

sub GetAllLocalizedRights {
	my $lang = lc( shift );
	my $project = shift;
	my $rtrn;
	foreach (keys %{$main::MD->{$project}{urole}}) {
		$rtrn->{$_}{name} = LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
		$rtrn->{$_}{desc} = LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetAllLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
		$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
	}

	return $rtrn
}

#---------------------------------------

sub GetLocalizedRights {
	my $lang = lc( shift );
	my $project = shift;
	my @@ids = @@_;
	my $rtrn;
	foreach (@@ids) {
		$rtrn->{$_}{name} = LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
		$rtrn->{$_}{desc} = LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
		$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
	}

	return $rtrn
}

#---------------------------------------

sub GetLocalizedAttrLinks {
	my ($attr,$form,$lang) = @@_;
	my $project = $main::MDi->{$attr}->{proj};
	my $links = $main::MD->{$project}{attr}{$attr}{link} if exists $main::MD->{$project}{attr}{$attr}{link};
	my $rtrn;
	foreach (keys %{$links}) {
		$rtrn->{$_} = LocalizedObj($links->{$_}{$form},"? $_",$lang,'en');
	}
	$rtrn->{$attr} = LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{name}, "obj~$attr", $lang , $Const::DefaultLanguage);
	if ($main::MDi->{$attr}->{type} eq 'attr') {
		my @@forms = ();
		foreach my $form (&GetAttrDisplyForms($attr)) {
			push @@forms,LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{display}{$form}{name}, "obj~$form", $lang , $Const::DefaultLanguage),$form;
			}
		$rtrn->{$attr} .= "\t".join(",",@@forms) if @@forms > 0;
	}

	return $rtrn
}

#---------------------------------------

sub GetAttrDisplyForms {
	my ($attr) = @@_;
	return keys %{${ $main::MDi->{$attr}->{ptr} }->{display}}
}

#---------------------------------------

sub GetLocalizedAttrDrill {
	my ($attr,$upDown,$lang) = @@_;
	my $project = $main::MDi->{$attr}->{proj};
	my @@links;
	if ($upDown eq 'UP') {
		@@links = $main::MDga->{$project}->predecessors($attr)
	} elsif ($upDown eq 'DOWN') {
		@@links = $main::MDga->{$project}->successors($attr);
	} else {
		return undef
	}
	my $rtrn;
	foreach my $link (@@links) {
		next if $attr eq $link;
		if ($main::MDi->{$link}->{type} eq 'attr') {
			$rtrn->{$link} = LocalizedObj(${$main::MDi->{$link}->{ptr}}->{name}, "obj~$link", $lang , $Const::DefaultLanguage);
			my @@forms = ();
			foreach my $form (&GetAttrDisplyForms($link)) {
				push @@forms,LocalizedObj(${$main::MDi->{$link}->{ptr}}->{display}{$form}{name}, "obj~$form", $lang , $Const::DefaultLanguage),$form;
			}
			$rtrn->{$link} .= "\t".join(",",@@forms) if @@forms > 0;
		}
	}
	return $rtrn
}

#---------------------------------------

sub GetInvolvedReportMetadata {	# returns hash of metadata in form 'metadata type'=>ID=>{params...}
	my ($ID) = @@_;
	my $obj = Bear::GetMetadata(undef,$ID);	#undef -> do not log call
	my $rtrn = dclone(\%{$obj->{report}{$ID}});

	#handle main definition object
	my $delete = (ref $rtrn->{var_def} eq 'HASH') ? undef : delete $rtrn->{var_def};
	if ($delete) {
		my $hlp = Bear::GetMetadata(undef,$delete);
		if ($rtrn->{report_type} eq 'grid') {
			foreach ('page','col','row','metric'){
				$rtrn->{var_def}{$_} = $hlp->{grid}{$delete}{$_};
			}
		} elsif ($rtrn->{report_type} eq 'graph3d') {
			foreach ('x','z','y','pages','diameter','shape','color','transparency'){
				$rtrn->{var_def}{$_} = $hlp->{graph3d}{$delete}{$_};
			}
		}
		$rtrn->{var_def}{orig_id} = $delete;
	};
	
	#handle filter
	$delete = (ref $rtrn->{filter_def} eq 'HASH') ? undef : delete $rtrn->{filter_def};
	if ($delete) {
		my $hlp = Bear::GetMetadata(undef,$delete);
		$rtrn->{filter_def}{expr} = $hlp->{filter}{$delete}{expr};
		$rtrn->{filter_def}{orig_id} = $delete;
	};

	#handle format
	$delete = (ref $rtrn->{format_def} eq 'HASH') ? undef : delete $rtrn->{format_def};
	if ($delete) {
		my $hlp = Bear::GetMetadata(undef,$delete);
		my $type = Bear::GetObjectType(undef,$delete);
		foreach ('form','type') {
			$rtrn->{format_def}{$_} = $hlp->{$type}{$delete}{$_};
		}
		$rtrn->{format_def}{header} = $hlp->{$type}{$delete}{header} if $type eq 'format';
		$rtrn->{format_def}{orig_id} = $delete;
	};
	
	return $rtrn
}

#---------------------------------------
sub ModifyReport {	#create new report with all included items from original report and involves modifications
	my ($id,$user,$modification,$lang) = @@_;
	my $obj = &GetInvolvedReportMetadata($id);
	my $clone = dclone(\%{$obj});
	$clone->{var_def}{orig_id} = $id if defined $clone->{var_def}{orig_id};
	my $filter = {};
	my @@params = split(/,/,$modification);
	my ($specifiedIn,$specifiedPos);
	$params[0] = $Const::MetricsIdent if $main::MDi->{$params[0]}{type} eq 'metric';
	foreach my $i (3..$#params) {
		my @@cntn = split(/\|/,$params[$i]);
		my @@navig = split(/\./,$cntn[0]);
		my $in = ($navig[0] eq 'r') ? 'row' : 'col';
		if (defined $clone->{var_def}{$in}[$navig[1]]) {
			$clone->{var_def}{$in}[$navig[1]] =~ /^(.*?)(~.*)?$/; # creates internal $1
			push(@@{$filter->{$in}{$1}},$cntn[1]) if $cntn[1] ne '*';
			if ($1 eq $params[0]) {
				$specifiedIn = $in ;
				$specifiedPos = $navig[1];
				$params[0] = $clone->{var_def}{$in}[$navig[1]] if $params[1] =~ /pivot/;
			}
		}
	}

	my $insert = 1;
	for (0..$#{$clone->{var_def}{$specifiedIn}}) {
		if ($params[2] eq $clone->{var_def}{$specifiedIn}[$_]) {
			$insert = 0;	#drilled item is already presented
		}
	}
	if ($params[1] eq 'down' && $insert) {
		if (@@{$clone->{var_def}{$specifiedIn}}[$#{$clone->{var_def}{$specifiedIn}}] eq $Const::MetricsIdent) {
			splice @@{$clone->{var_def}{$specifiedIn}},$#{$clone->{var_def}{$specifiedIn}},0,$params[2];
		} else {
			push @@{$clone->{var_def}{$specifiedIn}},$params[2];
		}
	} elsif ($params[1] eq 'up' && $insert) {
		unshift @@{$clone->{var_def}{$specifiedIn}},$params[2] if $insert;
	} elsif ($params[1] eq 'self') {
		splice @@{$clone->{var_def}{$specifiedIn}},$specifiedPos,1,$params[2];
	} elsif ($params[1] =~ /pivot/) {
		my $target = ($params[1] eq 'pivotX') ? 'col' : 'row'; # source is same as specifiedIn
		my ($targetPos,$targetLength);
		my $eq = int($params[2]) == $params[2] ? 1 : 0;	#replace
		if ($eq) {
			$targetLength = 1;	#replace
			$targetPos = $params[2];
		} else {
			$targetLength = 0;	#add
			$targetPos = $params[2]+0.5;	#0.5 is 'bulgarian constant :-)', but in the fact it match the definition for simple identification of pivot action
		}
		# print "trg: $target, trgpos: $targetPos, trglngth: $targetLength, specin: $specifiedIn, specpos:$specifiedPos\n\n";
		if ($target eq $specifiedIn) {
			if ($targetLength) {
				if ($targetPos == $specifiedPos) {
					if ($params[0] eq $Const::MetricsIdent) {
						#remove selected metric, if more than 2 or exactly 2 metrics presented in definition
						#remove metric indetificator if 1 metric left
						my $index;
						my ($pos,$metric) = split(/\|/,$params[3]);
						for my $i (0..@@{$clone->{var_def}{metric}}) {
							if (${$clone->{var_def}{metric}}[$i] eq $metric) {
								$index = $i;
								last;
							}
						}
						if (defined $index) {
							splice @@{$clone->{var_def}{metric}},$index,1 if @@{$clone->{var_def}{metric}} > 1;
							splice @@{$clone->{var_def}{$target}},$targetPos,1 if @@{$clone->{var_def}{metric}} == 2;
						}
					} else {
						splice @@{$clone->{var_def}{$target}},$targetPos,1;	#remove item within self
					}
				} else {
					splice @@{$clone->{var_def}{$target}},$specifiedPos,1;		#remove old item in same row
					$targetPos-- if $targetPos > $specifiedPos && $targetPos > 0;
					splice @@{$clone->{var_def}{$target}},$targetPos,1,$params[0];	#replace within self
				}
			} elsif ($targetPos < $specifiedPos || $targetPos > $specifiedPos+1) {	#insert within self
				splice @@{$clone->{var_def}{$target}},$specifiedPos,1;		#remove old item in same row
				$targetPos-- if $targetPos > $specifiedPos;			#move new item one point down, due to unshift of old item
				splice @@{$clone->{var_def}{$target}},$targetPos,0,$params[0];	#insert new item
			}
		} else {
			splice @@{$clone->{var_def}{$target}},$targetPos,$targetLength,$params[0];	#insert/replace item (depends on targetLength)
			splice @@{$clone->{var_def}{$specifiedIn}},$specifiedPos,1;			#remove source item
		}
		undef $filter;	#do create filter from selection when pivoting
	}

	my $filtr;
	foreach my $location (keys %{$filter}) {
		my $subFilter;
		foreach my $attr (keys %{$filter->{$location}}) {
			if ($main::MDi->{$attr}{type} eq 'attr') {
				$subFilter .= ($subFilter) ? " OR ([$attr] IN (".join(",",@@{$filter->{$location}{$attr}})."))" : "([$attr] IN (".join(",",@@{$filter->{$location}{$attr}})."))";
			}
		}
		$filtr = ($filtr) ? "($filtr) AND ($subFilter)" : "$subFilter" if $subFilter;
	}

	$clone->{filter_def}{expr} = (defined $clone->{filter_def}{expr}) ? "($clone->{filter_def}{expr}) AND ($filtr)" : "$filtr" if $filtr;

	#------- create hash string from modification --------
	my $hash = {};
	$hash->{filter} = $clone->{filter_def}{expr};
	foreach my $key (keys %{$clone->{var_def}}) {
		next if $key eq 'orig_id';
		$hash->{object}{$key} = $clone->{var_def}{$key};
	}
	if (exists $clone->{format_def}) {
		foreach ('form','type','header') {
			$hash->{format}{$_} = $clone->{format_def}{$_};
		}
	}
	my $newId = &getUniqueHashString($hash,'RT');
	#------------------------------------------------------

	my $project = $main::MDi->{$id}->{proj};
	if (-e "$Const::myPath$Const::MDataDir$project/PrivateMD/$user/Reports/$newId.xml") {
		&setNewMetaInformation($clone->{meta},$user);
	} else {
		&setNewMetaInformation($clone->{meta},$user,'all');
	}

	my $FullObj = {};
	$clone->{modification} = "$params[0],$params[1],$params[2]";
	$clone->{name} = &setLocalizedObj($clone->{name},LocalizedObj($clone->{name}, "obj~$1", $lang , $Const::DefaultLanguage)."*",$lang);
	$FullObj->{report}{$newId} = $clone;
	my $saved = SaveMData($FullObj,1,"$project/PrivateMD/$user/Reports/");
	return $saved ? $newId : undef;

}

#---------------------------------------
sub getUniqueHashString {	#converts hash into unique stamp
	my ($hash) = @@_;
	return md5_hex(freeze(\%{$hash}))
}

#---------------------------------------
sub setNewMetaInformation {	#sets modifier and time of modificiation, when defined all creator and created is set
	my ($obj,$user,$all) = @@_;
	my $dateTime = &getTime;
	$obj->{creator} = $user if $all;
	$obj->{modifier} = $user;
	$obj->{modified} = $dateTime;
	$obj->{created} = $dateTime if $all;
}

#---------------------------------------
sub getTime {
	my @@time = localtime(time);
	return sprintf "%d-%02d-%02d, %02d:%02d:%02d",($time[5] += 1900),($time[4]++),($time[3]++),$time[2],$time[1],$time[0];
}

#---------------------------------------
sub GetDerivatedReports {
my ($path,$ext,$lang,$proj) = @@_;
my $rtrn;
	if (opendir DIR,$path) {
		my $cnt = 0;
		foreach my $dirFile (readdir DIR) {
			if ($dirFile =~ /^(.*?)\.$ext$/) {
				if (!exists($main::MDi->{$1})) { #dirfile with its ID is not stored in memory
					JoinMetadata(\$main::MD->{$proj}, \$main::MDi, LoadOneMData("$path/$dirFile"),"$path/$dirFile", $proj);
				}
				my @@time = localtime( (stat "$path/$dirFile")[9] );
				$rtrn->{$cnt}{date} = sprintf "%d-%02d-%02d, %02d:%02d:%02d",($time[5] += 1900),($time[4]++),($time[3]++),$time[2],$time[1],$time[0];
				$rtrn->{$cnt}{id} = $1;
				if (exists $main::MDi->{$1}) {
					$rtrn->{$cnt}{name} = LocalizedObj(${$main::MDi->{$1}->{ptr}}->{name}, "obj~$1", $lang , $Const::DefaultLanguage);
					my $original = ${ $main::MDi->{$1}{ptr} }->{var_def}{orig_id};
					$rtrn->{$cnt}{modification} = ${$main::MDi->{$1}->{ptr}}->{modification};
					if (exists $main::MDi->{$original}) {
						$rtrn->{$cnt}{orig_id} = $original;
						$rtrn->{$cnt}{orig_name} = LocalizedObj(${$main::MDi->{$original}->{ptr}}->{name}, "obj~$original", $lang , $Const::DefaultLanguage);
					} else {
						$rtrn->{$cnt}{orig_id} = "?";
						$rtrn->{$cnt}{orig_name} = "?";
					}
				} else {
					$rtrn->{$cnt}{name} = $1;
					$rtrn->{$cnt}{orig_id} = "?";
					$rtrn->{$cnt}{orig_name} = "?";
				}
				$cnt++;
			}
		}
	}
return $rtrn
}

#---------------------------------------
sub setLocalizedObj {		#sets the object with or without localized names / descriptions

	my $localObj = shift;
	my $stringToSave = shift;
	my $lang = shift;
	$stringToSave =~ s/\r//g;
	$stringToSave =~ s/\n/\\n/g;

	if ($lang) {						#if localized data is to save
		$localObj = undef if (ref($localObj)!~/HASH/);	#prepare/clear object for saving if no other localized datas presented
		$localObj->{$lang} = $stringToSave;
		return $localObj
	} else {
		return $stringToSave;
	}
}

#----------------------------------
sub GetDynamicParamsInReport {
	my ($ID,$lang,$user,$ignoreReset) = @@_;
	my $rtrn = {};
	my $proj = &Bear::GetProjectName(undef,$ID);
	my $rprt = &GetInvolvedReportMetadata($ID);	#get definition of report build as one hash

	&getDynamicParamsInDefinition($rtrn,$rprt,$proj);	#primary find DP in main definition
	
	if (keys %{$rtrn->{object}} == 0) { #if no primary params (in definition object, remove its key
		delete $rtrn->{object};	#remove object symptom it has no content
		delete $rtrn->{others}{metrics} if exists $rtrn->{others}; # remove recursive break for analyzing filter
		delete $rtrn->{others} if keys %{$rtrn->{others}} == 0; #remove filter symptom if has no content
	} else {	#else remove other DP, till defined and substituted primary
		delete $rtrn->{others}	
	}
	
	&localizeDynamicParams($rtrn,$ID,$user,$lang,$ignoreReset);	#assign names for params and its values
	
	return $rtrn
}

#----------------------------------
sub paramsInMetric {
my ($metricId, $definitions) = (shift,shift);
my $proj = &Bear::GetProjectName(undef,$metricId);
my $obj = &Bear::GetMetadata(undef,$metricId);	#undef -> do not log call
$definitions->{metrics}{$metricId} = 1;	#avoid recursive deadlock in metrics
	while ($obj->{metric}{$metricId}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$definitions->{$1} = {};
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			next if exists $definitions->{metrics}{$1};
			&paramsInMetric($1,$definitions);
		}
	}
return 1
}

#----------------------------------
sub getDynamicParamsInDefinition { 
my ($rtrn,$rprt,$proj) = @@_;
foreach my $key (keys %{$rprt->{var_def}}) {	#analyze all key in definition, skip orig_id
	next if $key eq 'orig_id';
	if ($rprt->{report_type} eq 'grid') {
		foreach (@@{$rprt->{var_def}{$key}}) {
			if (exists $main::MD->{$proj}{param}{$_}) {	#object is DP, save that inf
				$rtrn->{object}{$_} = {};
				$rtrn->{object}{$_}{content} = &getContentType($key,'grid'); #for definition object part is necessary proper content of DP
			} elsif (exists $main::MD->{$proj}{metric}{$_}) {
				$rtrn->{others} = {} if ref($rtrn->{others}) ne "HASH";
				&paramsInMetric($_,$rtrn->{others});
			}
		}
	} elsif ($rprt->{report_type} eq 'graph3d') {
		foreach (@@{$rprt->{var_def}{$key}{items}}) {
			if (exists $main::MD->{$proj}{param}{$_}) {
				$rtrn->{object}{$_} = {};
				$rtrn->{object}{$_}{content} = &getContentType($key,'graph3d',\$rprt->{var_def}{$key}{items});
			} elsif (exists $main::MD->{$proj}{metric}{$_}) {
				$rtrn->{others} = {} if ref($rtrn->{others}) ne "HASH";
				&paramsInMetric($_,$rtrn->{others});
			}
		}
	}
}
	
while ($rprt->{filter_def}{expr} =~ /\[(.*?)\]/g) {	#till squre bracket, analyze its content for a type
	if (exists $main::MD->{$proj}{param}{$1}) {
		$rtrn->{others}{$1} = {}
	} elsif (exists $main::MD->{$proj}{metric}{$1}) {
		$rtrn->{others} = {} if ref($rtrn->{others}) ne "HASH";
		&paramsInMetric($1,$rtrn->{others});	#exists another
	}
}

return $rtrn
}

#----------------------------------
sub getContentType {	#checks of type for definiton object
my ($key, $type, $ptr) = @@_;
if ($type eq 'grid') {	#analyze grid
	if ($key =~ /^row$|^page$|^col$/) {	#grid contents only attr excluding metrics
		return 'attr'
	} elsif ($key =~ /^metric$/) {
		return 'metric'
	} else {
		return undef
	}
} elsif ($type eq 'graph3d') {	#analyze grid
	foreach (@@{$$ptr}) {	#check for type all presented objects
		next if $main::MDi->{$_}{type} eq 'param';
		return $main::MDi->{$_}{type};
	}
	return 'unknown'
}
}

#----------------------------------
sub localizeDynamicParams {
	my ($rtrn,$ID,$user,$lang,$ignoreReset) = @@_;
	my $all = 1;	#expecting all params are defined
	foreach my $key (keys %{$rtrn}) {
		foreach my $id (keys %{$rtrn->{$key}}) {	#add all infromations about DP
			my $obj = ${$main::MDi->{$id}->{ptr}};
			$rtrn->{$key}{$id}{type} = $obj->{type};
			$rtrn->{$key}{$id}{subtype} = $obj->{def}{type} if $obj->{type} =~ /^common$|^date$/;	#subtype presented
			$rtrn->{$key}{$id}{min} = ($obj->{def}{min} < 0) ? 0 : $obj->{def}{min};	#negative count
			$rtrn->{$key}{$id}{max} = ($obj->{def}{min} < $obj->{def}{max}) ? $obj->{def}{max} : ($obj->{def}{min} > 0) ? $obj->{def}{min} : 1; #max is less than min
			$rtrn->{$key}{$id}{ask} = LocalizedObj($obj->{q}{ask}, "no question", $lang, $Const::DefaultLanguage);
			$rtrn->{$key}{$id}{help} = LocalizedObj($obj->{q}{help}, "no help", $lang, $Const::DefaultLanguage);
			$rtrn->{$key}{$id}{prop} = $obj->{def}{prop};
			$rtrn->{$key}{$id}{share} = $obj->{def}{share};
			if (&checkParam($id,$ID,$user,$rtrn->{$key}{$id})) { #check if params are defined in memory
				if ($rtrn->{$key}{$id}{prop} eq 'reset') {
					$rtrn->{$key}{$id}{view} = 5;
					undef $all if !$ignoreReset; #sign undef param because of reset type, but when ignoreReset do not do that
				} else {
					$rtrn->{$key}{$id}{view} = $rtrn->{$key}{$id}{prop} eq 'lock' ? 10 : 0;
				}
				$rtrn->{$key}{$id}{values} = ($rtrn->{$key}{$id}{share}) ? $main::UserPref->{$user}{$id} : $main::UserPref->{$user}{$ID}{$id};
			} else {
				$rtrn->{$key}{$id}{view} = 1;
				undef $all;	#param is not defined in memory
			}
			if ($obj->{type} eq 'object' && $key eq 'object') {	#DP is in definition segment (grid, graph3d)
				my $content = delete $rtrn->{$key}{$id}{content};#expected content type
				foreach my $alt (@@{$obj->{def}{alternatives}}) {
					my ($name,$form) = split(/~/,$alt); #/
					if ($content eq $main::MDi->{$name}{type}) {
						&localizeAlternatives($rtrn->{$key}{$id},$alt,$name,$form,$lang);
					} else {
						$rtrn->{$key}{$id}{type} = 'mismatch';
						$rtrn->{$key}{$id}{name} = LocalizedObj(${$main::MDi->{$id}->{ptr}}->{name}, "obj~$id", $lang , $Const::DefaultLanguage) if $rtrn->{$key}{$id}{type} eq 'mismatch';
					}
				}
			} elsif ($obj->{type} =~ /^element$|^common$|^date$/) {#DP is somewhere in filter, metric..
				foreach my $alt (@@{$obj->{def}{alternatives}}) {
					push @@{$rtrn->{$key}{$id}{alt}},$alt;
				}
			} elsif ($obj->{type} eq 'object') {	#DP is somewhere, but is object type, thus is necessary to localize values
				foreach my $alt (@@{$obj->{def}{alternatives}}) {
					my ($name,$form) = split(/~/,$alt); #/
					&localizeAlternatives($rtrn->{$key}{$id},$alt,$name,$form,$lang);
				}
			}
		}
	}
$rtrn->{defined} = $all if (exists $rtrn->{object} || exists $rtrn->{others}); #save sign of defined params, if exists DP
}

#----------------------------------
sub localizeAlternatives {	#localize DP values and store ids
my ($rtrn,$alt,$name,$form,$lang) = @@_;
if ($form) {
	push @@{$rtrn->{alt}},LocalizedObj(${$main::MDi->{$name}->{ptr}}->{name}, "obj:$name", $lang , $Const::DefaultLanguage)."~".LocalizedObj(${$main::MDi->{$name}->{ptr}}->{display}{$form}{name}, "form:$form", $lang , $Const::DefaultLanguage);
	push @@{$rtrn->{ids}},$alt;
} else {
	push @@{$rtrn->{alt}},LocalizedObj(${$main::MDi->{$alt}->{ptr}}->{name}, "obj:$alt", $lang , $Const::DefaultLanguage);
	push @@{$rtrn->{ids}},$alt;
}
}

#----------------------------------
sub checkParam {
	my ($id,$rid,$user,$param) = @@_;
	if ($param->{share}) {	# values are shared
		if (defined $main::UserPref->{$user}{$id} && ($param->{min} <= @@{$main::UserPref->{$user}{$id}} || $param->{min} == 0)) {#values are defined in minimal requested amount
			return 1
		} else {
			return undef
		}
	} else {	# values are standalone
		if (exists $main::UserPref->{$user}{$rid} && defined $main::UserPref->{$user}{$rid}{$id}) {#values should be defined
			if ($param->{min} <= @@{$main::UserPref->{$user}{$rid}{$id}} || $param->{min} == 0) {  # values are defined in minimal requested amount
				return 1
			} else {
				return undef
			}
		} else {
			return undef
		}
	}
}

#----------------------------------
sub setParam {
my ($id,$rid,$user,$param) = @@_;
my ($new, $view);
$new = (@@{$param->{values}} >= $param->{min} || $param->{min} == 0) ? 1 : 0; #defined minimal new itmes
$view = not($new);	#if not enough params show again
splice @@{$param->{values}},$param->{max} if $param->{max} < @@{$param->{values}}; #cut exceeding items if present some
if ($param->{prop} =~ /^reset$|^default$/) {
	if ($param->{share}) {
		$main::UserPref->{$user}{$id} = $param->{values} if $new;
		$param->{view} = $param->{prop} eq 'reset' ? 1 : $view;	#is viewed again when not enough params defined
		return $new #return 1 if new values were successfully asigned
	} else {
		$main::UserPref->{$user}{$rid}{$id} = $param->{values} if $new;
		$param->{view} = $param->{prop} eq 'reset' ? 1 : $view;
		return $new
	}
} elsif ($param->{prop} eq 'lock') {
	if ($param->{share}) {
		if (defined $main::UserPref->{$user}{$id} && @@{$main::UserPref->{$user}{$id}} <= $param->{max} && (@@{$main::UserPref->{$user}{$id}} >= $param->{min} || $param->{min} == 0)) {
			$param->{view} = 0;
			return 1
		} else {
			$main::UserPref->{$user}{$id} = $param->{values} if $new;
			$param->{view} = $view;
			return $new
		}
	} else {
		if (defined $main::UserPref->{$user}{$rid}{$id} && @@{$main::UserPref->{$user}{$rid}{$id}} <= $param->{max} && (@@{$main::UserPref->{$user}{$rid}{$id}} >= $param->{min} || $param->{min} == 0)) {
			$param->{view} = 0;
			return 1
		} else {
			$main::UserPref->{$user}{$rid}{$id} = $param->{values} if $new;
			$param->{view} = $view;
			return $new
		}
	}
} else {
	return undef
}
}

#----------------------------------
sub SetDynamicParams {
my ($user,$rprtid,$lang,$params) = @@_;
my $dynamic = GetDynamicParamsInReport($rprtid,$lang,$user);

my $rtrn = 1;
if (exists $main::UserPref->{$user}) {
	foreach my $type (keys %{$dynamic}) {
		next if $type eq 'defined';
		foreach my $dpid (keys %{$dynamic->{$type}}) {	#dynamic param id
			if ($params->{$dpid}{view}) {	#params were vied and thus values were set
				$dynamic->{$type}{$dpid}{values} = $params->{$dpid}{values};
				undef $rtrn if !&setParam($dpid,$rprtid,$user,$dynamic->{$type}{$dpid});
			} else {
				undef $rtrn if !&checkParam($dpid,$rprtid,$user,$dynamic->{$type}{$dpid});
			}
		}
	}
} else {
	undef $rtrn
}
$dynamic->{defined} = $rtrn; #if $rtrn undef, at least one param is not defined
$dynamic = &SubstituteParamsInReport($dynamic,$rprtid,$user,$lang) if $rtrn;


return $dynamic
}

#----------------------------------
sub SubstituteParamsInReport {	#create new report with substituted params in current level
my ($dynamics,$id,$user,$lang) = @@_;
my $obj = &GetInvolvedReportMetadata($id);
my $clone = dclone(\%{$obj});
my $newId;
my $positions;
if (exists $dynamics->{object}) {
foreach my $dpid (keys %{$dynamics->{object}}) {
	if ($dynamics->{object}{$dpid}{type} eq 'object') {
		$positions = &getPositions($obj->{var_def},$dpid); #find position and location of DP in definition structure
		if (exists $positions->{location}) {
			my $shift = 0;
			my $first = 1;
			my $values = ($dynamics->{object}{$dpid}{share}) ? \$main::UserPref->{$user}{$dpid} : \$main::UserPref->{$user}{$id}{$dpid};
			foreach my $value (@@{$$values}) {	#add all values
				splice @@{$clone->{var_def}{$positions->{location}}},$positions->{pos}+$shift,$first,$value;
				$first = 0 if $shift == 0; #1time replace, than add
				$shift++;
			}
			if ($dynamics->{object}{$dpid}{min} == 0 && 1 > @@{$dynamics->{object}{$dpid}{values}}) {#param can be undefined (remove them)
				splice @@{$clone->{var_def}{$positions->{location}}},$positions->{pos},1;
			}
		}
	}
}
$positions = &getPositions($obj->{var_def},$Const::MetricsIdent); #find position of metric group
if (exists $clone->{var_def}{metric}) {#check of posibility to add or remove metric group
	if (exists $positions->{location}) { #check existence of metric group
		if (@@{$clone->{var_def}{metric}} < 2) { #useless metric group
			splice @@{$clone->{var_def}{$positions->{location}}},$positions->{pos},1;
		}
	} else {
		if (@@{$clone->{var_def}{metric}} > 1) { #missing metric group
			push @@{$clone->{var_def}{row}},$Const::MetricsIdent;
		}
	}
}

	#------- create hash string from modification --------
	my $hash = {};
	$hash->{filter} = $clone->{filter_def}{expr};
	foreach my $key (keys %{$clone->{var_def}}) {
		next if $key eq 'orig_id';
		$hash->{object}{$key} = $clone->{var_def}{$key};
	}
	if (exists $clone->{format_def}) {
		foreach ('form','type','header') {
			$hash->{format}{$_} = $clone->{format_def}{$_};
		}
	}
	$newId = &getUniqueHashString($hash,'RT');
	#------------------------------------------------------

my $project = $main::MDi->{$id}->{proj};
if (-e "$Const::myPath$Const::MDataDir$project/PrivateMD/$user/Reports/$newId.xml") {
	&setNewMetaInformation($clone->{meta},$user);
} else {
	&setNewMetaInformation($clone->{meta},$user,'all'); #set creator inf as well
}

my $FullObj = {};
$clone->{name} = &setLocalizedObj($clone->{name},&LocalizedObj($clone->{name}, "obj", $lang , $Const::DefaultLanguage)."*",$lang);
$clone->{modification} = "dynamic params";
$FullObj->{report}{$newId} = $clone;
my $saved = &SaveMData($FullObj,1,"$project/PrivateMD/$user/Reports/");
} else {
	$newId = $id;
}

my $rtrn;
$rtrn->{success} = 1;
my $sameChange = ($newId eq $id) ? 1 : 0; #dynamic params are presented but not included in definition
my $nextDynamicParams = &GetDynamicParamsInReport($newId,$lang,$user,$sameChange);
$rtrn->{id} = $newId;
if (exists $nextDynamicParams->{defined}) {
	$rtrn->{dynamics} = $nextDynamicParams;
	$rtrn->{paramsDefined} = $nextDynamicParams->{defined};
} else {
	$rtrn->{dynamics} = $dynamics;
	$rtrn->{paramsDefined} = 1;	# substitution oparetion succed
}

return $rtrn
}

#-------------------------------
sub getPositions {	#get 
my ($def,$id) = @@_;
my $rtrn;
foreach my $type (keys %{$def}) {
	next if $type eq 'orig_id';
	for (0..$#{$def->{$type}}) {
		if ($def->{$type}[$_] eq $id) {
			$rtrn->{location} = $type;
			$rtrn->{pos} = $_;
			return $rtrn
		}
	}
}
return undef
}

#-------------------------------
sub CheckAccess2Tab {	#check if content of tab can be viewed to user
my ($tab,$userID,$project) = @@_;
my @@roles;
@@roles = &Acl::GetUserRolesFromUsRL($project,$userID);
return 0 if @@roles < 1;	#user must be asigned at least to 1 role
my $rtrn = 1;
foreach (@@roles) {
	if ($_ eq "${project}_root") {
		return 1
	} else {
		$rtrn = 0 if &getRoleTabs($project,$_,$tab) =~ /$tab/; #internal function get.. vs SOAP function Get.. 
	}
}
return $rtrn
}

#-------------------------------
sub getRoleTabs {	#returns string with forbidden tabs or undef
my ($project,$roleID) = @@_;
return ($project && $roleID) ? $main::MD->{$project}{urole}{$roleID}{tabs} : undef
}

#-------------------------------
sub GetRoleTabs { #returns concatenated string of all forbidden tabs in each role assigned to user
my ($project,$userID,$tab) = @@_;
my @@roles = &Acl::GetUserRolesFromUsRL($project,$userID);
return undef if @@roles < 1;	#user must be asigned at least to 1 role
my $rtrn = "";
foreach (@@roles) {
	if ($_ eq "${project}_root") {
		return ''
	} else {
		$rtrn .= &getRoleTabs($project,$_); #internal function get.. vs SOAP function Get..
	}
}
return $rtrn
}

#-------------------------------
sub CheckAccess2Object {
my ($userID,$project,$id,@@rghts) = @@_;
return 1 if &checkOwner($userID,$id,$project);	#skip checking user is owner
my @@roles = &Acl::GetUserRolesFromUsRL($project,$userID);	#get roles assigned to user
return undef if @@roles < 1;	#user must be asigned at least to 1 role
my ($rtrn,$rghts,$rights,$all);
my $root = "$project"."_root";	#default role for root
foreach (@@rghts) {
	$rights->{$_} = 0;	#store information for each access right
}
#my @@suc = $main::MDgo->{$project}->predecessors($attr); #bject has successors, break deleting
my @@ids = grep(/E/,@@rghts) ? ($id,&Bear::GetObjPredecessors(undef,$id)) : $id ;
foreach my $type ('deny','allow') { #order of chacking is very important
	foreach my $id (@@ids) {
		$rights = {};
		($rghts,$all) = &getRights4Object($id,$type,$project,join('',@@rghts));
		push @@roles,$all if $all; #no rights saved within object def. force checking for default rigths
		foreach my $role (@@roles) {
			return 1 if $role eq $root; #skip checking, user has root's rights
			if (exists $rghts->{$role}) {
				foreach (@@rghts) {
					$rights->{$_} = 1 if $rghts->{$role} =~ /$_/; #label found
				}
			}
		}
		pop @@roles if $all; #remove previusly added role
		my $subrtrn = 0;
		foreach (@@rghts) {
			$subrtrn++ if $rights->{$_}; #count labels
		}
		if ($type eq 'deny') {
			return 0 if $subrtrn > 0;	#at least one label found when checking deny rights, skip che
		} else { 
			$subrtrn = $subrtrn < @@rghts ? 0 : 1;	#some label wasnt found when checking allow rights
			$rtrn->{$id} = $all || $subrtrn ? $subrtrn : &checkOthersAccess2Object($project,$id,@@rghts); #rights 4 other were tested or allowed right found return result else check rights 4 other
		}
	}
}
my $finalrtrn = 0;
foreach (@@ids) {	#count if all object have been successfully tested on allow rights
	$finalrtrn += $rtrn->{$_};
}
return $finalrtrn == @@ids ? 1 : 0
}

#-------------------------------
sub checkOthersAccess2Object {
my ($project,$id,@@rghts) = @@_;
my ($rtrn,$rights);
foreach (@@rghts) {
	$rights->{$_} = 0;	#store information for each access right
}

foreach my $type ('deny','allow') { #order of chacking is very important
	my $rghts = &getOthersRights4Object($id,$type,$project,join('',@@rghts)); #at first check deny rights fo right $_
	foreach (@@rghts) {
		$rights->{$_} = 1 if $rghts =~ /$_/; #label found
	}
	$rtrn = 0;
	foreach (@@rghts) {
		$rtrn++ if $rights->{$_}; #count labels
	}
	return 0 if $type eq 'deny' && $rtrn > 0;	#at least one label found when checking deny rights
	$rtrn = $rtrn < @@rghts ? 0 : 1;	#some label wasnt found when checking allow rights
}
return $rtrn	#return 1 if found label for allow,0 when found nothing
}

#-------------------------------
sub getOthersRights4Object { #return string of rights, or rights supplied with params
my ($id,$type,$project,$rght) = @@_;
my $objType = Bear::GetObjectType(undef,$id);
if (ref $main::MD->{$project}{$objType}{$id}{acl} eq 'HASH') {
	#return rights stored in object for rights of others, else return supplied right praram (at first deny type)
	return exists $main::MD->{$project}{$objType}{$id}{acl}{$type}{"${project}_all"} ? $main::MD->{$project}{$objType}{$id}{acl}{$type}{"${project}_all"} : $rght;
} else {
	#return default rights for others, else return supplied right praram (at first deny type)
	return $main::MD->{$project}{$objType}{$id}{acl} eq "${project}_all" ? $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type} : $rght;
}
}

#-------------------------------
sub getRights4Object { #return hash role id : rights for specified type of rights (allow,deny), and extra label 'all' if object has default rights only
my ($id,$type,$project,$rghts) = @@_;
my $objType = Bear::GetObjectType(undef,$id);
if (ref $main::MD->{$project}{$objType}{$id}{acl} eq 'HASH') {
	return exists $main::MD->{$project}{$objType}{$id}{acl}{$type} ? ($main::MD->{$project}{$objType}{$id}{acl}{$type},undef) : ({},undef);
} elsif ($main::MD->{$project}{$objType}{$id}{acl} eq "${project}_all") {
	my $rtrn;
	$rtrn->{"${project}_all"} = exists $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type} ? $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type} : $rghts; #rights for all
	return ($rtrn,"${project}_all")
} else {
	return {}
}
}

#---------------------------------------
sub checkOwner {	#check if user is owner of object
my ($user,$id,$project) = @@_;
my $type = Bear::GetObjectType(undef,$id);
if ($type) {
	return $main::MD->{$project}{$type}{$id}{meta}{creator} eq $user ? 1 : 0
}
return undef
}

#---------------------------------------
sub GetSqlAccess {	#check if user has access to sql def
my ($user,$project) = @@_;
my @@roles = &Acl::GetUserRolesFromUsRL($project,$user);	#get roles assigned to user
my $sql;
foreach (@@roles) {
	$sql->{ $main::MD->{$project}{urole}{$_}{sql} }++;
}
if (exists $sql->{none}) {	#order of sequences is important
	return 'none'
} elsif (exists $sql->{view}) {
	return 'view'
} elsif (exists $sql->{edit}) {
	return 'edit'
} else {
	return undef
}
}

#-------------------------------

1

__END__

@


1.70
log
@universal custom folders system implemented 4 facts
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.69 2004/04/13 12:42:37 michald Exp $
d42 1
a42 1
			foreach (keys %{$md->{host}->{$h}->{source}}) {
d56 1
a56 1
			SQLGen::MDh2graph($pn, $hri, $md);
d152 1
a152 1
				$$MD->{$typ}->{$id}->{join} = $nMD->{$typ}->{$id}->{join};
d328 1
a328 1
					'dates','commons','elements','objects','display','expr']);
d637 3
a639 3
my $use_lang = lc( shift );
my $project = shift;
my @@rtrn;
a641 1

d647 8
a654 8
my $lang = lc( shift );
my $project = shift;
my $rtrn;
foreach (keys %{$main::MD->{$project}{urole}}) {
	$rtrn->{$_}{name} = LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
	$rtrn->{$_}{desc} = LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetAllLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
	$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
}
d656 1
a656 1
return $rtrn
d662 9
a670 9
my $lang = lc( shift );
my $project = shift;
my @@ids = @@_;
my $rtrn;
foreach (@@ids) {
	$rtrn->{$_}{name} = LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
	$rtrn->{$_}{desc} = LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
	$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
}
d672 1
a672 1
return $rtrn
d676 1
d678 15
a692 15
my ($attr,$form,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my $links = $main::MD->{$project}{attr}{$attr}{link} if exists $main::MD->{$project}{attr}{$attr}{link};
my $rtrn;
foreach (keys %{$links}) {
	$rtrn->{$_} = LocalizedObj($links->{$_}{$form},"? $_",$lang,'en');
}
$rtrn->{$attr} = LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{name}, "obj~$attr", $lang , $Const::DefaultLanguage);
if ($main::MDi->{$attr}->{type} eq 'attr') {
	my @@forms = ();
	foreach my $form (&GetAttrDisplyForms($attr)) {
		push @@forms,LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{display}{$form}{name}, "obj~$form", $lang , $Const::DefaultLanguage),$form;
		}
	$rtrn->{$attr} .= "\t".join(",",@@forms) if @@forms > 0;
}
d694 1
a694 1
return $rtrn
d698 1
d700 2
a701 2
my ($attr) = @@_;
return keys %{${ $main::MDi->{$attr}->{ptr} }->{display}}
d705 1
d707 20
a726 18
my ($attr,$upDown,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my @@links;
if ($upDown eq 'UP') {
	@@links = $main::MDga->{$project}->predecessors($attr)
} elsif ($upDown eq 'DOWN') {
	@@links = $main::MDga->{$project}->successors($attr);
} else {
	return undef
}
my $rtrn;
foreach my $link (@@links) {
	next if $attr eq $link;
	if ($main::MDi->{$link}->{type} eq 'attr') {
		$rtrn->{$link} = LocalizedObj(${$main::MDi->{$link}->{ptr}}->{name}, "obj~$link", $lang , $Const::DefaultLanguage);
		my @@forms = ();
		foreach my $form (&GetAttrDisplyForms($link)) {
			push @@forms,LocalizedObj(${$main::MDi->{$link}->{ptr}}->{display}{$form}{name}, "obj~$form", $lang , $Const::DefaultLanguage),$form;
a727 1
		$rtrn->{$link} .= "\t".join(",",@@forms) if @@forms > 0;
d729 1
a729 2
}
return $rtrn
d780 20
a799 19
my ($id,$user,$modification,$lang) = @@_;
my $obj = &GetInvolvedReportMetadata($id);
my $clone = dclone(\%{$obj});
$clone->{var_def}{orig_id} = $id if defined $clone->{var_def}{orig_id};
my $filter = {};
my @@params = split(/,/,$modification);
my ($specifiedIn,$specifiedPos);
$params[0] = $Const::MetricsIdent if $main::MDi->{$params[0]}{type} eq 'metric';
foreach my $i (3..$#params) {
	my @@cntn = split(/\|/,$params[$i]);
	my @@navig = split(/\./,$cntn[0]);
	my $in = ($navig[0] eq 'r') ? 'row' : 'col';
	if (defined $clone->{var_def}{$in}[$navig[1]]) {
		$clone->{var_def}{$in}[$navig[1]] =~ /^(.*?)(~.*)?$/; # creates internal $1
		push(@@{$filter->{$in}{$1}},$cntn[1]) if $cntn[1] ne '*';
		if ($1 eq $params[0]) {
			$specifiedIn = $in ;
			$specifiedPos = $navig[1];
			$params[0] = $clone->{var_def}{$in}[$navig[1]] if $params[1] =~ /pivot/;
a801 1
}
d803 45
a847 40
my $insert = 1;
for (0..$#{$clone->{var_def}{$specifiedIn}}) {
	if ($params[2] eq $clone->{var_def}{$specifiedIn}[$_]) {
		$insert = 0;	#drilled item is already presented
	}
}
if ($params[1] eq 'down' && $insert) {
	if (@@{$clone->{var_def}{$specifiedIn}}[$#{$clone->{var_def}{$specifiedIn}}] eq $Const::MetricsIdent) {
		splice @@{$clone->{var_def}{$specifiedIn}},$#{$clone->{var_def}{$specifiedIn}},0,$params[2];
	} else {
		push @@{$clone->{var_def}{$specifiedIn}},$params[2];
	}
} elsif ($params[1] eq 'up' && $insert) {
	unshift @@{$clone->{var_def}{$specifiedIn}},$params[2] if $insert;
} elsif ($params[1] eq 'self') {
	splice @@{$clone->{var_def}{$specifiedIn}},$specifiedPos,1,$params[2];
} elsif ($params[1] =~ /pivot/) {
	my $target = ($params[1] eq 'pivotX') ? 'col' : 'row'; # source is same as specifiedIn
	my ($targetPos,$targetLength);
	my $eq = int($params[2]) == $params[2] ? 1 : 0;	#replace
	if ($eq) {
		$targetLength = 1;	#replace
		$targetPos = $params[2];
	} else {
		$targetLength = 0;	#add
		$targetPos = $params[2]+0.5;	#0.5 is 'bulgarian constant :-)', but in the fact it match the definition for simple identification of pivot action
	}
#	print "trg: $target, trgpos: $targetPos, trglngth: $targetLength, specin: $specifiedIn, specpos:$specifiedPos\n\n";
	if ($target eq $specifiedIn) {
		if ($targetLength) {
			if ($targetPos == $specifiedPos) {
				if ($params[0] eq $Const::MetricsIdent) {
					#remove selected metric, if more than 2 or exactly 2 metrics presented in definition
					#remove metric indetificator if 1 metric left
					my $index;
					my ($pos,$metric) = split(/\|/,$params[3]);
					for my $i (0..@@{$clone->{var_def}{metric}}) {
						if (${$clone->{var_def}{metric}}[$i] eq $metric) {
							$index = $i;
							last;
d849 2
a850 4
					}
					if (defined $index) {
						splice @@{$clone->{var_def}{metric}},$index,1 if @@{$clone->{var_def}{metric}} > 1;
						splice @@{$clone->{var_def}{$target}},$targetPos,1 if @@{$clone->{var_def}{metric}} == 2;
d853 3
a855 1
					splice @@{$clone->{var_def}{$target}},$targetPos,1;	#remove item within self
d857 1
a857 1
			} else {
d859 2
a860 2
				$targetPos-- if $targetPos > $specifiedPos && $targetPos > 0;
				splice @@{$clone->{var_def}{$target}},$targetPos,1,$params[0];	#replace within self
d862 3
a864 4
		} elsif ($targetPos < $specifiedPos || $targetPos > $specifiedPos+1) {	#insert within self
			splice @@{$clone->{var_def}{$target}},$specifiedPos,1;		#remove old item in same row
			$targetPos-- if $targetPos > $specifiedPos;			#move new item one point down, due to unshift of old item
			splice @@{$clone->{var_def}{$target}},$targetPos,0,$params[0];	#insert new item
d866 1
a866 3
	} else {
		splice @@{$clone->{var_def}{$target}},$targetPos,$targetLength,$params[0];	#insert/replace item (depends on targetLength)
		splice @@{$clone->{var_def}{$specifiedIn}},$specifiedPos,1;			#remove source item
a867 2
	undef $filter;	#do create filter from selection when pivoting
}
d869 7
a875 6
my $filtr;
foreach my $location (keys %{$filter}) {
	my $subFilter;
	foreach my $attr (keys %{$filter->{$location}}) {
		if ($main::MDi->{$attr}{type} eq 'attr') {
			$subFilter .= ($subFilter) ? " OR ([$attr] IN (".join(",",@@{$filter->{$location}{$attr}})."))" : "([$attr] IN (".join(",",@@{$filter->{$location}{$attr}})."))";
d877 1
a878 2
	$filtr = ($filtr) ? "($filtr) AND ($subFilter)" : "$subFilter" if $subFilter;
}
d880 1
a880 1
$clone->{filter_def}{expr} = (defined $clone->{filter_def}{expr}) ? "($clone->{filter_def}{expr}) AND ($filtr)" : "$filtr" if $filtr;
d897 6
a902 6
my $project = $main::MDi->{$id}->{proj};
if (-e "$Const::myPath$Const::MDataDir$project/PrivateMD/$user/Reports/$newId.xml") {
	&setNewMetaInformation($clone->{meta},$user);
} else {
	&setNewMetaInformation($clone->{meta},$user,'all');
}
d904 6
a909 6
my $FullObj = {};
$clone->{modification} = "$params[0],$params[1],$params[2]";
$clone->{name} = &setLocalizedObj($clone->{name},LocalizedObj($clone->{name}, "obj~$1", $lang , $Const::DefaultLanguage)."*",$lang);
$FullObj->{report}{$newId} = $clone;
my $saved = SaveMData($FullObj,1,"$project/PrivateMD/$user/Reports/");
return $saved ? $newId : undef;
d975 13
a987 13
 my $localObj = shift;
 my $stringToSave = shift;
 my $lang = shift;
$stringToSave =~ s/\r//g;
$stringToSave =~ s/\n/\\n/g;

if ($lang) {						#if localized data is to save
	$localObj = undef if (ref($localObj)!~/HASH/);	#prepare/clear object for saving if no other localized datas presented
	$localObj->{$lang} = $stringToSave;
	return $localObj
} else {
	return $stringToSave;
}
@


1.69
log
@foundation for N:M relations
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.68 2004/04/09 07:04:39 michald Exp $
d109 1
a109 1
	foreach my $typ ('group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole','param','pacl') {	# for each object type
d223 7
a229 3
			my ($src,$t,$k) = ($_ =~ m{^(.*?/.*?)/(.*?)/(.*)$});
			push(@@{$main::MDk->{$pName}->{$src}->{$t}->{m}}, $id);
			push(@@{$main::MDl->{$pName}->{$id}}, "$src/$t");
@


1.68
log
@Directed Graph visualization for debugging purposes implemented - need to install GraphViz (look at README)
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.67 2004/04/05 05:43:52 michald Exp $
d56 1
a56 33
			my $hr = $main::MD->{$pn}->{hrelation}->{$hri};
			my $groupFrom = $md->{attr}->{$hr->{from}}->{group} if exists $md->{attr}->{$hr->{from}}->{group};
			my $groupTo = $md->{attr}->{$hr->{to}}->{group} if exists $md->{attr}->{$hr->{to}}->{group};
			my @@roleFrom = keys %{$main::MD->{$pn}->{group}->{$groupFrom}->{role}} if exists $main::MD->{$pn}->{group}->{$groupFrom}->{role};
			my @@roleTo= keys %{$main::MD->{$pn}->{group}->{$groupTo}->{role}} if exists $main::MD->{$pn}->{group}->{$groupTo}->{role};
			if (@@roleFrom && @@roleTo) {
				if ($groupFrom eq $groupTo) {	# both attributes has the same role
					foreach my $r (@@roleFrom) {
						SQLGen::add_tmp_attr_edge($pn, "$hr->{from}.$r", "$hr->{to}.$r");
						SQLGen::add_tmp_attr_edge($pn, "$hr->{to}.$r", "$hr->{from}.$r");
					}
				} else {	# hrelation is connecting attributes with different roles
					foreach my $rf (@@roleFrom) {
						foreach my $rt (@@roleTo) {
							SQLGen::add_tmp_attr_edge($pn, "$hr->{from}.$rf", "$hr->{to}.$rt");
							SQLGen::add_tmp_attr_edge($pn, "$hr->{to}.$rf", "$hr->{from}.$rt");
						}
					}
				}
			} elsif  (@@roleFrom) {	# only From Attr has role defined
				foreach my $r (@@roleFrom) {
					SQLGen::add_tmp_attr_edge($pn, "$hr->{from}.$r", $hr->{to});
					SQLGen::add_tmp_attr_edge($pn, "$hr->{to}.$r", $hr->{from});
				}
			} elsif  (@@roleTo) {	# only To Attr has role defined
				foreach my $r (@@roleFrom) {
					SQLGen::add_tmp_attr_edge($pn, $hr->{from}, "$hr->{to}.$r");
					SQLGen::add_tmp_attr_edge($pn, $hr->{to}, "$hr->{from}.$r");
				}
			} else {	# no roles are presented
				SQLGen::add_tmp_attr_edge($pn, $hr->{from}, $hr->{to});
				SQLGen::add_tmp_attr_edge($pn, $hr->{to}, $hr->{from});
			}
d148 4
a151 2
				$$MD->{$typ}->{$id}->{from} = $nMD->{$typ}->{$id}->{from}->{content};
				$$MD->{$typ}->{$id}->{to} = $nMD->{$typ}->{$id}->{to}->{content};
@


1.67
log
@fix filter rearion bug
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.66 2004/04/02 04:46:05 michald Exp $
d48 1
a48 1
		JoinMetadata(\$main::MD->{$pn}, \$main::MDi, \$main::MDn, $md, undef, $pn);
d53 35
a87 10
			
			# add edge from hrelations
			my ($a, $r) = split('\.', $attr);
			my $to = $main::MD->{$pn}->{hrelation}->{$a};
			next if !$to;	# continue only if hrelation for this attribute exists
			if (!exists $main::MDi->{$to}) {	# $to object is not exits
				my $tor = $to.'.'.$r;
				if (($main::MDi->{$tor}->{type} eq 'attr') && (exists $main::MDi->{$tor})) {
					$to = $tor ;	# add role in case target attribute has one
				} else { next }
a88 1
			SQLGen::add_tmp_attr_edge($pn, $attr, $to);
d90 1
a90 1
		
d123 1
a123 1
		JoinMetadata(\$main::MD->{$pName}, \$main::MDi, \$main::MDn, LoadOneMData($MDataDir.$_.$Const::MDataExt), $MDataDir.$_.$Const::MDataExt, $pName);
a133 1
	my $MDn=shift;	# project specific subtree of metadata name index
d174 1
a174 1
						MD2mem($MD, $MDi, $MDn, $lmd, $path, $pName, $typ, $i);
d177 1
a177 1
					MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $typ, $id);
d179 4
a182 2
#			} elsif ($typ eq 'hrelation') {
#				$$MD->{$typ}->{ $nMD->{$typ}->{$id}->{from}->{content} } = $nMD->{$typ}->{$id}->{to}->{content};
d184 1
a184 1
				MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $typ, $id);
a197 1
	my $MDn=shift;	# project specific subtree of metadata name index
d351 1
a351 1
					'input','output','attr','fact','folder',
d968 1
a968 1
					JoinMetadata(\$main::MD->{$proj}, \$main::MDi, \$main::MDn, LoadOneMData("$path/$dirFile"),"$path/$dirFile", $proj);
@


1.66
log
@fix wrng table nameing in Cache.pm:GetAttrElements
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.65 2004/03/29 06:04:55 michald Exp $
d367 1
a367 1
			WriteLog('Save Metadata Falied',"LE Parser is not loaded",1) if ($Const::LogLevel>0);
d371 7
a377 5
		if ($Bear::lePO->decomposeLE($Obj->{$objT}->{$objI}->{expr})) {
			$Obj->{$objT}->{$objI}->{def} = $Bear::lePO->resultHash();
		} else {
			WriteLog('Save Metadata Falied',"Error in filter expression on line ".$Bear::lePO->error->{LINE}.", char ".$Bear::lePO->error->{POS}.", near \"".$Bear::lePO->error->{STR}."\"",1) if ($Const::LogLevel>0);
			return 0
@


1.65
log
@new lookup cache management
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.64 2004/03/21 07:01:13 michald Exp $
d16 1
@


1.64
log
@slight modification of the Metric Filter Intersection MD presentation
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.63 2004/03/12 16:11:26 michald Exp $
a8 1
use Date::Manip;
d155 2
a156 2
			} elsif ($typ eq 'hrelation') {
				$$MD->{$typ}->{ $nMD->{$typ}->{$id}->{from}->{content} } = $nMD->{$typ}->{$id}->{to}->{content};
d187 1
a187 1
	if ($typ=~/attr|fact|folder|relation/) {	# delete unneded parameters to save some space
d377 1
a377 1
print Dumper($Obj->{$objT}->{$objI}->{filter_def}->{expr});
@


1.63
log
@minor fixes and some comments
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.62 2004/03/11 07:59:00 michald Exp $
d365 15
d392 6
a397 3
	if ($objT =~ /^attr$|^fact$/ ) {
		foreach my $k (keys %{$Obj->{$objT}->{$objI}}) {
			$main::MD->{$projN}->{$objT}->{$objI}->{$k} = $Obj->{$objT}->{$objI}->{$k};
a398 3
	} else {
		$main::MD->{$projN}->{$objT}->{$objI} = $Obj->{$objT}->{$objI};
	}
d410 1
@


1.62
log
@initial implementation of caches in the local DB
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.61 2004/02/27 16:00:03 jiri_schmid Exp $
d33 2
a34 1
	my $MDataDir=shift;
d75 1
d83 1
a83 1
	DBlib::DBConnect($src, $conn->{'src-name'}->{content}, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content}, $conn->{enc}->{content});
d94 4
a97 2
	my $MDataDir=shift;
	my $pName=shift;
d107 1
a179 1
#	$$MD->{$typ}->{$id} = $nMD->{$typ}->{$id};	#store objects
a186 1
##
a195 2
#	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{ptr} = \$$MD->{$typ}->{$id};	#store pointer to object
#	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{id} = $id;	#store object's ID
d239 2
a240 1
sub ObjInvolved {	# returns list of objects on which object $Obj depends directly
d295 1
d303 2
a304 1
sub GetFiles {	# returns list of file names (without extension) with specific extension from specific directory
d319 1
d321 1
a321 1
#	my ($projN)=($mf=~/^([^\/]+)\/.*$/);	#project name
a334 1
#print Dumper($md->{attr}->{okres}) if exists($md->{attr}->{okres});
d341 1
a341 1
	# Save metadata
a376 1
#		delete $main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}};	# delete name index
a387 2
#		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{ptr} = \$main::MD->{$projN}->{$objT}->{$objI};	#store pointer to object
#		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{id} = $objI;	#store object's ID
d406 1
a406 1
	# Drop metadata data
d409 1
d426 15
d897 2
a898 2
my ($hash) = @@_;
return md5_hex(freeze(\%{$hash}))
d903 6
a908 6
my ($obj,$user,$all) = @@_;
my $dateTime = &getTime;
$obj->{creator} = $user if $all;
$obj->{modifier} = $user;
$obj->{modified} = $dateTime;
$obj->{created} = $dateTime if $all;
d913 2
a914 2
my @@time = localtime(time);
return sprintf "%d-%02d-%02d, %02d:%02d:%02d",($time[5] += 1900),($time[4]++),($time[3]++),$time[2],$time[1],$time[0];
d1073 1
a1073 1
my ($rtrn,$ID,$user,$lang,$ignoreReset) = @@_;
d1138 2
a1139 2
my ($id,$rid,$user,$param) = @@_;
if ($param->{share}) {	# values are shared
@


1.61
log
@execution rights tested on all depending objects, not implemented 4 drills yet
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.60 2004/02/25 16:05:07 jiri_schmid Exp $
d562 1
@


1.60
log
@fixed rights logic and folder XML definition files are specific for each project now
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.59 2004/02/24 10:21:48 jiri_schmid Exp $
d1363 2
d1366 10
a1375 7
	($rghts,$all) = &getRights4Object($id,$type,$project,join('',@@rghts));
	push @@roles,$all if $all; #no rights saved within object def. force checking for default rigths
	foreach my $role (@@roles) {
		return 1 if $role eq $root; #skip checking, user is root
		if (exists $rghts->{$role}) {
			foreach (@@rghts) {
				$rights->{$_} = 1 if $rghts->{$role} =~ /$_/; #label found
d1378 11
a1389 6
	$rtrn = 0;
	foreach (@@rghts) {
		$rtrn++ if $rights->{$_}; #count labels
	}
	return 0 if $type eq 'deny' && $rtrn > 0;	#at least one label found when checking deny rights
	$rtrn = $rtrn < @@rghts ? 0 : 1;	#some label wasnt found when checking allow rights
d1391 5
a1395 1
return $all || $rtrn ? $rtrn : &checkOthersAccess2Object($project,$id,@@rghts) #rights 4 other were tested or allowed right found return result else check rights 4 other
a1405 2
#my @@suc = $main::MDgo->{$project}->predecessors($attr); #bject has successors, break deleting

@


1.59
log
@prefer access and rights logic changed
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.58 2004/02/19 13:26:07 jiri_schmid Exp $
d409 1
a409 2
	my $project = $main::MDi->{$ID}->{proj};
	my @@suc = $main::MDgo->{$project}->successors($ID);
d1364 1
a1364 1
	($rghts,$all) = &getRights4Object($id,$type,$project);
d1391 3
d1395 1
a1395 1
	my $rghts = &getOthersRights4Object($id,$type,$project,$_); #at first check deny rights fo right $_
d1424 1
a1424 1
my ($id,$type,$project) = @@_;
d1428 1
a1428 1
} else {
d1430 1
a1430 1
	$rtrn->{"${project}_all"} = exists $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type} ? $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type} : undef; #rights for all
d1432 2
@


1.58
log
@edit page rights fixies and improvments
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.57 2004/02/18 16:19:16 jiri_schmid Exp $
d1318 2
a1319 6
if ($project eq 'TRYNEW') {	#special situtation user may try to set preferences for 1. time
	return 0 if GetUserPref($userID,'Beard'); #if true user has saved preferences and has no access to tab
} else {
	@@roles = &Acl::GetUserRolesFromUsRL($project,$userID);
	return 0 if @@roles < 1;	#user must be asigned at least to 1 role
}
d1364 1
a1364 1
foreach my $type ('deny','allow') {
d1392 1
a1392 1
foreach my $type ('deny','allow') {
d1443 19
@


1.57
log
@rights implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.56 2004/02/16 14:55:22 jiri_schmid Exp $
d1397 1
a1397 1
	my $rghts = &getOthersRights4Object($id,$type,$project);
d1412 2
a1413 2
sub getOthersRights4Object { #return string of rights
my ($id,$type,$project) = @@_;
d1415 3
a1417 2
if (ref $main::MD->{$project}{$objType}{$id}{acl} eq 'HASH') { #check local stored rights for others rights	
	return exists $main::MD->{$project}{$objType}{$id}{acl}{$type}{"${project}_all"} ? $main::MD->{$project}{$objType}{$id}{acl}{$type}{"${project}_all"} : $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type}
d1419 2
a1420 1
	return $main::MD->{$project}{urole}{"${project}_all"}{rights}{$type}
@


1.56
log
@security improvment for tabs
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.55 2004/02/13 17:09:40 jiri_schmid Exp $
d1316 8
a1323 3
my ($userID,$project,$tab) = @@_;
my @@roles = &Acl::GetUserRolesFromUsRL($project,$userID);
return 0 if @@roles < 1;	#user must be asigned at least to 1 role
d1329 1
a1329 1
		$rtrn = 0 if &getRoleTabs($project,$_,$tab) =~ /$tab/;
a1341 1

d1351 1
a1351 1
		$rtrn .= &getRoleTabs($project,$_);
d1358 88
@


1.55
log
@major tabs control implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.54 2004/02/12 16:24:26 jiri_schmid Exp $
d1324 1
a1324 1
		$rtrn = 0 if &getRoleTabs($project,$_) =~ /$tab/;
d1331 1
a1331 1
sub getRoleTabs {	#returns string with forbidden tabs
d1339 1
a1339 1
my ($project,$userID) = @@_;
@


1.54
log
@prototype of tabs hidding implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.53 2004/02/10 14:47:16 jiri_schmid Exp $
d1315 39
@


1.53
log
@mod perl fixies, functionality improvment
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.52 2004/02/09 14:26:41 jiri_schmid Exp $
d1314 1
a1315 2

#-------------------------------
@


1.52
log
@object tree remembers opened directory till webbrowser restarts
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.51 2004/02/05 08:54:01 jiri_schmid Exp $
d409 3
d418 1
a418 1
		return $ID
d421 1
a421 1
		return 0
d1111 1
a1111 1
	push @@{$rtrn->{alt}},LocalizedObj(${$main::MDi->{$name}->{ptr}}->{name}, "obj:$name", $lang , $Const::DefaultLanguage)."~".LocalizedObj(${$main::MDi->{$name}->{ptr}}->{display}{name}{$form}, "form:$form", $lang , $Const::DefaultLanguage);
@


1.51
log
@derivated reports redesigned
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.50 2004/02/02 09:14:07 michald Exp $
d899 1
a899 1
my ($path,$ext,$lang) = @@_;
d905 3
@


1.50
log
@Make independent project specific spaces in MDk, MDl
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.49 2004/01/27 13:35:20 jiri_schmid Exp $
d1268 1
@


1.49
log
@dynamic param fix, description fix
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.48 2004/01/16 11:56:25 jiri_schmid Exp $
d212 1
a212 1
					push(@@{$main::MDk->{$src}->{$t}->{pk}}, $id);
d221 1
a221 1
					push(@@{$main::MDk->{$src}->{$t}->{fk}}, $id);
d229 2
a230 2
			push(@@{$main::MDk->{$src}->{$t}->{m}}, $id);
			push(@@{$main::MDl->{$id}}, "$src/$t");
@


1.48
log
@dp page imrpovment, dp rules code fixies
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.47 2004/01/14 16:09:17 jiri_schmid Exp $
d1181 1
d1185 1
d1200 2
a1201 1
#print Dumper($dynamic);
@


1.47
log
@substitution rules fix
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.46 2004/01/14 15:32:47 jiri_schmid Exp $
d1080 1
a1080 6
						if ($form) {
							$rtrn->{$key}{$id}{alt}{$alt} = LocalizedObj(${$main::MDi->{$name}->{ptr}}->{name}, "obj:$name", $lang , $Const::DefaultLanguage)."~";
							$rtrn->{$key}{$id}{alt}{$alt} .= LocalizedObj(${$main::MDi->{$name}->{ptr}}->{display}{name}{$form}, "form:$form", $lang , $Const::DefaultLanguage);
						} else {
							$rtrn->{$key}{$id}{alt}{$alt} = LocalizedObj(${$main::MDi->{$alt}->{ptr}}->{name}, "obj~$alt", $lang , $Const::DefaultLanguage);
						}
d1086 5
a1090 1
			} elsif ($obj->{type} =~ /^object$|^element$|^common$|^date$/) {#DP is somewhere in filter, metric..
d1092 2
a1093 1
					$rtrn->{$key}{$id}{alt}{$alt} = $alt;
a1097 1
	
d1102 12
d1212 1
a1212 1
		$positions = &getPositions($obj->{var_def},$dpid);
d1217 1
a1217 1
			foreach my $value (@@{$$values}) {
d1260 1
a1260 1
	&setNewMetaInformation($clone->{meta},$user,'all');
@


1.46
log
@DP rules fixies
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.45 2004/01/12 16:31:10 jiri_schmid Exp $
a1195 1
my $positions = &getPositions($obj->{var_def});
d1197 1
a1197 1

d1201 2
a1202 1
		if (exists $positions->{$dpid}) {
d1207 1
a1207 1
				splice @@{$clone->{var_def}{$positions->{$dpid}[1]}},$positions->{$dpid}[0]+$shift,$first,$value;
d1212 1
a1212 1
				splice @@{$clone->{var_def}{$positions->{$dpid}[1]}},$positions->{$dpid}[0],1;
d1217 1
d1219 1
a1219 1
	if (exists $positions->{$Const::MetricsIdent}) { #check existence of metric group
d1221 1
a1221 1
			splice @@{$clone->{var_def}{$positions->{$Const::MetricsIdent}[1]}},$positions->{$Const::MetricsIdent}[0],1;
d1277 2
a1278 2
sub getPositions {
my $def = shift;
d1283 5
a1287 1
		$rtrn->{$def->{$type}[$_]} = [$_,$type];
d1290 1
a1290 1
return $rtrn
@


1.45
log
@dynamic param managing rules implentation started
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.44 2004/01/12 13:50:25 jiri_schmid Exp $
d997 1
a997 1
				$rtrn->{object}{$_}{content} = &getContentType(\$rprt->{var_def}{$key});
d1007 1
a1007 1
				$rtrn->{object}{$_}{content} = &getContentType(\$rprt->{var_def}{$key}{items});
d1029 16
a1044 4
sub getContentType {	#checks function input till finds object type different from dynamic param
my $ptr = shift;
foreach (@@{$$ptr}) {
	return $main::MDi->{$_}{type} if $main::MDi->{$_}{type} ne 'param'
a1045 1
return 'param'
d1051 1
a1051 1
	my $all = 1;
d1053 1
a1053 1
		foreach my $id (keys %{$rtrn->{$key}}) {
d1056 3
a1058 3
			$rtrn->{$key}{$id}{subtype} = $obj->{def}{type} if $obj->{type} =~ /^common$|^date$/;
			$rtrn->{$key}{$id}{min} = ($obj->{def}{min} < 0) ? 0 : $obj->{def}{min};
			$rtrn->{$key}{$id}{max} = ($obj->{def}{min} < $obj->{def}{max}) ? $obj->{def}{max} : ($obj->{def}{min} > 0) ? $obj->{def}{min} : 1;
d1066 1
a1066 1
					undef $all if !$ignoreReset;
d1073 1
a1073 1
				undef $all;
d1075 2
a1076 2
			if ($obj->{type} eq 'object') {
				my $content = delete $rtrn->{$key}{$id}{content};
d1079 7
a1085 5
					$rtrn->{$key}{$id}{type} = 'mismatch' if $content ne $main::MDi->{$name}{type};
					if ($form) {
						my $localized = LocalizedObj(${$main::MDi->{$name}->{ptr}}->{name}, "obj:$name", $lang , $Const::DefaultLanguage)."~";
						$localized .= LocalizedObj(${$main::MDi->{$name}->{ptr}}->{display}{name}{$form}, "form:$form", $lang , $Const::DefaultLanguage);
						$rtrn->{$key}{$id}{alt}{$alt} = $localized;
d1087 2
a1088 1
						$rtrn->{$key}{$id}{alt}{$alt} = LocalizedObj(${$main::MDi->{$alt}->{ptr}}->{name}, "obj~$alt", $lang , $Const::DefaultLanguage);
a1089 1
					
d1091 1
a1091 2
				$rtrn->{$key}{$id}{name} = LocalizedObj(${$main::MDi->{$id}->{ptr}}->{name}, "obj~$id", $lang , $Const::DefaultLanguage) if $rtrn->{$key}{$id}{type} eq 'mismatch';
			} elsif ($obj->{type} =~ /^element$|^common$|^date$/) {
d1099 1
a1099 1
$rtrn->{defined} = $all if (exists $rtrn->{object} || exists $rtrn->{others});
d1197 1
d1199 1
a1216 1

d1241 1
a1241 1
	my $newId = &getUniqueHashString($hash,'RT');
d1255 3
@


1.44
log
@dynamic param fixations
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.43 2004/01/09 12:42:50 jiri_schmid Exp $
a897 1

a931 1

a949 1

d970 1
d997 1
d1006 2
a1007 1
				$rtrn->{object}{$_} = {}
d1029 9
d1065 1
d1067 3
a1069 2
					if ($alt =~ /~/) {
						my ($name,$form) = split(/~/,$alt); #/
d1076 1
d1078 1
a1179 1

@


1.43
log
@dynamic param code imrpovment
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.42 2004/01/09 08:04:49 jiri_schmid Exp $
d957 1
a957 1
	my $rprt = &GetInvolvedReportMetadata($ID);
d959 8
a966 21
	foreach my $key (keys %{$rprt->{var_def}}) {
		next if $key eq 'orig_id';
		if ($rprt->{report_type} eq 'grid') {
			foreach (@@{$rprt->{var_def}{$key}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = {};
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					$rtrn->{object} = {} if ref($rtrn->{object}) ne "HASH";
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		} elsif ($rprt->{report_type} eq 'graph3d') {
			foreach (@@{$rprt->{var_def}{$key}{items}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = {}
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					$rtrn->{object} = {} if ref($rtrn->{object}) ne "HASH";
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		}
d968 12
a979 2

	while ($rprt->{filter_def}{expr} =~ /\[(.*?)\]/g) {
d981 1
a981 1
			$rtrn->{filter}{$1} = {}
d983 2
a984 1
			&paramsInMetric($1,$rtrn->{filter});
d987 2
d990 25
a1014 4
	delete $rtrn->{object}{metrics} if exists $rtrn->{object}; # remove recursive break for analyzing grid and graph3d
	delete $rtrn->{filter}{metrics} if exists $rtrn->{filter}; # remove recursive break for analyzing filter
	delete $rtrn->{object} if keys %{$rtrn->{object}} == 0;
	delete $rtrn->{filter} if keys %{$rtrn->{filter}} == 0;
d1016 15
a1031 1

d1074 1
a1074 8
	$rtrn->{defined} = $all if (exists $rtrn->{object} || exists $rtrn->{filter});

#use Time::HiRes;
#my $stime = Time::HiRes::time();
#print sprintf("Response time: %.5f s\n", Time::HiRes::time()-$stime);

#print Dumper($rtrn);
	return $rtrn
a1141 19

sub paramsInMetric {
	my ($metricId, $definitions) = (shift,shift);
	my $proj = &Bear::GetProjectName(undef,$metricId);
	my $obj = &Bear::GetMetadata(undef,$metricId);	#undef -> do not log call
	$definitions->{metrics}{$metricId} = 1;	#avoid recursive deadlock in metrics
	while ($obj->{metric}{$metricId}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$definitions->{$1} = {};
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			next if exists $definitions->{metrics}{$1};
			&paramsInMetric($1,$definitions);
		}
	}
return 1
}

#----------------------------------

d1147 1
a1147 1
	foreach my $type ('filter','object') {
d1161 2
d1233 1
a1233 1
my $sameChange = ($newId eq $id) ? 1 : 0; #dynamic params are not inlucded in definition
@


1.42
log
@dynamic params fixation a code clearing
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.41 2004/01/07 16:27:05 jiri_schmid Exp $
d1081 2
a1082 2
		$param->{view} = $param->{prop} eq 'reset' ? 1 : $view;	#is viewed when not enough params defined
		return $new
d1134 2
a1135 1
my ($user,$rprtid,$dynamic) = @@_;
d1140 2
a1141 1
			if ($dynamic->{$type}{$dpid}{view}) {
d1151 1
a1151 1
$dynamic->{defined} = $rtrn;
@


1.41
log
@added icons and improved controling dynamic params
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.40 2004/01/07 12:01:59 jiri_schmid Exp $
d955 1
a955 1
	my $rtrn;
@


1.40
log
@dynamic param implementation - next step
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.39 2004/01/06 08:17:37 jiri_schmid Exp $
d436 1
a436 1
	open($fh,">${Path}${User}.xml") || print "failed:$Path.$User\n";
d446 1
a446 1
		WriteLog('Save Preferences Falied',$User.'.xml',1) if ($Const::LogLevel>0);
d1044 2
a1148 1

@


1.39
log
@dynamic params implemented into grid
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.38 2003/12/18 15:14:41 jiri_schmid Exp $
d847 3
a849 2
	foreach ('row','col','page','metric') {
		$hash->{object}{$_} = $clone->{var_def}{$_};
d954 1
a954 1
	my ($ID,$lang,$user) = @@_;
d964 1
a964 1
					$rtrn->{object}{$_} = {}
d966 1
d975 1
d992 3
a994 1

d1009 6
a1014 1
				$rtrn->{$key}{$id}{view} = $rtrn->{$key}{$id}{prop} eq 'lock' ? 10 : $rtrn->{$key}{$id}{prop} eq 'reset' ? 5 : 0; #default params should be viewed every time
a1040 1

a1043 2
#print Dumper($rtrn);

d1050 1
a1050 4
if ($param->{prop} eq 'reset') {	# values should be set every time
	return undef
} elsif ($param->{prop} =~ /^default$|^lock$/) {	# use previously setted values
	if ($param->{share}) {	# values are shared
a1066 3
} else {
	return undef
}
d1126 1
d1159 1
d1171 1
a1171 1
			if ($dynamics->{object}{$dpid}{min} == 0 && @@{$dynamics->{object}{$dpid}{values}} < 1) {
d1178 12
d1193 3
a1195 2
	foreach ('row','col','page','metric') {
		$hash->{object}{$_} = $clone->{var_def}{$_};
d1213 1
a1213 1
$clone->{name} = &setLocalizedObj($clone->{name},LocalizedObj($clone->{name}, "obj", $lang , $Const::DefaultLanguage)."*",$lang);
d1215 1
a1215 1
my $saved = SaveMData($FullObj,1,"$project/PrivateMD/$user/Reports/");
d1219 2
a1220 1
$rtrn->{dynamics} = $dynamics;
d1222 7
a1228 1
$rtrn->{paramsDefined} = 1;
@


1.38
log
@visual improvment
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.37 2003/12/18 12:59:54 jiri_schmid Exp $
a749 2
#use Data::Dumper;
#print Dumper(@@params);
a756 1
		print "$params[2] vs. $clone->{var_def}{$in}[$navig[1]]\n";
d1004 1
a1004 1
				$rtrn->{$key}{$id}{view} = $rtrn->{$key}{$id}{prop} eq 'lock' ? 10 : $rtrn->{$key}{$id}{prop} eq 'default' ? 1 : 0; #default params should be viewed every time
d1073 1
a1073 1
$view = $new ? 0 : 1;
d1078 2
a1079 2
		$param->{view} = $view;	#is viewed when not enough params defined
		return $new;
d1082 2
a1083 2
		$param->{view} = $view;
		return $new;
d1093 1
a1093 1
			return $new;
d1098 1
a1098 1
			return 1;
d1102 1
a1102 1
			return $new;
d1136 3
a1138 3
				if (!&setParam($dpid,$rprtid,$user,$dynamic->{$type}{$dpid})) {
					undef $rtrn
				}
d1152 74
@


1.37
log
@defining of dynamic params within use rules implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.36 2003/12/16 15:49:24 jiri_schmid Exp $
a997 1
			$rtrn->{$key}{$id}{name} = LocalizedObj($obj->{name}, "obj~$id", $lang, $Const::DefaultLanguage);
d1006 2
a1007 2
			if (&checkParam($id,$ID,$user,$rtrn->{$key}{$id})) {
				$rtrn->{$key}{$id}{view} = $rtrn->{$key}{$id}{prop} eq 'lock' ? 10 : 0;
d1081 1
a1081 1
		$param->{view} = $view;
@


1.36
log
@first stage of reseting params implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.35 2003/12/16 13:44:24 jiri_schmid Exp $
a997 5
			if (exists $main::UserPref->{$user}{$ID} && defined $main::UserPref->{$user}{$ID}{$id}) {
				$rtrn->{$key}{$id}{values} = $main::UserPref->{$user}{$ID}{$id};
			} else {
				undef $all
			}
d1002 1
a1002 1
			$rtrn->{$key}{$id}{max} = ($obj->{def}{min} < $obj->{def}{max}) ? $obj->{def}{max} : $obj->{def}{min};
d1005 9
d1045 70
d1134 1
a1134 1
my ($user,$rprtid,$values) = @@_;
d1137 6
a1142 6
	foreach my $dpid (keys %{$values}) {	#dynamic param id
		if (defined $values->{$dpid}) {
			$main::UserPref->{$user}{$rprtid}{$dpid} = $values->{$dpid};
		} else {
			if (!defined $main::UserPref->{$user}{$rprtid}{$dpid}) {
				undef $rtrn
d1149 3
a1151 1
return $rtrn
@


1.35
log
@setting and checking values of params agains memory
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.34 2003/12/15 15:16:03 jiri_schmid Exp $
d998 5
a1024 3
			}
			if (!exists $main::UserPref->{$user}{$ID} || !defined $main::UserPref->{$user}{$ID}{$id}) {
				undef $all;
@


1.34
log
@interface for setting of dynamic params implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.33 2003/12/12 16:48:12 jiri_schmid Exp $
a748 1
my $insert = 1;
d759 1
d765 7
a771 3
		if ($params[2] eq $clone->{var_def}{$in}[$navig[1]]) {
			$insert = 0;	#drilled item is already presented
		}
d956 1
a956 1
	my ($ID,$lang) = @@_;
d993 2
d1001 2
a1002 2
			$rtrn->{$key}{$id}{max} = $obj->{def}{max};
			$rtrn->{$key}{$id}{min} = $obj->{def}{min};
d1021 3
d1026 2
d1056 22
@


1.33
log
@continuing in implementation of dynamic params
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.32 2003/12/12 13:34:09 jiri_schmid Exp $
d749 1
d765 3
d770 1
a770 1
if ($params[1] eq 'down') {
d776 2
a777 2
} elsif ($params[1] eq 'up') {
	unshift @@{$clone->{var_def}{$specifiedIn}},$params[2];
d994 1
d1010 4
d1022 1
@


1.32
log
@forgotten one right curly bracket :-(
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.31 2003/12/12 13:31:12 jiri_schmid Exp $
a952 3
	$rtrn->{object} = {};
	$rtrn->{filter} = {};

d958 1
a958 1
					$rtrn->{object}{$_} = 1
d966 1
a966 1
					$rtrn->{object}{$_} = 1
d976 1
a976 1
			$rtrn->{filter}{$1} = 1
d982 27
a1008 2
	delete $rtrn->{object}{metrics}; # remove recursive break for analyzing grid and graph3d
	delete $rtrn->{filter}{metrics}; # remove recursive break for analyzing filter
d1026 1
a1026 1
			$definitions->{$1} = 1
@


1.31
log
@deprecated empty hash content when trasnporting over SOAP 0.60 may be fixed
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.30 2003/12/12 12:12:16 jiri_schmid Exp $
d473 1
d503 3
a505 3
				if (exists $md->{Beard}->{report}) {
					foreach (keys(%{$main::UserPref->{$User}->{$Project}->{report}})) {
						$main::UserPref->{$User}->{$Project}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object ~$_", lc($main::UserPref->{$User}->{$Project}->{language}), $Const::DefaultLanguage);
@


1.30
log
@found a fixed bug manipulating dynamic params in grid
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.29 2003/12/11 16:20:07 jiri_schmid Exp $
d469 4
a472 3
		foreach (keys(%{$md->{Beard}->{report}})) {
			$md->{Beard}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object ~$_", $lang, $Const::DefaultLanguage);
		}
a474 1

d502 4
a505 2
				foreach (keys(%{$main::UserPref->{$User}->{$Project}->{report}})) {
					$main::UserPref->{$User}->{$Project}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object ~$_", lc($main::UserPref->{$User}->{$Project}->{language}), $Const::DefaultLanguage);
@


1.29
log
@last pivot rule implenmeted, removing modified reports enhanced
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.28 2003/12/10 15:54:31 jiri_schmid Exp $
d694 1
a694 1
	my ($ID,$class) = @@_;
a733 2
	WriteLog('Involved Report Definition Metadata Request',"GetInvolvedReportMetadata($ID)",4) if (($main::LogLevel>3)&&($class));	#don't log if called localy
	
d940 67
@


1.28
log
@code and functionality improvments for pivoting and modified reports page
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.27 2003/12/10 10:24:48 jiri_schmid Exp $
a792 1
					splice @@{$clone->{var_def}{$target}},$targetPos,1 if @@{$clone->{var_def}{metric}} == 2; 
d801 4
a804 1
					splice @@{$clone->{var_def}{metric}},$index,1 if @@{$clone->{var_def}{metric}} > 1;
@


1.27
log
@drill fix
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.26 2003/12/10 09:31:28 jiri_schmid Exp $
d741 1
a741 1
my ($id,$user,$modification) = (shift,shift,shift);
d744 1
d749 2
d790 16
a805 1
				splice @@{$clone->{var_def}{$target}},$targetPos,1 if $main::MDi->{$params[0]}{type} ne 'metric' ;	#remove item within self
d858 2
d891 1
a891 1
my ($path,$ext) = @@_;
d894 1
d896 21
a916 3
			if ($dirFile =~ s/\.$ext$//) {
				my @@time = localtime( (stat "$path/$dirFile.xml")[9] );
				$rtrn->{$dirFile}{date} = sprintf "%d-%02d-%02d, %02d:%02d:%02d",($time[5] += 1900),($time[4]++),($time[3]++),$time[2],$time[1],$time[0];
d924 19
@


1.26
log
@minor code improvments
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.25 2003/12/09 15:58:27 jiri_schmid Exp $
d753 1
a753 1
		$clone->{var_def}{$in}[$navig[1]] =~ /^(.*?)~.*$/; # creates internal $1
@


1.25
log
@drill on all items implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.24 2003/12/09 10:43:47 jiri_schmid Exp $
d753 3
a755 3
		(my $itemId = $clone->{var_def}{$in}[$navig[1]]) =~ s/^(.*?)~.*$/$1/;
		push(@@{$filter->{$in}{$itemId}},$cntn[1]) if $cntn[1] ne '*';
		if ($itemId eq $params[0]) {
@


1.24
log
@brackets for OR definition in generated filter added
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.23 2003/12/08 15:46:35 jiri_schmid Exp $
d810 1
a810 1
			$subFilter .= ($subFilter) ? " OR [$attr] IN (".join(",",@@{$filter->{$location}{$attr}}).")" : "[$attr] IN (".join(",",@@{$filter->{$location}{$attr}}).")";
d816 1
a816 1
$clone->{filter_def}{expr} = (defined $clone->{filter_def}{expr}) ? "($clone->{filter_def}{expr}) AND ($filtr)" : "($filtr)" if $filtr;
@


1.23
log
@drill up-down with all from header implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.22 2003/12/08 14:58:37 jiri_schmid Exp $
d816 1
a816 1
$clone->{filter_def}{expr} = (defined $clone->{filter_def}{expr}) ? "($clone->{filter_def}{expr}) AND ($filtr)" : $filtr if $filtr;
@


1.22
log
@reading of privatemd implemented, derivated reports are no longer in tree generated
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.21 2003/12/04 14:04:34 jiri_schmid Exp $
d754 1
a754 1
		push(@@{$filter->{$in}{$itemId}},$cntn[1]);
@


1.21
log
@modificated reports filterinng contians variations within element (OR) and joins between elements themselve (AND)
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.20 2003/12/04 10:44:36 jiri_schmid Exp $
d841 1
a841 1
my $saved = SaveMData($FullObj,0,"$project/PrivateMD/$user/Reports/");
d848 1
a848 1
my ($hash,$hashSalt) = @@_;
d866 16
@


1.20
log
@visaul changes and improvments
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.19 2003/12/03 12:03:09 jiri_schmid Exp $
d754 1
a754 1
		push(@@{$filter->{$itemId}},$cntn[1]);
d804 1
d806 6
a811 3
foreach my $attr (keys %{$filter}) {
	if ($main::MDi->{$attr}{type} eq 'attr') {
		$filtr .= ($filtr) ? " AND [$attr] IN (".join(",",@@{$filter->{$attr}}).")" : "[$attr] IN (".join(",",@@{$filter->{$attr}}).")";
d813 1
d815 1
@


1.19
log
@fixed generating header in grid, minor visual improvments
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.18 2003/12/02 16:22:52 jiri_schmid Exp $
a803 1
&setNewMetaInformation($clone->{meta},$user,'all');
d828 1
a828 1
	return $newId
d830 1
a830 4
	my $FullObj = {};
	$FullObj->{report}{$newId} = $clone;
	my $saved = SaveMData($FullObj,0,"$project/PrivateMD/$user/Reports/");
	return $newId if $saved;
d832 6
a837 1
return undef
@


1.18
log
@fixed some generating bugs when creating HTML output
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.17 2003/12/01 15:14:09 jiri_schmid Exp $
d808 1
a808 5
		my @@elements = ();
		foreach (@@{$filter->{$attr}}) {
			push @@elements,$_;
		}
		$filtr .= ($filtr) ? " AND [$attr] IN (".join(",",@@elements).")" : "[$attr] IN (".join(",",@@elements).")";
@


1.17
log
@metrics stands last in definition, when last defined
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.16 2003/12/01 15:00:27 jiri_schmid Exp $
d722 1
a722 1
	#handle filter
d783 1
a783 1
	print "trg: $target, trgpos: $targetPos, trglngth: $targetLength, specin: $specifiedIn, specpos:$specifiedPos\n\n";
d817 13
a829 11
#---------- create hash string from modification -----------
my $hash = {};
$hash->{filter} = $clone->{filter_def}{expr};
foreach ('row','col','page','metric') {
	$hash->{object}{$_} = $clone->{var_def}{$_};
}
foreach ('form','type','header') {
	$hash->{format}{$_} = $clone->{format_def}{$_};
}
my $newId = &getUniqueHashString($hash,'RT');
#-----------------------------------------------------------
@


1.16
log
@removing grid item when pivoting on its self
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.15 2003/12/01 12:30:32 jiri_schmid Exp $
d763 5
a767 1
	push @@{$clone->{var_def}{$specifiedIn}},$params[2];
@


1.15
log
@pivoting attr with form fixed
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.14 2003/12/01 12:20:43 jiri_schmid Exp $
a768 1
	print Dumper(@@params);
d781 8
a788 4
		if ($targetLength && $targetPos != $specifiedPos) {
			splice @@{$clone->{var_def}{$target}},$specifiedPos,1;		#remove old item in same row
			$targetPos-- if $targetPos > $specifiedPos && $targetPos > 0;
			splice @@{$clone->{var_def}{$target}},$targetPos,1,$params[0];	#replace within self
@


1.14
log
@pivoting implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.13 2003/11/28 17:31:49 jiri_schmid Exp $
d758 1
@


1.13
log
@self drill implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.12 2003/11/28 16:56:06 jiri_schmid Exp $
d16 1
d747 1
d767 28
d807 1
a807 1
$clone->{filter_def}{expr} = (defined $clone->{filter_def}{expr}) ? "($clone->{filter_def}{expr}) AND ($filtr)" : $filtr;
@


1.12
log
@drill up and down fixed
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.11 2003/11/28 14:49:49 jiri_schmid Exp $
d745 1
a745 1
my $specifiedIn;
d753 4
a756 1
		$specifiedIn = $in if $itemId eq $params[0];
d763 2
@


1.11
log
@fixed right click menu bug
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.10 2003/11/28 13:03:22 jiri_schmid Exp $
d756 5
a760 1
push @@{$clone->{var_def}{$specifiedIn}},$params[2];
@


1.10
log
@MD5 hashing implemented, sorting menus implemented etc...
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.9 2003/11/28 07:06:08 michald Exp $
d646 8
a661 1

@


1.9
log
@report/metric filter join
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.8 2003/11/27 16:41:09 jiri_schmid Exp $
d14 2
a15 1
use Storable qw(dclone);	#needed for creating independent copy of hash
a420 9
#-----------------------------------------------------

sub ModifyReport {
	# modify report metadata and save it as new report, returns new report ID
	my $ID=shift;	#object ID to modify
	my $newMD=shift;	#new metadata
	return if (!$ID);
}

d675 1
a675 1
			push @@forms,$form,LocalizedObj(${$main::MDi->{$link}->{ptr}}->{display}{$form}{name}, "obj~$form", $lang , $Const::DefaultLanguage);
d751 1
a751 1
my $filtr = $clone->{filter_def}{expr};
d761 13
a773 1
$clone->{filter_def}{expr} = $filtr;
d776 10
a785 4
my $newId = IDGen();
my $FullObj = {};
$FullObj->{report}{$newId} = $clone;
my $saved = SaveMData($FullObj,1,"$project/PrivateMD/$user/Reports/");
d787 4
a790 1
return $newId
d792 1
@


1.8
log
@something like drill implemeted
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.7 2003/11/27 08:52:44 jiri_schmid Exp $
d418 9
@


1.7
log
@1.step for drilling implemented
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.6 2003/11/26 05:36:27 michald Exp $
d14 1
a14 2
use Storable;	#needed for creating independent copy of hash
#use Const;
d649 3
a651 10
sub GetLocalizedAttrDrillDown {
my ($attr,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my @@links = $main::MDga->{$project}->successors($attr);
my $rtrn;
foreach (@@links) {
	next if $attr eq $_;
	$rtrn->{$_} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj~$_", $lang , $Const::DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
}
return $rtrn
d653 1
d656 2
a657 2
sub GetLocalizedAttrDrillUp {
my ($attr,$lang) = @@_;
d659 8
a666 1
my @@links = $main::MDga->{$project}->predecessors($attr);
d668 10
a677 3
foreach (@@links) {
	next if $attr eq $_;
	$rtrn->{$_} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj~$_", $lang , $Const::DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
a685 1

d687 1
a687 1
	my $rtrn = &Storable::dclone($obj->{report}{$ID});
d731 4
a734 5
sub ModifyReport {
my ($id,$modification) = @@_;
my $project = $main::MDi->{$id}->{proj};
my $obj = Bear::GetMetadata(undef,$id);
my $clone = &Storable::dclone($obj->{report}{$id});
a747 1
#print Dumper(@@params);
d749 12
a760 2
#print Dumper($clone);
#print Dumper($filter);
d762 5
a766 1
#$id = Bear::NewId();
d768 10
a777 1
return $id
d781 4
d786 1
a786 1

d790 1
@


1.6
log
@cleadnup of some obsolete files
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.5 2003/11/25 10:07:13 michald Exp $
d14 1
d469 1
a469 1
			$md->{Beard}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", $lang, $Const::DefaultLanguage);
d502 1
a502 1
					$main::UserPref->{$User}->{$Project}->{report}->{$_}->{name} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", lc($main::UserPref->{$User}->{$Project}->{language}), $Const::DefaultLanguage);
d645 1
a645 1
$rtrn->{$attr} = LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{name}, "obj#$attr", $lang , $Const::DefaultLanguage);
d657 1
a657 1
	$rtrn->{$_} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj#$_", $lang , $Const::DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
d670 1
a670 1
	$rtrn->{$_} = LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj#$_", $lang , $Const::DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
d674 81
@


1.5
log
@Project ACL implementation
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.4 2003/11/20 08:17:34 michald Exp $
d12 1
a12 1
use DBlib;	# should be invoked on this place to ensure BEGIN procedure will be called after initialization of const.def in beard.pl
@


1.4
log
@fix of LDM, cleanup of some obsolete files
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.3 2003/11/11 15:06:15 jiri_schmid Exp $
d111 1
a111 1
	foreach my $typ ('group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole','param','acl') {	# for each object type
@


1.3
log
@closing Dumping tuning informations
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.2 2003/11/11 14:03:19 jiri_schmid Exp $
d111 1
a111 1
	foreach my $typ ('group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole','param') {	# for each object type
@


1.2
log
@creating report - minor bugs fixed, seems to be working properly
@
text
@d4 1
a4 1
# $Id: Bearlib.pm,v 1.1 2003/11/10 18:51:59 michald Exp $
d21 6
a26 6
#if ($Const::LogFile) {
#	open(STDOUT, '>>', $Const::LogFile) || die "Can't redirect stdout";
#	open(STDERR, ">&STDOUT")     || die "Can't dup stdout";
#	select(STDERR); $| = 1;     # make unbuffered
#	select(STDOUT); $| = 1;     # make unbuffered
#}
@


1.1
log
@.pl to .pm transition
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.117 2003/11/07 16:51:05 jiri_schmid Exp $
d14 1
d21 6
a26 6
if ($Const::LogFile) {
	open(STDOUT, '>>', $Const::LogFile) || die "Can't redirect stdout";
	open(STDERR, ">&STDOUT")     || die "Can't dup stdout";
	select(STDERR); $| = 1;     # make unbuffered
	select(STDOUT); $| = 1;     # make unbuffered
}
d328 1
a328 1
print Dumper($md->{attr}->{okres}) if exists($md->{attr}->{okres});
@

