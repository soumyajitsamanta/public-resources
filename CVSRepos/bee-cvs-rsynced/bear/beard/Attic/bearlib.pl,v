head	1.118;
access;
symbols;
locks; strict;
comment	@# @;


1.118
date	2003.11.20.08.17.34;	author michald;	state dead;
branches;
next	1.117;

1.117
date	2003.11.07.16.51.05;	author jiri_schmid;	state Exp;
branches;
next	1.116;

1.116
date	2003.11.07.07.36.43;	author michald;	state Exp;
branches;
next	1.115;

1.115
date	2003.11.06.09.19.46;	author spanhel;	state Exp;
branches;
next	1.114;

1.114
date	2003.11.06.08.43.26;	author michald;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.05.16.04.06;	author jiri_schmid;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.05.15.47.52;	author jiri_schmid;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.05.10.44.57;	author jiri_schmid;	state Exp;
branches;
next	1.110;

1.110
date	2003.11.04.15.19.00;	author jiri_schmid;	state Exp;
branches;
next	1.109;

1.109
date	2003.11.04.07.52.49;	author spanhel;	state Exp;
branches;
next	1.108;

1.108
date	2003.10.31.13.06.25;	author jiri_schmid;	state Exp;
branches;
next	1.107;

1.107
date	2003.10.16.14.08.53;	author jiri_schmid;	state Exp;
branches;
next	1.106;

1.106
date	2003.10.01.15.29.38;	author jiri_schmid;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.29.05.43.19;	author michald;	state Exp;
branches;
next	1.104;

1.104
date	2003.09.23.13.06.57;	author jiri_schmid;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.10.09.08.58;	author jiri_schmid;	state Exp;
branches;
next	1.102;

1.102
date	2003.09.09.09.41.30;	author jiri_schmid;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.03.15.10.46;	author jiri_schmid;	state Exp;
branches;
next	1.100;

1.100
date	2003.08.26.15.35.45;	author jiri_schmid;	state Exp;
branches;
next	1.99;

1.99
date	2003.08.25.15.09.20;	author jiri_schmid;	state Exp;
branches;
next	1.98;

1.98
date	2003.08.20.14.23.45;	author jiri_schmid;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.19.13.05.57;	author jiri_schmid;	state Exp;
branches;
next	1.96;

1.96
date	2003.08.18.13.17.13;	author jiri_schmid;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.18.05.50.55;	author michald;	state Exp;
branches;
next	1.94;

1.94
date	2003.08.15.10.59.39;	author michald;	state Exp;
branches;
next	1.93;

1.93
date	2003.08.04.05.12.23;	author michald;	state Exp;
branches;
next	1.92;

1.92
date	2003.08.01.13.07.14;	author jiri_schmid;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.29.06.52.46;	author michald;	state Exp;
branches;
next	1.90;

1.90
date	2003.07.23.11.44.56;	author jiri_schmid;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.23.08.08.54;	author jiri_schmid;	state Exp;
branches;
next	1.88;

1.88
date	2003.07.22.08.48.01;	author jiri_schmid;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.18.10.51.01;	author jiri_schmid;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.17.03.04.21;	author michald;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.11.16.00.52;	author jiri_schmid;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.11.05.40.58;	author michald;	state Exp;
branches;
next	1.83;

1.83
date	2003.07.09.15.30.18;	author jiri_schmid;	state Exp;
branches;
next	1.82;

1.82
date	2003.07.07.14.17.14;	author jiri_schmid;	state Exp;
branches;
next	1.81;

1.81
date	2003.07.04.14.29.33;	author jiri_schmid;	state Exp;
branches;
next	1.80;

1.80
date	2003.07.04.06.19.19;	author michald;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.25.15.40.29;	author jiri_schmid;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.25.09.14.47;	author jiri_schmid;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.24.15.17.43;	author jiri_schmid;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.23.08.31.13;	author jiri_schmid;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.21.16.13.10;	author michald;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.20.16.21.23;	author jiri_schmid;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.20.08.42.32;	author michald;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.13.15.35.24;	author jiri_schmid;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.13.11.33.00;	author jiri_schmid;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.12.08.44.34;	author jiri_schmid;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.04.07.50.56;	author jiri_schmid;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.03.08.16.07;	author jiri_schmid;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.02.14.47.53;	author jiri_schmid;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.02.12.09.11;	author jiri_schmid;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.02.09.33.18;	author jiri_schmid;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.02.07.35.13;	author jiri_schmid;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.30.12.43.13;	author jiri_schmid;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.30.12.39.40;	author jiri_schmid;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.30.09.22.41;	author jiri_schmid;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.30.09.13.31;	author jiri_schmid;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.28.15.33.34;	author michald;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.28.15.18.46;	author jiri_schmid;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.28.12.56.23;	author jiri_schmid;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.28.10.40.23;	author jiri_schmid;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.28.08.55.28;	author jiri_schmid;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.28.07.34.21;	author jiri_schmid;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.27.12.18.12;	author michald;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.26.15.01.40;	author jiri_schmid;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.23.06.40.49;	author michald;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.22.09.17.38;	author michald;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.21.10.38.21;	author michald;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.21.07.47.24;	author michald;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.14.14.28.21;	author jiri_schmid;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.08.07.42.46;	author michald;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.07.08.21.59;	author jiri_schmid;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.06.20.48.38;	author michald;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.06.15.36.06;	author jiri_schmid;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.06.15.06.12;	author jiri_schmid;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.06.09.21.01;	author jiri_schmid;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.05.06.41.47;	author michald;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.01.15.40.30;	author jiri_schmid;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.01.12.17.23;	author michald;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.30.09.53.40;	author jiri_schmid;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.16.12.17.19;	author jiri_schmid;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.16.11.18.12;	author jiri_schmid;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.14.08.39.03;	author jiri_schmid;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.11.15.25.24;	author jiri_schmid;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.10.14.19.16;	author jiri_schmid;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.08.07.32.07;	author michald;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.07.13.28.31;	author michald;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.04.09.33.49;	author jiri_schmid;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.26.09.38.19;	author jiri_schmid;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.24.12.17.54;	author jiri_schmid;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.20.16.39.45;	author michald;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.14.09.23.52;	author jiri_schmid;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.06.14.49.04;	author jiri_schmid;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.06.08.49.36;	author jiri_schmid;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.04.16.32.14;	author jiri_schmid;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.03.16.44.03;	author jiri_schmid;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.24.15.37.32;	author jiri_schmid;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.24.15.31.21;	author jiri_schmid;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.14.09.56.51;	author michald;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.05.18.31.05;	author michald;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.30.06.36.23;	author michald;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.26.14.16.29;	author michald;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.20.18.33.57;	author michald;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.18.12.23.08;	author michald;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.03.11.22.05;	author michald;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.26.08.08.32;	author michald;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.22.12.01.41;	author michald;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.21.16.27.21;	author spanhel;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.12.18.18.44;	author michald;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.12.12.04.01;	author michald;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.11.10.36.04;	author michald;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.22.15.11.15;	author michald;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.05.17.32.03;	author michald;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.02.16.53.05;	author michald;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.02.11.14.05;	author michald;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.30.10.04.46;	author michald;	state Exp;
branches;
next	;


desc
@@


1.118
log
@fix of LDM, cleanup of some obsolete files
@
text
@#-----------------------------------------------------
#  Common Library for the Bear Daemon
#-----------------------------------------------------
# $Id: bearlib.pl,v 1.117 2003/11/07 16:51:05 jiri_schmid Exp $

use strict;
use Date::Manip;
use XML::Simple;
use Data::Dumper;
use DBlib;	# should be invoked on this place to ensure BEGIN procedure will be called after initialization of const.def in beard.pl
use FileHandle;

use utf8;
binmode(STDOUT, ':utf8');
binmode(STDIN, ':utf8');

use vars qw($MDataExt $MetricsIdent $LogFile $DefaultLanguage);	# vars from const.def

# Log File Initialization
if ($LogFile) {
	open(STDOUT, '>>', $LogFile) || die "Can't redirect stdout";
	open(STDERR, ">&STDOUT")     || die "Can't dup stdout";
	select(STDERR); $| = 1;     # make unbuffered
	select(STDOUT); $| = 1;     # make unbuffered
}

#------------------Load Metadata Section---------------------

sub LoadMData {
	my $MDataDir=shift;
	
	foreach my $pn (GetFiles($MDataDir,$MDataExt)) {	# for each Project Name
		my $md=LoadOneMData($MDataDir.$pn.$MDataExt);
		SQLGen::GraphPNInit($pn);	# init temporary Directed Graph, MDga graph will be initiated as result of APSP_Floyd_Warshall function
		$main::MDgo->{$pn} = new Graph::Directed;	# init Directed Graph of objects dependencies
		
		foreach my $h (keys %{$md->{host}}) {	# for each host name
			foreach (keys %{$md->{host}->{$h}->{source}}) {
				OpenDBConnection($md->{host}, $h, $_);	# open connection for each host/source				
				SQLGen::GraphTempInit("$h/$_");	# init temporary Directed Graph, MDg graph will be initiated as result of APSP_Floyd_Warshall function
			}
		}
		
		JoinMetadata(\$main::MD->{$pn}, \$main::MDi, \$main::MDn, $md, undef, $pn);
		LoadMDataRecur($MDataDir.$pn."/", $pn) if (-d $MDataDir.$pn);  # each project metadata has corresponding directory as well

		foreach my $attr (keys %{$main::MD->{$pn}->{attr}}) {	# for each attribute ID
			SQLGen::MD2graph($pn, $attr);
			
			# add edge from hrelations
			my ($a, $r) = split('\.', $attr);
			my $to = $main::MD->{$pn}->{hrelation}->{$a};
			next if !$to;	# continue only if hrelation for this attribute exists
			if (!exists $main::MDi->{$to}) {	# $to object is not existent
				my $tor = $to.'.'.$r;
				if (($main::MDi->{$tor}->{type} eq 'attr') && (exists $main::MDi->{$tor})) {
					$to = $tor ;	# add role in case target attribute has one
				} else { next }
			}
			SQLGen::add_tmp_attr_edge($pn, $attr, $to);
		}
		
		SQLGen::GenAPSP($pn);	# make All-pairs Shortest Paths

	}
}

#---------------------------------------

sub OpenDBConnection {
	my $md=shift;	#metadata
	my $h=shift;	#host
	my $s=shift;	#source

	my $src = "$h/$s";
	my $conn = $md->{$h}->{source}->{$s}->{'src-conn'};
	return if ($conn->{driver} ne 'dbi:MySQL');
	DBlib::DBConnect($src, $conn->{'src-name'}->{content}, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content}, $conn->{enc}->{content});
	if (@@DBlib::SQLErrors) {
		WriteLog('DB Connection Falied', $src, 1) if ($LogLevel>0);
	} else {
		WriteLog('Open DB Connection', "$conn->{'src-name'}->{content}:$conn->{user}->{content} as $src", 3) if ($LogLevel>2);
	}
}

#---------------------------------------

sub LoadMDataRecur {
	my $MDataDir=shift;
	my $pName=shift;
	foreach (GetFiles($MDataDir,$MDataExt)) {
		JoinMetadata(\$main::MD->{$pName}, \$main::MDi, \$main::MDn, LoadOneMData($MDataDir.$_.$MDataExt), $MDataDir.$_.$MDataExt, $pName);
		LoadMDataRecur($MDataDir.$_."/",$pName) if (-d $MDataDir.$_);  # folder's metadata has corresponding directory as well
	}
}

#---------------------------------------

sub JoinMetadata {
	my $MD=shift;	# project specific subtree of metadata
	my $MDi=shift;	# project specific subtree of metadata index
	my $MDn=shift;	# project specific subtree of metadata name index
	my $nMD=shift;	# new metadata
	my $path=shift;	# physical path to metadata in filesystem
	my $pName=shift;	# project name

	$path=~s/^$MDataDir// if ($path);	# cut $MDataDir from beginning of the path


	foreach my $typ ('group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole','param') {	# for each object type
		next if (!exists $nMD->{$typ});

		foreach my $id (keys %{$nMD->{$typ}}) {	# foreach object ID

			if ($typ eq 'attr') {
				if (exists $nMD->{group} && ref($nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}) eq 'HASH') {	# attribute has multiple roles
					foreach my $r (keys %{$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}}) {	# make copy for each role of attribute
						my $lmd = {};	# temp. hash to store role copy
						my $i = "$id.$r";	# id of attr.role

						if (ref($nMD->{$typ}->{$id}->{fk}) eq 'ARRAY') {
							foreach (@@{$nMD->{$typ}->{$id}->{fk}}) {
								push @@{$lmd->{$typ}->{$i}->{fk}}, $_
							}
						}
						if (ref($nMD->{$typ}->{$id}->{role}->{$r}->{fk}) eq 'ARRAY') {
							foreach (@@{$nMD->{$typ}->{$id}->{role}->{$r}->{fk}}) {
								push @@{$lmd->{$typ}->{$i}->{fk}}, $_
							}
						}

						if (ref($nMD->{$typ}->{$id}->{name}) eq 'HASH') {		# if name contains localisation
							foreach (keys %{$nMD->{$typ}->{$id}->{name}}) {	# roles have to be localised as well
								$lmd->{$typ}->{$i}->{name}->{$_} = $nMD->{$typ}->{$id}->{name}->{$_}.' ('.$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}->{$r}->{name}->{$_}.')';
							}
						} else {
							$lmd->{$typ}->{$i}->{name} = $nMD->{$typ}->{$id}->{name}.' :'.$nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}->{$r}->{name};
						}
						foreach ('link','group','pk','display') {
							$lmd->{$typ}->{$i}->{$_} = $nMD->{$typ}->{$id}->{$_} if exists $nMD->{$typ}->{$id}->{$_};
						}

						MD2mem($MD, $MDi, $MDn, $lmd, $path, $pName, $typ, $i);
					}
				} else {	# attribute has no roles
					MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $typ, $id);
				}
			} elsif ($typ eq 'hrelation') {
				$$MD->{$typ}->{ $nMD->{$typ}->{$id}->{from}->{content} } = $nMD->{$typ}->{$id}->{to}->{content};
			} else {	# diffrent object type as attribute
				MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $typ, $id);
			}

			foreach (ObjInvolved($id, $typ, $nMD->{$typ}->{$id})) {	# for each object involved in object $id definition, has to run after seting of MDi by MD2mem
				$main::MDgo->{$pName}->add_edge($_, $id);	# add edge representing dependency of objects
			}
		}
	}
}

sub MD2mem {
# add new metadata into memory hashes
	my $MD=shift;	# project specific subtree of metadata
	my $MDi=shift;	# project specific subtree of metadata index
	my $MDn=shift;	# project specific subtree of metadata name index
	my $nMD=shift;	# new metadata
	my $path=shift;	# physical path to metadata in filesystem
	my $pName=shift;	# project name
	my $typ=shift;	# object type
	my $id=shift;	# object ID

#	$$MD->{$typ}->{$id} = $nMD->{$typ}->{$id};	#store objects
	if (exists $$MD->{$typ}->{$id}) {
		foreach my $k (keys %{$nMD->{$typ}->{$id}}) {
			$$MD->{$typ}->{$id}->{$k} = $nMD->{$typ}->{$id}->{$k};
		}
	} else {
		$$MD->{$typ}->{$id} = $nMD->{$typ}->{$id};
	}
##
	
	if ($typ=~/attr|fact|folder|relation/) {	# delete unneded parameters to save some space
		delete($$MD->{$typ}->{$id}->{'gui-presentation'}) if ($$MD->{$typ}->{$id}->{'gui-presentation'});
		delete($$MD->{$typ}->{$id}->{'directory'}) if ($$MD->{$typ}->{$id}->{'directory'});
	}
	$$MDi->{$id}->{ptr} = \$$MD->{$typ}->{$id};	#store pointer to object
	$$MDi->{$id}->{type} = $typ;	#store object type
	$$MDi->{$id}->{path} = $path;	#store object disk location
	$$MDi->{$id}->{proj} = $pName;	#store project name
#	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{ptr} = \$$MD->{$typ}->{$id};	#store pointer to object
#	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{id} = $id;	#store object's ID

	if ($typ eq 'urole') {
		foreach (@@{$$MD->{$typ}->{$id}->{uuser}}) {
			Acl::AddUserRoleToUsRL($pName, $id, $_);
		}
		foreach (@@{$$MD->{$typ}->{$id}->{ugroup}}) {
			foreach (@@{$Acl::Grp->{$_}{members}}) {
				Acl::AddUserRoleToUsRL($pName, $id, $_);
			}
		}
	}
	if ($typ eq 'attr') {	# set attributes into MDk
		if (exists $nMD->{$typ}->{$id}->{pk}) {
			foreach my $pk (@@{$nMD->{$typ}->{$id}->{pk}}) {
				if (defined $pk) {
					#my ($src,$t,$k) = ($pk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
					my ($src,$t,$k) = ($pk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
					push(@@{$main::MDk->{$src}->{$t}->{pk}}, $id);
				}
			}
		}
		if (exists $nMD->{$typ}->{$id}->{fk}) {
			foreach my $fk (@@{$nMD->{$typ}->{$id}->{fk}}) {
				if (defined $fk) {
					#my ($src,$t,$k) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
					my ($src,$t,$k) = ($fk =~ m{^(.*?/.*?)/(.*?)/(.*)$});
					push(@@{$main::MDk->{$src}->{$t}->{fk}}, $id);
				}
			}
		}
	}
	if (($typ eq 'fact')&&(ref($nMD->{$typ}->{$id}->{expr}) eq 'ARRAY')) {	# set facts into MDk
		foreach (@@{$nMD->{$typ}->{$id}->{expr}}) {
			my ($src,$t,$k) = ($_ =~ m{^(.*?/.*?)/(.*?)/(.*)$});
			push(@@{$main::MDk->{$src}->{$t}->{m}}, $id);
			push(@@{$main::MDl->{$id}}, "$src/$t");
		}
	}
	
}

#---------------------------------------

sub ObjInvolved {	# returns list of objects on which object $Obj depends directly
	my $id = shift;
	my $typ = shift;
	my $Obj = shift;

	my %h;
	if ($typ eq 'grid') {
		foreach (@@{$Obj->{row}}, @@{$Obj->{col}}, @@{$Obj->{page}}) {
			my $r = $_;	#have to make copy to avoid change of original metadata
			next if ($r eq $MetricsIdent);
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
		if ($Obj->{metric}) {
			foreach (@@{$Obj->{metric}}) {
				my $r = $_;	#have to make copy to avoid change of original metadata
				$r =~ s/~.*$//;	# cut display form
		 		$h{$r}++ if $r;
			}
		}
	} elsif ($typ eq 'filter') {
		foreach (getObjectsFromExpr($Obj->{expr})) {
			my $r = $_;	#have to make copy to avoid change of original metadata
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
	} elsif ($typ eq 'metric') {
		foreach (getObjectsFromExpr($Obj->{expr})) {
			my $r = $_;
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
		foreach my $r (@@{$Obj->{aggr_def}}) {	#aggr_def is an array
			$r =~ s/~.*$//;	# cut display form
		 	$h{$r}++ if $r;
		}
	 	$h{$Obj->{filter_def}}++ if $Obj->{filter_def};
	} elsif ($typ eq 'report') {
		foreach my $o ('format_def', 'var_def', 'filter_def') {
			if (ref($Obj->{$o}) eq 'HASH') {	# object is stored localy
				my $t = {'var_def'=>$Obj->{report_type}, 'filter_def'=>'filter'};	# mapping between type key and locally stored object type
				next if !exists $t->{$o};
				foreach (ObjInvolved($id, $t->{$o}, $Obj->{$o})) {
				 	$h{$_}++;
				}
			} else {	# def contains ID of global object
				my $r = $Obj->{$o};
			 	$h{$r}++ if $r;
			}
		}
	}
	return keys %h;
}

sub getObjectsFromExpr {
	my $s = shift;
	return if !$s;
	return ($s=~/\[(.+?)\]/g);
}

#---------------------------------------

sub GetFiles {	# returns list of file names (without extension) with specific extension from specific directory
	my ($td, $fExt)=@@_;	# directory, file ext
	my @@fList=();

	if (opendir(DIR, $td) ) {
		@@fList = grep { /^\w.*$fExt$/ && -f "$td/$_" } readdir(DIR);
		closedir DIR;
	}
	foreach (@@fList) { s/$fExt$// };
	return sort @@fList
}

#---------------------------------------

sub LoadOneMData {
	my $mdf=shift;	# metadata filename
#	my ($projN)=($mf=~/^([^\/]+)\/.*$/);	#project name
	my $PData = new XML::Simple(rootname=>'project',KeyAttr=>['id','layer'],
					SuppressEmpty=>undef,
					forcearray=>['host','source','table','column',
					'view','connection','relation','signal','const','triger','gui-layer',
					'gui-presentation','transformation','constraint',
					'input','output','attr','fact','folder',
					'metric','filter','format','grid','graph3d','format3d','format2d','row','col','page',
					'report','fk','pk','aggr_def','items','rules','urole','uuser','ugroup','param',
					'dates','commons','elements','objects','display','expr']);

	my $md = $PData->XMLin($mdf);

	WriteLog('Load Metadata',"Load from $mdf",4) if ($LogLevel>3);
	return $md
}    

#------------------End of Load Metadata Section---------------------

sub SaveMData {
	# Save metadata
	my $Obj=shift;	#object to save
	my $Rewrit=shift;	#force rewrite
	my $Path=shift;	#path (under $MDataDir, started with project name) where object will be saved

	my $objT=(keys %{$Obj})[0];	# object type
	my $objI=(keys %{$Obj->{$objT}})[0];	#object ID
	my $fn;	# path and filename to save

	my $projN;	# project name
	if ($Path) {
		($projN)=($Path=~/^([^\/]+)\/.*$/);	# project name
		$fn = ($objI) ? $objI : IDGen();	# set filename appropiate to object ID or to generic ID in case ID is missing
		$fn=$Path.$fn.'.xml';
	} else {
		$projN = $main::MDi->{$objI}->{proj};
		$fn = $main::MDi->{$objI}->{path};
	}
	
	if ((-f $MDataDir.$fn)&&(!$Rewrit)) {
		WriteLog('Unsuccessful Rewrite',"Attempt to involuntary rewrite $fn without",3) if ($LogLevel>3);
		return -1	# file exists and $Rewrit flag was not set
	}


	my $PData = new XML::Simple(keyattr=>['id'], rootname=>'project');
	
	my $fh = new FileHandle;
	open($fh,">${MDataDir}$fn") || print "failed:$MDataDir$fn\n";
	binmode($fh,":utf8");
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$fh, xmldecl=>'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
	close($fh);

	if ($out) {	# file save succeed, let save into memory and create indexes
		WriteLog('Save Metadata',"$fn",4) if ($LogLevel>3);

#		delete $main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}};	# delete name index
	if ($objT =~ /^attr$|^fact$/ ) {
		foreach my $k (keys %{$Obj->{$objT}->{$objI}}) {
			$main::MD->{$projN}->{$objT}->{$objI}->{$k} = $Obj->{$objT}->{$objI}->{$k};
		}
	} else {
		$main::MD->{$projN}->{$objT}->{$objI} = $Obj->{$objT}->{$objI};
	}
		$main::MDi->{$objI}->{ptr} = \$main::MD->{$projN}->{$objT}->{$objI};	#store pointer to object
		$main::MDi->{$objI}->{type} = $objT;	#store object type
		$main::MDi->{$objI}->{path} = $fn;	#store object disk location
		$main::MDi->{$objI}->{proj} = $projN;	#store project name
#		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{ptr} = \$main::MD->{$projN}->{$objT}->{$objI};	#store pointer to object
#		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{id} = $objI;	#store object's ID

		foreach ($main::MDgo->{$projN}->predecessors($objI)) {	# for each predecessor of object $objI
			$main::MDgo->{$projN}->delete_edge($_, $objI);	# remove edge
		}
		foreach (ObjInvolved($objI, $objT, $Obj->{$objT}->{$objI})) {	# for each object involved in object $id definition
			$main::MDgo->{$projN}->add_edge($_, $objI);	# add edge representing dependency of objects
		}

		return $fn
	} else {	# file save failed 
		WriteLog('Save Metadata Falied',"$fn",1) if ($LogLevel>0);
		return 0
	}
}

#-----------------------------------------------------

sub DropMData {
	# Drop metadata data
	my $Proj=shift;	#project
	my $ID=shift;	#object ID to drop
	return if (!$ID);
	if (unlink($MDataDir.$main::MDi->{$ID}->{path})) {
		my $type=$main::MDi->{$ID}->{type};
		delete $main::MD->{$Proj}->{$type}->{$ID};
		delete $main::MDi->{$ID};
		$main::MDgo->{$Proj}->delete_vertex($ID);
		WriteLog('Drop Metadata',"Proj:$Proj, ID:$ID",4) if ($LogLevel>3);
		return $ID
	} else {
		WriteLog('Drop Metadata Falied',"$ID",1) if ($LogLevel>0);
		return 0
	}
}

#--------------------Users and User Preferences Section-----------------------

sub SaveUserPref {
# save User Preferences Object, if succeeds then set $UserPref->{$User} cache and returns 1
	my $Obj=shift;	#object to save
	my $User=shift; #user name
	my $Path=shift;	#path (under $MDataDir, started with project name) where object will be saved

	if ($Path) {$Path = $MDataDir.$Path} 
	else {$Path = $MDataDir.'Prefer/'};
	
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'preferences');

	my $fh = new FileHandle;
	open($fh,">${Path}${User}.xml") || print "failed:$Path.$User\n";
	binmode($fh,":utf8");
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$fh, xmldecl=>'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
	close($fh);
	
	if ($out) {	# file save succeed 
		WriteLog('Save Preferences',$User.'.xml',4) if ($LogLevel>3);
		$main::UserPref->{$User} = $Obj;
		return 1
	} else { 	# file save failed 
		WriteLog('Save Preferences Falied',$User.'.xml',1) if ($LogLevel>0);
		return undef
	}

}
#---------------------------------------

sub LoadUserPref {
	my $User=shift;
	my $Path=shift;	# path to metadata file

	if (!$Path) {$Path = 'Prefer/'};
	my $fn = $MDataDir.$Path.$User.'.xml';	 # preferences file

	my $md;
	
	if (-e $fn) {
		my $PData = new XML::Simple(keyattr=>'id', rootname=>'preferences', forcearray=>['report']);
		$md = $PData->XMLin($fn);
	};

	if ($md) {
		my $lang = lc($md->{Beard}->{language});
		foreach (keys(%{$md->{Beard}->{report}})) {
			$md->{Beard}->{report}->{$_}->{name} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", $lang, $DefaultLanguage);
		}
		WriteLog('Load Preferences', $fn, 4) if ($LogLevel>3);
		$main::UserPref->{$User} = $md;

		return $md
	} else {
		WriteLog('Load Preferences Falied', $fn, 1) if ($LogLevel>0);
		return undef
	}
}

#---------------------------------------

sub GetUserPref {
	my $User=shift;
	my $Project=shift;
	my $Item=shift;
	my $umd; #user meta data
	my $load;

	if ($User && $Project) {
		WriteLog('Get User Preferences', "$User/$Project/$Item", 4) if ($LogLevel>3);
		if ($Item) {
			if ($main::UserPref->{$User}->{$Project}->{$Item}) {
				return $main::UserPref->{$User}->{$Project}->{$Item}
			} else {
				$umd = LoadUserPref($User,undef); #force reading user pref from disk
				return $umd->{$Project}->{$Item}
			};
		} else {
			if ($main::UserPref->{$User}->{$Project}) {
				foreach (keys(%{$main::UserPref->{$User}->{$Project}->{report}})) {
					$main::UserPref->{$User}->{$Project}->{report}->{$_}->{name} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", lc($main::UserPref->{$User}->{$Project}->{language}), $DefaultLanguage);
				}
				return $main::UserPref->{$User}->{$Project}
			} else {
				$umd = LoadUserPref($User,undef); #force reading user pref from disk
				return $umd->{$Project}
			}
		}
	} else  {
		return undef
	};
}
#------------------End of User Preferences Section---------------------

sub LocalizedObj {		# returns localized description
						# $descr = LocalizedObj($descrObj, "NA", 'cz', 'en', ...);

	my $descr=shift;	# description with possible locale
	my $alter=shift;	# alternate description for case specific locale is not defined
	my @@lang=@@_;		# locale(s)
	
	if ($descr) {
		if (ref($descr)=~/HASH/) {
			foreach (@@lang) {
				if (exists ($descr->{$_})) {
					if (ref($descr->{$_})=~/HASH/) {	# empty string is presented as empty hash
						return ''
					} else {
						return $descr->{$_}
					}
				}
			}
		} else {
			return $descr
		}
	}
	return $alter

}

#-----------------------------------------------------

# Log Levels
# 0 ... nothing
# 1 ... Error & Start/Stop
# 2 ... Warning
# 3 ... Info
# 4 ... Trace

sub WriteLog {
	my($Header,$Txt,$Level) = @@_;
	$Header = '' if !$Header;
	$Txt = '' if !$Txt;
	$Level = 0 if !$Level;
	print &UnixDate('today','%Y-%m-%d %T')."\t".$Level."\t".$Header."\t".$Txt."\n";
}

#---------------------------------------

my $IDGen=0;
my $IDSt;
my $IDa='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';	# lenght 52 B
my $IDb=$IDa.'0123456789';	# lenght 62 B

sub IDGen {	# singular ID generator
# returns singular string (starting with letter) contains:
#   3 chars are representing sequence of ID (with period 199888)
#   4 chars are representing time (with period 171 days)
#   3 chars are representing PID (max PID should be 62**3)
	if (!$IDGen) {
		$IDSt = '';
		my $t=time%62**4;	# we are using only part of time information to save string space; resulting 171 days period seems enough to ensure ID singularity
		foreach (62**3, 62**2, 62) {	# we are setting 4 chars string depending on time
			$IDSt .= substr($IDb, int($t/$_), 1);
			$t = $t%$_;
		}
		$IDSt .= substr($IDb, $t, 1);
		$t=$$%62**3;
		foreach (62**2, 62) {	# we are setting 3 chars string depending on PID
			$IDSt .= substr($IDb, int($t/$_), 1);
			$t = $t%$_;
		}
		$IDSt .= substr($IDb, $t, 1);
	}
	if ($IDGen==199888) {$IDGen=0} else {$IDGen++};	# 199888=52*62*62; we are returning about 100000 IDs/s on P4/1.6 GHz into empty loop, so such 3 chars string seems enough to keep sequence

	my $i1 = int($IDGen/3844);	# 3844=62*62
	my $i2 = $IDGen%3844;
	return substr($IDa, $i1, 1).substr($IDb, int($i2/62), 1).substr($IDb, $i2%62, 1).$IDSt;	# we are converting $IDGen to 3 char string in space 'aaa','aab',...,'zzz'; returning string is starting with this string to ensure ID is not starting with number

}

#---------------------------------------

sub GetLocalizedRolesList {
my $use_lang = lc( shift );
my $project = shift;
my @@rtrn;
	foreach (keys %{$main::MD->{$project}{urole}}) { push(@@rtrn,LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$use_lang,'en'));}
	return @@rtrn

}

#---------------------------------------

sub GetAllLocalizedRights {
my $lang = lc( shift );
my $project = shift;
my $rtrn;
foreach (keys %{$main::MD->{$project}{urole}}) {
	$rtrn->{$_}{name} = &main::LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
	$rtrn->{$_}{desc} = &main::LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetAllLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
	$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
}

return $rtrn
}

#---------------------------------------

sub GetLocalizedRights {
my $lang = lc( shift );
my $project = shift;
my @@ids = @@_;
my $rtrn;
foreach (@@ids) {
	$rtrn->{$_}{name} = &main::LocalizedObj($::MD->{$project}{urole}{$_}{name},"? $_",$lang,'en');
	$rtrn->{$_}{desc} = &main::LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
	$rtrn->{$_}{rights} = $::MD->{$project}{urole}{$_}{rights};
}

return $rtrn
}

#---------------------------------------
sub GetLocalizedAttrLinks {
my ($attr,$form,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my $links = $main::MD->{$project}{attr}{$attr}{link} if exists $main::MD->{$project}{attr}{$attr}{link};
my $rtrn;
foreach (keys %{$links}) {
	$rtrn->{$_} = &main::LocalizedObj($links->{$_}{$form},"? $_",$lang,'en');
}
$rtrn->{$attr} = main::LocalizedObj(${$main::MDi->{$attr}->{ptr}}->{name}, "obj#$attr", $lang , $DefaultLanguage);
return $rtrn
}

#---------------------------------------
sub GetLocalizedAttrDrillDown {
my ($attr,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my @@links = $main::MDga->{$project}->successors($attr);
my $rtrn;
foreach (@@links) {
	next if $attr eq $_;
	$rtrn->{$_} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj#$_", $lang , $DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
}
return $rtrn
}

#---------------------------------------
sub GetLocalizedAttrDrillUp {
my ($attr,$lang) = @@_;
my $project = $main::MDi->{$attr}->{proj};
my @@links = $main::MDga->{$project}->predecessors($attr);
my $rtrn;
foreach (@@links) {
	next if $attr eq $_;
	$rtrn->{$_} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "obj#$_", $lang , $DefaultLanguage) if $main::MDi->{$_}->{type} eq 'attr';
}
return $rtrn
}

1

__END__
@


1.117
log
@tuning
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.116 2003/11/07 07:36:43 michald Exp $
@


1.116
log
@fix for not numeric fact ID
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.115 2003/11/06 09:19:46 spanhel Exp $
d116 1
a116 1
				if (ref($nMD->{group}->{$nMD->{$typ}->{$id}->{group}}->{role}) eq 'HASH') {	# attribute has multiple roles
@


1.115
log
@XML Simple - display
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.114 2003/11/06 08:43:26 michald Exp $
a224 2
			#my ($src,$t,$k);
			#($src,$t,$k) = /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/;
d322 2
a323 2
					'dates','commons','elements','objects', 'display',]);
	
@


1.114
log
@small change to log output
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.113 2003/11/05 16:04:06 jiri_schmid Exp $
d112 1
a112 1
#print Dumper($nMD->{$typ});
d324 1
a324 2
					'dates','commons','elements','objects','display']);

@


1.113
log
@XMLIN - froce array for display keys re-added
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.112 2003/11/05 15:47:52 jiri_schmid Exp $
d112 1
a112 1
# 		print Dumper($nMD->{$typ});
@


1.112
log
@minor javascript improvments and fixies
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.111 2003/11/05 10:44:57 jiri_schmid Exp $
d324 1
a324 1
					'dates','commons','elements','objects']); #,'display']); # !!! myson goes out of memory when display active !!!
@


1.111
log
@pointers everywhere, reapply of removed fix
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.110 2003/11/04 15:19:00 jiri_schmid Exp $
d324 2
a325 2
#					'display', # !!! myson goes out of memory when uncommented !!!
					'dates','commons','elements','objects']);
@


1.110
log
@save as - modperl fixies, code improvments
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.109 2003/11/04 07:52:49 spanhel Exp $
d112 1
a112 1
 		print Dumper($nMD->{$typ});
d324 1
@


1.109
log
@display form of attributes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.108 2003/10/31 13:06:25 jiri_schmid Exp $
d324 1
a324 1
					'dates','commons','elements','objects','display',]);
@


1.108
log
@xmlin() configuration changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.107 2003/10/16 14:08:53 jiri_schmid Exp $
d112 1
d324 1
a324 1
					'dates','commons','elements','objects',]);
@


1.107
log
@mod-perl implementation stage 1, rebuilding global vars in .pl to global pointers
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.106 2003/10/01 15:29:38 jiri_schmid Exp $
d322 2
a323 1
					'report','fk','pk','aggr_def','items','rules','urole','uuser','ugroup','param']);
@


1.106
log
@prompt implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.105 2003/09/29 05:43:19 michald Exp $
d315 1
a315 1
	my $PData = new XML::Simple(rootname=>'project',keyattr=>['id','layer'],
a356 1
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'project');
d358 2
@


1.105
log
@new version of the metadata - multiple attribute PK implementation; improvement of the PrepareSQL
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.104 2003/09/23 13:06:57 jiri_schmid Exp $
d110 1
a110 1
	foreach my $typ ('group','attr','fact','hrelation','folder','metric','filter','format','grid','report','role','graph3d','format3d','format2d','urole') {	# for each object type
d322 1
a322 1
					'report','fk','pk','aggr_def','items','rules','urole','uuser','ugroup']);
@


1.104
log
@bee demo changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.103 2003/09/10 09:08:58 jiri_schmid Exp $
d559 2
a560 2
my $IDa='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';	# lenght 52
my $IDb=$IDa.'0123456789';	# lenght 62
@


1.103
log
@ACl changes, report outup visual improvments
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.102 2003/09/09 09:41:30 jiri_schmid Exp $
d109 14
a122 10
	foreach my $typ (keys %{$nMD}) {	# for each object type
		if ($typ=~/^attr$|^fact$|^hrelation$|^folder$|^metric$|^filter$|^format$|^grid$|^report$|^group$|^role$|^graph3d$|^format3d$|^format2d$|^urole$/) {
			foreach my $id (keys %{$nMD->{$typ}}) {	# foreach object ID
			
				if ($typ eq 'attr') {
					if ($nMD->{$typ}->{$id}->{role}) {	# attribute has multiple roles
						foreach my $r (keys %{$nMD->{$typ}->{$id}->{role}}) {	# make copy for each role of attribute
							if (!exists $nMD->{role}->{$r}) {
								main::WriteLog("Nonexistend role '$r' ocurred","ID=$id",1) if ($main::LogLevel>0);
								next
d124 4
a127 7
							my $lmd = {};
							my $i = "$id.$r";	# id of attr.role
							
							if (ref($nMD->{$typ}->{$id}->{fk}) eq 'ARRAY') {
								foreach (@@{$nMD->{$typ}->{$id}->{fk}}) {
									push @@{$lmd->{$typ}->{$i}->{fk}}, $_
								}
d129 5
a133 4
							if (ref($nMD->{$typ}->{$id}->{role}->{$r}->{fk}) eq 'ARRAY') {
								foreach (@@{$nMD->{$typ}->{$id}->{role}->{$r}->{fk}}) {
									push @@{$lmd->{$typ}->{$i}->{fk}}, $_
								}
d135 5
a139 13
							
							if (ref($nMD->{$typ}->{$id}->{name}) eq 'HASH') {		# if name contains localisation
								foreach (keys %{$nMD->{$typ}->{$id}->{name}}) {	# roles have to be localised as well
									$lmd->{$typ}->{$i}->{name}->{$_} = $nMD->{$typ}->{$id}->{name}->{$_}.' ('.$nMD->{role}->{$r}->{name}->{$_}.')';
								}
							} else {
								$lmd->{$typ}->{$i}->{name} = $nMD->{$typ}->{$id}->{name}.' :'.$nMD->{role}->{$r}->{name};
							}
							foreach ('link','group','pk','display') {
								$lmd->{$typ}->{$i}->{$_} = $nMD->{$typ}->{$id}->{$_} if exists $nMD->{$typ}->{$id}->{$_};
							}
							
							MD2mem($MD, $MDi, $MDn, $lmd, $path, $pName, $typ, $i);
d141 2
a142 2
					} else {	# attribute has no roles
						MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $typ, $id);
d144 1
a144 3
				} elsif ($typ eq 'hrelation') {
					$$MD->{$typ}->{ $nMD->{$typ}->{$id}->{from}->{content} } = $nMD->{$typ}->{$id}->{to}->{content};
				} else {	# diffrent object type as attribute
d147 8
a154 4
				
				foreach (ObjInvolved($id, $typ, $nMD->{$typ}->{$id})) {	# for each object involved in object $id definition, has to run after seting of MDi by MD2mem
					$main::MDgo->{$pName}->add_edge($_, $id);	# add edge representing dependency of objects
				}
d204 7
a210 2
			my ($src,$t,$k) = ($nMD->{$typ}->{$id}->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
			push(@@{$main::MDk->{$src}->{$t}->{pk}}, $id);
d214 5
a218 2
				my ($src,$t,$k) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
				push(@@{$main::MDk->{$src}->{$t}->{fk}}, $id);
d224 3
a226 2
			my ($src,$t,$k);
			($src,$t,$k) = /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/;
@


1.102
log
@ACL for facts and attrs implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.101 2003/09/03 15:10:46 jiri_schmid Exp $
d635 27
@


1.101
log
@implementation of right clik menu
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.100 2003/08/26 15:35:45 jiri_schmid Exp $
d175 10
a184 1
	$$MD->{$typ}->{$id} = $nMD->{$typ}->{$id};	#store objects
d364 5
d370 1
@


1.100
log
@rights improvment, create delete duplicate rule implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.99 2003/08/25 15:09:20 jiri_schmid Exp $
d609 12
@


1.99
log
@object acl, owner, modifier, datetime creation and modification implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.98 2003/08/20 14:23:45 jiri_schmid Exp $
d583 1
a583 1
sub GetLocalizedRights {
d589 1
a589 1
	$rtrn->{$_}{desc} = &main::LocalizedObj($::MD->{$project}{urole}{$_}{description},"GetLocalizedRights? $_",$lang,'en') if $::MD->{$project}{urole}{$_}{description};
d597 14
@


1.98
log
@access object implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.97 2003/08/19 13:05:57 jiri_schmid Exp $
d572 2
a573 1
sub GetRolesList {
a574 1
my $use_lang = lc( shift );
d579 15
@


1.97
log
@formats2d implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.96 2003/08/18 13:17:13 jiri_schmid Exp $
d346 1
a346 1
	open($fh,">${MDataDir}$fn") || print "failed:$MDataDir.$fn\n";
d567 11
@


1.96
log
@admin page reading rutines implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.95 2003/08/18 05:50:55 michald Exp $
d110 1
a110 1
		if ($typ=~/^attr$|^fact$|^hrelation$|^folder$|^metric$|^filter$|^format$|^grid$|^report$|^group$|^role$|^graph3d$|^format3d$|^urole$/) {
d307 1
a307 1
					'metric','filter','format','grid','graph3d','format3d','row','col','page',
@


1.95
log
@some ACL improvement
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.94 2003/08/15 10:59:39 michald Exp $
d192 1
a192 1
			foreach (@@{$Acl::Grp->{$_}}) {
@


1.94
log
@initial ACL implementation
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.93 2003/08/04 05:12:23 michald Exp $
d189 1
a189 1
			Acl::AddRoleToUser($pName, $id, $_);
d193 1
a193 1
				Acl::AddRoleToUser($pName, $id, $_);
a344 2
	#print Dumper($Obj);

d539 2
d542 25
a566 6
sub IDGen {	# unique ID generator
	if (!$IDGen) { 
		($IDSt=sprintf('%04x', time))=~s/.*(\w{4})$/$1/;	# lower 4char hexa presentation of current time
		$IDSt.=sprintf('%04x', $$);							# PID
	}
	if ($IDGen==255) {$IDGen=0} else {$IDGen++};
d568 1
a568 1
	return $IDSt.sprintf('%02x',$IDGen);
d570 1
a570 1
}
@


1.93
log
@Plug-Ins implementation
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.92 2003/08/01 13:07:14 jiri_schmid Exp $
d110 1
a110 1
		if ($typ=~/attr|fact|hrelation|folder|metric|filter|format|grid|report|group|role|graph3d|format3d/) {
d184 2
a185 2
	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{ptr} = \$$MD->{$typ}->{$id};	#store pointer to object
	$$MDn->{$$MD->{$typ}->{$id}->{name}}->{id} = $id;	#store object's ID
d187 10
d308 1
a308 1
					'report','fk','pk','aggr_def','items','rules']);
d356 1
a356 1
		delete $main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}};	# delete name index
d362 2
a363 2
		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{ptr} = \$main::MD->{$projN}->{$objT}->{$objI};	#store pointer to object
		$main::MDn->{$main::MD->{$projN}->{$objT}->{$objI}->{name}}->{id} = $objI;	#store object's ID
d399 1
a399 1
#--------------------User Preferences Section-----------------------
@


1.92
log
@graph3d relevant changes made to cooperate with right pane, multiple metric not alowed yet
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.91 2003/07/29 06:52:46 michald Exp $
d521 3
@


1.91
log
@Cache::GetAttrElements implementation
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.90 2003/07/23 11:44:56 jiri_schmid Exp $
d298 1
a298 1
					'report','fk','pk','aggr_def','items','intervals','sizes']);
@


1.90
log
@next tab implemented on graph3d page
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.89 2003/07/23 08:08:54 jiri_schmid Exp $
d54 6
a59 2
			my $tor = $to.'.'.$r;
			$to = $tor if ($main::MDi->{$tor}->{type} eq 'attr');	# add role in case target attribute has one
d274 1
a274 1
sub GetFiles {
a281 1
	@@fList = sort @@fList;
d283 1
a283 1
	return @@fList
@


1.89
log
@some XML::Simple-In reconfiguration
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.88 2003/07/22 08:48:01 jiri_schmid Exp $
d295 1
a295 1
					'report','fk','pk','aggr_def','items','intervals']);
@


1.88
log
@axis tabs on 3dgraph page implented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.87 2003/07/18 10:51:01 jiri_schmid Exp $
d289 1
@


1.87
log
@format3d implemented, format changed all dependencies fixed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.86 2003/07/17 03:04:21 michald Exp $
d294 1
a294 1
					'report','fk','pk','aggr_def','items']);
@


1.86
log
@fix of ObjInvolved func
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.85 2003/07/11 16:00:52 jiri_schmid Exp $
d106 1
a106 1
		if ($typ=~/attr|fact|hrelation|folder|metric|filter|format|grid|report|group|role|graph3d/) {
d246 1
a246 1
		foreach my $o ('format_def', 'grid_def', 'filter_def') {
d248 1
a248 1
				my $t = {'grid_def'=>'grid', 'filter_def'=>'filter'};	# mapping between type key and locally stored object type
d293 1
a293 1
					'metric','filter','format','grid','graph3d','row','col','page',
@


1.85
log
@graph3d next stage
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.84 2003/07/11 05:40:58 michald Exp $
d240 2
a241 3
		foreach my $o ('aggr_def', 'filter_def') {	#aggr_def is array now !!!
			my $r = $Obj->{$o};
			#$r =~ s/~.*$//;	# cut display form ? !!!
d244 1
d454 9
a462 4
if ($User && $Project) {
	if ($Item) {
		if ($main::UserPref->{$User}->{$Project}->{$Item}) {
			return $main::UserPref->{$User}->{$Project}->{$Item}
d464 8
a471 7
			$umd = LoadUserPref($User,undef); #force reading user pref from disk
			return $umd->{$Project}->{$Item}
		};
	} else {
		if ($main::UserPref->{$User}->{$Project}) {
			foreach (keys(%{$main::UserPref->{$User}->{$Project}->{report}})) {
			$main::UserPref->{$User}->{$Project}->{report}->{$_}->{name} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", lc($main::UserPref->{$User}->{$Project}->{language}), $DefaultLanguage);
a472 4
			return $main::UserPref->{$User}->{$Project}
		} else {
			$umd = LoadUserPref($User,undef); #force reading user pref from disk
			return $umd->{$Project}
d474 3
a476 4
	}
} else  {
	return undef
};
@


1.84
log
@minor fixes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.83 2003/07/09 15:30:18 jiri_schmid Exp $
d294 1
a294 1
					'report','fk','pk','aggr_def','pages','x','z','y']);
@


1.83
log
@minor bug fixies, 3dgraph interface changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.82 2003/07/07 14:17:14 jiri_schmid Exp $
a243 13
		}
	} elsif ($typ eq 'report') {
		foreach my $o ('format_def', 'grid_def', 'filter_def') {
			if (ref($Obj->{$o}) eq 'HASH') {	# object is stored localy
				my $t = {'grid_def'=>'grid', 'filter_def'=>'filter'};	# mapping between type key and locally stored object type
				next if !exists $t->{$o};
				foreach (ObjInvolved($id, $t->{$o}, $Obj->{$o})) {
				 	$h{$_}++;
				}
			} else {	# def contains ID of global object
				my $r = $Obj->{$o};
			 	$h{$r}++ if $r;
			}
@


1.82
log
@utf8 may work properly
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.81 2003/07/04 14:29:33 jiri_schmid Exp $
d307 1
a307 1
					'report','fk','pk','aggr_def']);
@


1.81
log
@utf8 handling fixed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.80 2003/07/04 06:19:19 michald Exp $
d343 2
@


1.80
log
@some fixes for proper utf8 encoding, see README for details
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.79 2003/06/25 15:40:29 jiri_schmid Exp $
d11 1
d106 1
a106 1
		if ($typ=~/attr|fact|hrelation|folder|metric|filter|format|grid|report|group|role/) {
d258 13
a272 1
		
d306 1
a306 1
					'metric','filter','format','grid','row','col','page',
d308 1
d344 5
a348 3
#	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$MDataDir.$fn, xmldecl=>1);
# fix for UTF-8 encoding:
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$MDataDir.$fn, xmldecl=>'<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?><!--file is saved as UTF-8, encoding is set to ISO-8859-1 for fixing compatibility issue on Soap Server -->');
d408 7
a414 2
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$Path.$User.'.xml', xmldecl=>'<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?><!--file saved UTF-8, encoding ISO-8859-1 si forced for reading because of compatibility issue on Soap Server -->');
		
@


1.79
log
@code changes a fixies
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.78 2003/06/25 09:14:47 jiri_schmid Exp $
d13 2
a14 2
binmode(STDOUT, ":utf8");
binmode(STDIN, ":utf8");
d73 1
a73 1
	DBlib::DBConnect($src , $conn->{'src-name'}->{content}, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content});
@


1.78
log
@multiple aggregations in metric implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.77 2003/06/24 15:17:43 jiri_schmid Exp $
d214 2
a215 1
		foreach my $r (@@{$Obj->{row}}, @@{$Obj->{col}}, @@{$Obj->{page}}) {
d221 3
a223 1
			foreach my $r (@@{$Obj->{metric}}) {
d228 3
a230 1
		foreach my $r (getObjectsFromExpr($Obj->{expr})) {
d234 3
a236 1
		foreach my $r (getObjectsFromExpr($Obj->{expr})) {
d239 1
a239 1
		foreach my $o ('aggr', 'filter_id') {
d241 1
a241 1
			$r =~ s/~.*$//;	# cut display form
@


1.77
log
@metric mData change, minor code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.76 2003/06/23 08:31:13 jiri_schmid Exp $
d287 1
a287 1
					'report','fk','pk','content']);
@


1.76
log
@clearCache rebuild
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.75 2003/06/21 16:13:10 michald Exp $
d287 1
a287 1
					'report','fk','pk']);
@


1.75
log
@improvement of object dependency directed graph
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.74 2003/06/20 16:21:23 jiri_schmid Exp $
a485 15
}
#-----------------------------------------------------
sub IsUsedInReport() {
my $ID = shift;
my $projectName = $main::MDi->{$ID}->{proj};
my $mdReports = $main::MD->{$projectName}->{report};
my $itemType = $main::MDi->{$ID}->{type};
my @@rtrn;

foreach (keys(%{$mdReports})) {
	if (SOAP->HasPath($_,$ID)) {
		push(@@rtrn,$_);
	}
}
return (@@rtrn)
@


1.74
log
@result of clearing HTML cache depends on HasPath() now
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.73 2003/06/20 08:42:32 michald Exp $
d46 10
a55 2
		foreach (keys %{$main::MD->{$pn}->{attr}}) {	# for each attribute ID
			SQLGen::MD2graph($pn, $_);
d105 1
a105 1
		if ($typ=~/attr|fact|folder|metric|filter|format|grid|report|group|role/) {
d145 2
d151 1
a151 1
				foreach (ObjInvolved($id)) {	# for each object involved in object $id definition, has to run after seting of MDi by MD2mem
d182 11
a192 4
	if (($typ eq 'attr')&&(exists $nMD->{$typ}->{$id}->{pk})) {	# set attributes into MDk
		my ($src,$t,$k);
		($src,$t,$k) = ($nMD->{$typ}->{$id}->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
		push(@@{$main::MDk->{$src}->{$t}}, $id);
d198 1
a198 2
#			push(@@{$main::MDk->{$src}->{$t}}, "$id~$t");
			push(@@{$main::MDk->{$src}->{$t}}, $id);
d207 1
a207 1
sub ObjInvolved {
d209 2
a210 2
	my $typ = $main::MDi->{$id}->{type};
	return if !$typ;	# nonexistent $typ stands for $id is attr with role (there is attr.role key in MDi presented); we can return smoothly as attr not depends on any other logical object 
d214 1
a214 1
		foreach my $r (@@{${$main::MDi->{$id}->{ptr}}->{row}}, @@{${$main::MDi->{$id}->{ptr}}->{col}}, @@{${$main::MDi->{$id}->{ptr}}->{page}}) {
d216 1
a216 1
			$r =~ s/^(\w+?)[\.~].*$/$1/;
d219 2
a220 2
		if (${$main::MDi->{$id}->{ptr}}->{metric}) {
			foreach my $r (@@{${$main::MDi->{$id}->{ptr}}->{metric}}) {
d225 1
a225 1
		foreach my $r (getObjectsFromExpr(${$main::MDi->{$id}->{ptr}}->{expr})) {
d229 1
a229 1
		foreach my $r (getObjectsFromExpr(${$main::MDi->{$id}->{ptr}}->{expr})) {
d233 2
a234 2
			my $r = ${$main::MDi->{$id}->{ptr}}->{$o};
			$r =~ s/^(\w+?)[\.~].*$/$1/;
d238 12
d273 1
a273 1
	@@fList
a293 38
#-----------------------------------------------------

sub SubstPtr2Name {			# deprecated method, substitution is maintained on client site in present

	my $objT = shift;
	my $obj = shift;

	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
			my $i=$obj->{$oT};
			my @@ta=();
			foreach (@@{$i}) {
				if ($_ eq $MetricsIdent) {	#metric group positioning
					push (@@ta, "$MetricsIdent\tm_group");
				} elsif (exists $main::MDi->{$_}) {
					push (@@ta, ${$main::MDi->{$_}->{ptr}}->{name}."\t".$main::MDi->{$_}->{type});
				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
					push (@@ta, ${$main::MDi->{$1}->{ptr}}->{name}.".$2\tattr_form") if (exists $main::MDi->{$1});
				} else {
					main::WriteLog('Substitution of ID Failed',"ID=$_",1) if ($main::LogLevel>0);
				}
			}
			@@{$obj->{$oT}} = @@ta;
		}
	} elsif ($objT eq 'report') {
		foreach my $oT ('grid','filter','format') {
			my $i=$obj->{$oT};	# ID of grid|filter|format object
			if (exists $main::MDi->{$i}) {
				$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
			} else {
				$obj->{$oT} = "NA ID($i)";
				main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
			}
		}
	}
	return $obj;
}

d302 1
a302 1
	my $objT=(keys %{$Obj})[0];	#object type
d306 1
a306 1
	my $projN;
d308 1
a308 1
		($projN)=($Path=~/^([^\/]+)\/.*$/);	#project name
a315 1
	
a320 24
	#--- substitution of obj. names by ptr to objects ---
#	if ($objT eq 'grid') {
#		foreach my $oT ('page','col','row','metric') {
#			my @@ta=();
#			foreach (@@{$Obj->{$objT}->{$objI}->{$oT}}) {
#				if ($_ eq $MetricsIdent) {	#metric group positioning
#					push (@@ta, $MetricsIdent)
#				} elsif (exists $main::MDn->{$_}) {
#					push (@@ta, $main::MDn->{$_}->{id})
#				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
#					push (@@ta, $main::MDn->{$1}->{id}.".$2") if (exists $main::MDn->{$1});
#				}
#			}
#			@@{$Obj->{$objT}->{$objI}->{$oT}} = @@ta;
#		}
#	} elsif ($objT eq 'report') {
#		foreach my $oT ('grid','filter','format') {
#			my $n=$Obj->{$objT}->{$objI}->{$oT};
#			if (exists $main::MDn->{$n}) {
#				$Obj->{$objT}->{$objI}->{$oT} = $main::MDn->{$n}->{id};
#			}
#		}
#	}

a329 3
#print Dumper($main::MD->{$Proj}->{$type});
#print Dumper($main::MDi);

d339 7
d364 1
@


1.73
log
@introduction of new directed graph structures MDga and MDgo
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.72 2003/06/13 15:35:24 jiri_schmid Exp $
a519 1
#my $projectName = &Bear::GetProjectName(undef,$ID);
d526 1
a526 1
	if ($mdReports->{$_}{$itemType."_def"} eq $ID) {
a532 65
#-----------------------------------------------------

sub IsMetricUsedInReport() {
my $ID = shift;
my $projectName = $main::MDi->{$ID}->{proj};
my $md = $main::MD->{$projectName}->{grid};
my $itemType = $main::MDi->{$ID}->{type};
my $grids;
my $rtrn;

foreach my $grid (keys(%{$md})) {
	foreach (@@{$md->{$grid}{metric}}) {
		if ($_ eq $ID) {
			$grids->{$grid} = 1;
		}
	}
}

$md = $main::MD->{$projectName}->{report};
foreach my $report (keys(%{$md})) {
	if (ref($md->{$report}{grid_def}) =~ /HASH/) {
		foreach (@@{$md->{$report}{grid_def}{metric}}) {
			if ($_ eq $ID) {
				$rtrn->{$report} = 1;
			};
		}
	} else {
		foreach (keys(%{$grids})) {
			if ($md->{$report}{grid_def} eq $_) {
				$rtrn->{$report} = 1;
			};
		}
	}
}

return (keys(%{$rtrn}))
}


#-----------------------------------------------------

sub IsUsedInMetricInReport() {
my $ID = shift;
my $projectName = $main::MDi->{$ID}->{proj};
print "$projectName";
my $md = $main::MD->{$projectName}->{metric};
my $itemType = $main::MDi->{$ID}->{type};
my $metrics;
my $rtrn;

foreach (keys(%{$md})) {
	if ($md->{$_}{filter_id} eq $ID) {
		$metrics->{$_} = 1;
	}
}

foreach (keys(%{$metrics})) {
	my @@hlp = &IsMetricUsedInReport($_);
	foreach (@@hlp) { $rtrn->{$_} = 1; }
}

return (keys(%{$rtrn}))
}

#-----------------------------------------------------
@


1.72
log
@code improvmnent
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.71 2003/06/13 11:33:00 jiri_schmid Exp $
d31 1
a31 2
	foreach (GetFiles($MDataDir,$MDataExt)) {	# foreach Project Name
		my $pn = $_;	#project name
d33 2
d36 1
a36 2
		foreach (keys %{$md->{host}}) {
			my $h = $_;	#host name
d38 2
a39 2
				OpenDBConnection($md->{host},$h,$_);	# open connection for each host/source				
				SQLGen::GraphTempInit("$h/$_");	# init Directed Graph of physical relations
d43 2
a44 2
		JoinMetadata(\$main::MD->{$_}, \$main::MDi, \$main::MDn, $md, undef, $_);
		LoadMDataRecur($MDataDir.$_."/", $_) if (-d $MDataDir.$_);  # each project metadata has corresponding directory as well
d47 1
a47 1
			SQLGen::MD2graph($main::MD->{$pn}->{attr}->{$_}, $_);
d96 3
a98 5
	foreach (keys %{$nMD}) {
		my $m=$_;	# object type
		if (/attr|fact|folder|metric|filter|format|grid|report|group|role/) {
#		if (/attr|fact|folder|metric|filter|format|grid|report|relation/) {
			foreach my $id (keys %{$nMD->{$m}}) {	# foreach object ID
d100 7
a106 3
				if ($m eq 'attr') {
					if ($nMD->{$m}->{$id}->{role}) {	# attribute has multiple roles
						foreach my $r (keys %{$nMD->{$m}->{$id}->{role}}) {	# make copy for each role of attribute
d110 3
a112 3
							if (ref($nMD->{$m}->{$id}->{fk}) eq 'ARRAY') {
								foreach (@@{$nMD->{$m}->{$id}->{fk}}) {
									push @@{$lmd->{$m}->{$i}->{fk}}, $_
d115 3
a117 3
							if (ref($nMD->{$m}->{$id}->{role}->{$r}->{fk}) eq 'ARRAY') {
								foreach (@@{$nMD->{$m}->{$id}->{role}->{$r}->{fk}}) {
									push @@{$lmd->{$m}->{$i}->{fk}}, $_
d121 3
a123 3
							if (ref($nMD->{$m}->{$id}->{name}) eq 'HASH') {		# if name contains localisation
								foreach (keys %{$nMD->{$m}->{$id}->{name}}) {	# roles have to be localised as well
									$lmd->{$m}->{$i}->{name}->{$_} = $nMD->{$m}->{$id}->{name}->{$_}.' ('.$nMD->{role}->{$r}->{name}->{$_}.')';
d126 1
a126 1
								$lmd->{$m}->{$i}->{name} = $nMD->{$m}->{$id}->{name}.' :'.$nMD->{role}->{$r}->{name};
d129 1
a129 1
								$lmd->{$m}->{$i}->{$_} = $nMD->{$m}->{$id}->{$_} if exists $nMD->{$m}->{$id}->{$_};
d132 1
a132 1
							MD2mem($MD, $MDi, $MDn, $lmd, $path, $pName, $m, $i);
d135 1
a135 1
						MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $m, $id);
d138 2
a139 2
					MD2mem($MD, $MDi, $MDn, $nMD, $path, $pName, $m, $id);
				}								
d141 3
d157 1
a157 1
	my $m=shift;	# object type
d160 4
a163 4
	$$MD->{$m}->{$id} = $nMD->{$m}->{$id};	#store objects
	if ($m=~/attr|fact|folder|relation/) {	# delete unneded parameters to save some space
		delete($$MD->{$m}->{$id}->{'gui-presentation'}) if ($$MD->{$m}->{$id}->{'gui-presentation'});
		delete($$MD->{$m}->{$id}->{'directory'}) if ($$MD->{$m}->{$id}->{'directory'});
d165 2
a166 2
	$$MDi->{$id}->{ptr} = \$$MD->{$m}->{$id};	#store pointer to object
	$$MDi->{$id}->{type} = $m;	#store object type
d169 2
a170 2
	$$MDn->{$$MD->{$m}->{$id}->{name}}->{ptr} = \$$MD->{$m}->{$id};	#store pointer to object
	$$MDn->{$$MD->{$m}->{$id}->{name}}->{id} = $id;	#store object's ID
d172 1
a172 1
	if (($m eq 'attr')&&(exists $nMD->{$m}->{$id}->{pk})) {
d174 1
a174 1
		($src,$t,$k) = ($nMD->{$m}->{$id}->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
d177 2
a178 2
	if (($m eq 'fact')&&(ref($nMD->{$m}->{$id}->{expr}) eq 'ARRAY')) {
		foreach (@@{$nMD->{$m}->{$id}->{expr}}) {
d181 1
d183 1
d186 45
d360 1
a360 1
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$MDataDir.$fn, xmldecl=>'<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?><!--file saved UTF-8, encoding ISO-8859-1 si forced for reading because of compatibility issue on Soap Server -->');
d459 1
a598 1

@


1.71
log
@metric in report implemented, clearcache implemented, when part of report changed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.70 2003/06/12 08:44:34 jiri_schmid Exp $
d464 82
@


1.70
log
@create HTML report on artificial datas implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.69 2003/06/04 07:50:56 jiri_schmid Exp $
a492 6
}

#---------------------------------------
sub GetResult {
	my $ID=shift;	#report ID
return &Cache::RCache2XTabId($ID)
@


1.69
log
@report save as bug when locals defined fixed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.68 2003/06/03 08:16:07 jiri_schmid Exp $
d496 4
@


1.68
log
@code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.67 2003/06/02 14:47:53 jiri_schmid Exp $
d362 1
a362 1
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces');
d387 1
a387 1
		my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces', forcearray=>['report']);
@


1.67
log
@user prefernces handled with getuserpref only
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.66 2003/06/02 12:09:11 jiri_schmid Exp $
a379 1
	my $Force=shift;#Force reading prefernces from disk
d404 1
a404 1
} 
@


1.66
log
@code improvment, bug fixies
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.65 2003/06/02 09:33:18 jiri_schmid Exp $
d387 5
a391 10
	$Force = 1 if (!$main::UserPref->{$User});
	
	if ($Force) {
		if (-e $fn) {
			my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces', forcearray=>['report']);
			$md = $PData->XMLin($fn);
		#print "D I S K  R E A D I N G $User\n";
		};
	} else { $md = $main::UserPref->{$User}; }#print "M E M  R E A D I N G $User\n"; }
	my $lang = lc($md->{Beard}->{language});
d393 1
d397 1
a397 1
		WriteLog('Load Preferences', $fn, 4) if ($LogLevel>3 && $Force);
a399 3
#		use Data::Dumper;
#		print Dumper($main::UserPref);

d420 1
a420 1
			$umd = LoadUserPref($User,undef,1); #force reading user pref from disk
d430 1
a430 1
			$umd = LoadUserPref($User,undef,1); #force reading user pref from disk
@


1.65
log
@user interface dialogs improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.64 2003/06/02 07:35:13 jiri_schmid Exp $
a418 1
	my $rtrn;#return value
d424 6
a429 1
		if ($main::UserPref->{$User}->{$Project}->{$Item}) {return $main::UserPref->{$User}->{$Project}->{$Item} };
d431 9
a439 1
		if ($main::UserPref->{$User}->{$Project}) {return $main::UserPref->{$User}->{$Project} };
a440 7
	$umd = LoadUserPref($User,undef,1); #force reading user pref from disk
	if ($Item) {
		return $umd->{$Project}->{$Item};
	}else {
		return $umd->{$Project};
	}
	
@


1.64
log
@report bug? fixed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.63 2003/05/30 12:43:13 jiri_schmid Exp $
d425 1
a425 1
		if ($main::UserPref->{$User}->{$Project}->{$Item}) {print "MEM READING\n"; return $main::UserPref->{$User}->{$Project}->{$Item} };
d427 1
a427 1
		if ($main::UserPref->{$User}->{$Project}) {print "MEM READING\n"; return $main::UserPref->{$User}->{$Project} };
a428 1
	print "DISK READING\n";
@


1.63
log
@minor change in GetUserPref because of historical compatibility
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.62 2003/05/30 12:39:40 jiri_schmid Exp $
d434 1
a434 1
		return $umd
@


1.62
log
@fixed bug with user prefernces
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.61 2003/05/30 09:22:41 jiri_schmid Exp $
d434 1
a434 1
		return $umd->{$Project}
@


1.61
log
@only tmp prints removed in bearlib.pl-loaduserpref
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.60 2003/05/30 09:13:31 jiri_schmid Exp $
d414 27
@


1.60
log
@minor fixies and code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.59 2003/05/28 15:33:34 michald Exp $
d404 2
a405 2
		use Data::Dumper;
		print Dumper($main::UserPref);
@


1.59
log
@move of some code into separate modules
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.58 2003/05/28 15:18:46 jiri_schmid Exp $
a383 1
#	if (! -e $fn) {$fn = $MDataDir.$Path.'implicit.xml'}
d393 1
d395 1
a395 1
	} else { $md = $main::UserPref->{$User} }
d403 4
@


1.58
log
@user pref changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.57 2003/05/28 12:56:23 jiri_schmid Exp $
d10 2
d16 1
a16 3
use SQLGen;

use vars qw($MD $MDi $MDn $MDk $MDg $DBConn $UserPref $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile $MetricsIdent @@SQLErrors $DefaultLanguage);
d43 1
a43 1
		JoinMetadata(\$MD->{$_}, \$MDi, \$MDn, $md, undef, $_);
d46 2
a47 2
		foreach (keys %{$MD->{$pn}->{attr}}) {	# for each attribute ID
			SQLGen::MD2graph($MD->{$pn}->{attr}->{$_}, $_);
d65 2
a66 2
	DBConnect($src , $conn->{'src-name'}->{content}, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content});
	if (@@SQLErrors) {
d79 1
a79 1
		JoinMetadata(\$MD->{$pName}, \$MDi, \$MDn, LoadOneMData($MDataDir.$_.$MDataExt), $MDataDir.$_.$MDataExt, $pName);
d170 1
a170 1
		push(@@{$MDk->{$src}->{$t}}, $id);
d176 1
a176 1
			push(@@{$MDk->{$src}->{$t}}, $id);
d367 1
a367 1
		$UserPref->{$User} = $Obj;
d384 1
a384 1
	#if (! -e $fn) {$fn = $MDataDir.$Path.'implicit.xml'}
d388 1
a388 1
	$Force = 1 if (!$UserPref->{$User});
d395 2
a396 2
	} else { $md = $UserPref->{$User} }

d399 1
a399 1
			$md->{Beard}->{report}->{$_}->{name} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_",lc($md->{Beard}->{language}), $DefaultLanguage);
d402 1
a402 1
		$UserPref->{$User} = $md;
a410 241

#---------------------------Beard Caches-------------------------------

# Cache structure:

our $Lookup;
# $Lookup->{$AttrID}->{data}->{$ID}=[form1,form2, ...]
#                   ->{form_idx}->{$form}=form1index		#index into ->{data} for each specific form

our $MCache;
# $MCache->{$MCacheID}->{data}->[[A1, A2, ..., M1, M2, ...], [....], ...]
#                     ->{metric}->{$metric}->{pos}=mid	#position of specific metric in ->{data} array
#                     ->{attr}->{$attr}->{pos}=aid		#position of specific attribute in ->{data} array
#                                      ->{in}=[...]		#array of element list constraintr data set
#                     ->{filter}='filter condition'		#general constraint
#                     ->{nref}=N						#number of references from $Cache
$MCache->{lastid}=0;									#last MCacheID used

our $RCache;
# $RCache->{$ReportID}->{attr}->{A1|A2|...|An}=ptr_to_MCache_row
#                    ->{mcache}=MCacheID
#                    ->{sql}=SQL

#-----------------------------------------------------

sub LoadProjLookupCache {
	# load lookup data into cache for all attributes for specific project
	my $projN=shift;	# project name
	foreach (keys %{$MD->{$projN}->{attr}}) {	# foreach attribute object ID
		LoadLookupCache($_);		# load lookup cache for attr $_
	}				
}

#-----------------------------------------------------

sub LoadLookupCache {

	# load lookup data into cache
	my $ID=shift;	#report ID

	my ($h,$s,$t,$c)=SplitKey(${$main::MDi->{$_}->{ptr}}->{pk});	# get primary key
	my $src = "$h/$s";

	if (!IsDBConnected($src)) {
		WriteLog('Load Lookup Cache Failed',"DB connection is not open for $src (Attribute ID:$ID)",1) if ($LogLevel>0);
		return 0
	}

	my @@SelCl;	#SQL Selection Clause
	push (@@SelCl,$c);

	# physical presentation of multiple forms has to be located in one lookup table (e.g. host/source/table) in present version 
	# for support of lookup tables there will be necessary to create separate $SelCl for each such specific lookup table and to make separate SQL for each of them
	my %fdi;	# form definition index
	my $i=1;	# latest index
	foreach my $d (keys %{${$main::MDi->{$_}->{ptr}}->{display}}) {	# foreach display form
		foreach my $l (keys %{${$main::MDi->{$_}->{ptr}}->{display}->{$d}->{def}}) {	# foreach lang
			my $fd=${$main::MDi->{$_}->{ptr}}->{display}->{$d}->{def}->{$l};
			my ($hh,$ss,$tt,$c)=SplitKey($fd);	# get form def
			if (($h eq $hh) && ($s eq $ss) && ($t eq $tt)) {	#same host/source/table as for PK
				if ( $fdi{$fd} ) {	# same definition for diferent form is already exists
					$Lookup->{$ID}->{form_idx}->{$d}->{$l}=$fdi{$fd};					
				} else {
					push (@@SelCl,$c);
					$Lookup->{$ID}->{form_idx}->{$d}->{$l}=$i;
					$fdi{$fd}=$i++;
				}
			}
		}
	}
	
	if (@@SelCl) {
#		SQLPrepareFetch($src, 'l', 'SELECT '.join(',',@@SelCl)." FROM $t LIMIT 30");	#!!! for testing purposes only
		SQLPrepareFetch($src, 'l', 'SELECT '.join(',',@@SelCl)." FROM $t");
		if (@@SQLErrors) {
			WriteLog('Load Lookup Cache Failed',"ID:$ID:".join(',',@@SQLErrors),1) if ($LogLevel>0);
			undef @@SQLErrors;
			return 0
		} else {
			WriteLog('Load Lookup Cache',"Attribute ID:$ID",4) if ($LogLevel>3);
		}
		while ( my (@@r)=SQLFetch($src,'l') ) {
			$Lookup->{$ID}->{data}->{$r[0]}=[splice(@@r,1)];
		}
		SQLFetchClose($src,'l');
	} else {
		WriteLog('Load Lookup Cache Failed',"Preparation of SQL failed for Attribute ID:$ID",1) if ($LogLevel>0);
		delete $Lookup->{$ID};	# clear cache instance
	}
}

#-------------------

sub SplitKey {
	# returns (host, source, table, sel_expression)
	my $k=shift;	#key definition
	return ($k=~m|^(.+?)/(.+?)/(.+?)/(.*)$|);
}

#-----------------------------------------------------

sub GetResultDataSet {

	# returns result data set in table form
	my $ID=shift;	#report ID

	if ($main::MDi->{$ID}->{type} ne 'report') {
		WriteLog('GetResultDataSet Failed',"Attempt to access non report object ID:$ID",1) if ($LogLevel>0);
		return 0
	}

	my $id=CheckCache($ID);
	if ($id) {
		WriteLog('GetResultDataSet',"ID:$ID",4) if ($LogLevel>3);
#		return $RCache->{$id}->{data}
print Dumper($MCache);
print Dumper($RCache);
print Dumper($Lookup->{1201});
		return $id
	} else {
		WriteLog('GetResultDataSet Failed',"Cache Failure for report object ID:$ID",1) if ($LogLevel>0);
		return 0
	}
#print Dumper($RCache);
#print Dumper($MCache);

}

#-----------------------------------------------------

sub CheckCache {
# check if cache for specified conditions exists, if no, lets load it
# returns Cache ID or 0 if fails

	my $ID=shift;	#report ID

	my $grid=${ $main::MDi->{ ${$main::MDi->{$ID}->{ptr}}->{grid} }->{ptr} };	#returns Grid Object of selected report
	my %a;
	foreach (@@{$grid->{row}}) {s/\.\w+$//; $a{$_}=1 if ($_ ne $MetricsIdent)};
	foreach (@@{$grid->{col}}) {s/\.\w+$//; $a{$_}=1 if ($_ ne $MetricsIdent)};
	foreach (@@{$grid->{page}}) {s/\.\w+$//; $a{$_}=1 if ($_ ne $MetricsIdent)};
	my @@attr=sort (keys %a);				#array of attributes involved in report
	my @@metric=sort (@@{$grid->{metric}});	#array of metrics involved in report

# return here if Cache already exists

	$MCache->{lastid}++;

	my $src;	# expect host/source
	($src, $RCache->{$ID}->{sql}) = PrepareSQL(@@attr, @@metric);
	SQLPrepareFetch($src, 'rds', $RCache->{$ID}->{sql});
	if (@@SQLErrors) {
		WriteLog('Get Cache Failed',"ID:$ID:".join(',',@@SQLErrors),1) if ($LogLevel>0);
		undef @@SQLErrors;
		return 0
	}

	my $nmetr=$#metric+1;	# number of metrics involved
	my $nattr=$#attr+1;		# number of attributes involved
#	my $loo;				# temporary hash
	my $i=0;

	my $te='$RCache->{$ID}->{data}';	# prepare string for evaluation; we have to asign ptr into RCache this way as depth of hash is not known in compile time
	for (0..$#attr) {
		$te.='->{$r['.$_.']}';
	}
	$te.='=$x';				# $te has to be in form: $RCache->{$ID}->{data}->{$r[0]}->{$r[1]}...=$x;

	while ( my (@@r)=SQLFetch($src,'rds') ) {
#		my $j=0;
#		foreach (@@attr) {
#			$loo->{$_}->{$r[$j++]}=1;
#		}
		push( @@{$MCache->{$MCache->{lastid}}->{data}}, [@@r] );
#		$RCache->{$ID}->{data}->{join('|', splice(@@r, 0, $nattr))} = \@@{@@{$MCache->{$MCache->{lastid}}->{data}}[$i++]};	#  ptr to MCache row
		my $x = \@@{@@{$MCache->{$MCache->{lastid}}->{data}}[$i++]};	#  ptr to MCache row
		eval ($te);
	}
	SQLFetchClose($src,'rds');

#	foreach my $a (@@attr) {
#		foreach (keys %{$loo->{$a}}) {
#			push (@@{$RCache->{$ID}->{lookup}->{$a}}, $_);
#		}
#	}
	$MCache->{$MCache->{lastid}}->{nref}=1;			# number of references to this instance
	@@{$MCache->{$MCache->{lastid}}->{attr}}=@@attr;	# sorted array of attribute IDs
	@@{$MCache->{$MCache->{lastid}}->{metric}}=@@metric;	# sorted array of metric IDs
	$RCache->{$ID}->{mcache}=$MCache->{lastid};		# link to MCache
	@@{$RCache->{$ID}->{attr}}=(keys %a);			# unsorted array of attribute IDs
	$RCache->{$ID}->{metric}=$grid->{metric};		# unsorted array of metric IDs

#$MCache->{1}->{data}[1][3]=1;	#test if link from RCache is real
	return $ID

}

#-----------------------------------------------------

sub GetResult {
	# returns result hash of cells
	my $ID=shift;	#report ID

	if ($main::MDi->{$ID}->{type} ne 'report') {
		WriteLog('GetResult Failed',"Attempt to access non report object ID:$ID",1) if ($LogLevel>0);
		return -1
	}
	WriteLog('GetResult',"ID:$ID",4) if ($LogLevel>3);

	my $grid=${ $main::MDi->{ ${$main::MDi->{$ID}->{ptr}}->{grid} }->{ptr} };	#returns Grid Object of selected report

	my %a;
	foreach (@@{$grid->{row}}) {$a{$_}=1 if ($_ ne $MetricsIdent)};
	foreach (@@{$grid->{col}}) {$a{$_}=1 if ($_ ne $MetricsIdent)};
	foreach (@@{$grid->{page}}) {$a{$_}=1 if ($_ ne $MetricsIdent)};
	my @@attr=sort (keys %a);

	my $sql=PrepareSQL(\@@attr, \@@{$grid->{metric}});
	
	return $sql;

}

#-----------------------------------------------------

sub PrepareSQL {
	# returns host/source and SQL Statement
	my $attr = shift;
	my $metric = shift;
	
	# this is for testing purpose only
#	my $sql = "SELECT lu_date.year_id, lu_date.month_id, SUM(objem_prodeje_agr2.ks), SUM(objem_prodeje_agr2.cenaXks) FROM objem_prodeje_agr2 INNER JOIN lu_date ON objem_prodeje_agr2.date_id=lu_date.date_id GROUP BY lu_date.year_id, lu_date.month_id";
	my $sql = "SELECT lu_date.year_id, lu_date.month_id, SUM(objem_prodeje_agr2.ks), SUM(objem_prodeje_agr2.cenaXks) FROM objem_prodeje_agr2 INNER JOIN lu_date ON objem_prodeje_agr2.date_id=lu_date.date_id WHERE month_id IN (200002, 200003, 200004, 200102, 200104) GROUP BY lu_date.year_id, lu_date.month_id";
#	$sql .= "\n\n<p>".join('|',@@$attr).':'.join ('|',@@$metric)."\n";

	return ("localhost/delta", $sql);

}

#---------------------------------------
#copy of LocalizedObj in local_lib.pl
@


1.57
log
@forcearray fixies
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.56 2003/05/28 10:40:23 jiri_schmid Exp $
a397 4

#	use Data::Dumper;
#	print Dumper($md);
	
@


1.56
log
@code-improvment bug removed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.55 2003/05/28 08:55:28 jiri_schmid Exp $
d392 1
a392 1
			my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces');
d398 4
d408 1
a408 2
	}
	else {
@


1.55
log
@user pref handling changed, implicit.xml file removed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.54 2003/05/28 07:34:21 jiri_schmid Exp $
d392 1
a392 1
			my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces', forcearray=>['report']);
@


1.54
log
@cvs add/remove changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.53 2003/05/27 12:18:12 michald Exp $
d384 1
a384 1
	if (! -e $fn) {$fn = $MDataDir.$Path.'implicit.xml'}
d396 1
a396 1
	my $lang = lc($md->{Beard}->{language});
d399 1
a399 1
			$md->{Beard}->{report}->{$_}->{name} = main::LocalizedObj(${$main::MDi->{$_}->{ptr}}->{name}, "Object #$_", $lang, $DefaultLanguage);
@


1.53
log
@joins for not directly connected vertexes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.52 2003/05/26 15:01:40 jiri_schmid Exp $
d652 1
@


1.52
log
@saving under non-selected language implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.51 2003/05/23 06:40:49 michald Exp $
a8 1
use Graph::Directed;
d14 2
a34 1
		my $gr = {};	# temporary directed graph
d39 1
a39 1
				$gr->{"$h/$_"} = new Graph::Directed;	# init Directed Graph of physical relations
d47 1
a47 1
			MD2graph($gr, $MD->{$pn}->{attr}->{$_}, $_);
d49 2
a51 56
		# make directed graph
		foreach my $src (keys %{$gr}) {	# foreach source
			$MDg->{$pn}->{$src} = $gr->{$src}->APSP_Floyd_Warshall;
			my ($s,$e);
			my @@edg = $gr->{$src}->edges;
			while (@@edg) {	# copy join constrains into MDg
				$e = pop(@@edg);
				$s = pop(@@edg);
				$MDg->{$pn}->{$src}->set_attribute('join', $s, $e, $gr->{$src}->get_attribute('join', $s, $e))
			}
		}
#		delete($MD->{$pn}->{r_g});

	}
}

sub MD2graph {
# create relation for Directed Graph, new metadata has to be of attribute type
	my $rg=shift;	# hash for directed graph storage
	my $nMD=shift;	# new metadata
	my $id=shift;	# new object ID

#	return if !($nMD->{pk});	# return if pk is not defined, attributes without pk has to be solved separately
	
	my ($src1,$t1,$k1);
	if ($nMD->{pk}) {
		($src1,$t1,$k1) = ($nMD->{pk} =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
	}
	if (ref($nMD->{fk}) eq 'ARRAY') {
		foreach my $fk (@@{$nMD->{fk}}) {	# for each FK

			my ($src2,$t2,$k2) = ($fk =~ /^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
			if (!exists $nMD->{pk}) {	# if PK not exists
				$src1 = $src2;			# set both src equivalent to path through next checks smoothly
			}
			if (($src1) && ($src2)) {	# add edge to the Graph
				if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
					my ($r1) = ($id =~ /^[0-9a-f]{1,10}\.(\w+)$/);
					foreach my $id2 (@@{$MDk->{$src2}->{$t2}}) {	# for each object mapped into $t2
						my ($r2) = ($id2 =~ /^[0-9a-f]{1,10}\.(\w+)$/);
						next if ($r1&&$r2&&($r1 ne $r2));
						$rg->{$src1}->add_weighted_edge($id, 1, $id2);
						my $join = $nMD->{join};	# !!! need reimplementation: explicit join can be part of hrelation
						next if (!$join && (!exists $nMD->{pk}));	# don't set join if PK not exists and join is not defined explicitly in hrelation
						$join = "$t1.$k1=$t2.$k2" if (!$join);
						if (!$rg->{$src1}->set_attribute('join', $id, $id2, $join)) {
							WriteLog("Directed Graph Set Attribute Fails",$join,1) if ($LogLevel>0);
						}
					}
				} else {
					WriteLog("Wrong Relation Definition for $fk","Relation between Different Sources",1) if ($LogLevel>0);
				}
			} else {
				WriteLog("Wrong Relation Definition for $fk",'',1) if ($LogLevel>0);
			}
		}					
@


1.51
log
@implementation of attribute roles into directed graph
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.50 2003/05/22 09:17:38 michald Exp $
d15 1
a15 1
use vars qw($MD $MDi $MDn $MDk $MDg $DBConn $UserPref $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile $MetricsIdent @@SQLErrors);
d450 1
a450 1

d453 1
a453 1
			$md->{Beard}->{report}->{$_}->{name} = ${$main::MDi->{$_}->{ptr}}->{name};
@


1.50
log
@group and role object loading into memory metadata
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.49 2003/05/21 10:38:21 michald Exp $
d15 1
a15 1
use vars qw($MD $MDi $MDn $DBConn $UserPref $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile $MetricsIdent @@SQLErrors);
d34 1
d39 1
a39 1
				$MD->{$pn}->{r_g}->{"$h/$_"} = new Graph::Directed;	# init Directed Graph of physical relations
d46 4
a49 1
next;
d51 2
a52 2
		foreach my $src (keys %{$MD->{$pn}->{r_g}}) {	# foreach source
			$MD->{$pn}->{rel_gr}->{$src} = $MD->{$pn}->{r_g}->{$src}->APSP_Floyd_Warshall;
d54 5
a58 5
			my @@edg=$MD->{$pn}->{r_g}->{$src}->edges;
			while (@@edg) {	# copy join constrains into rel_gr
				$e=pop(@@edg);
				$s=pop(@@edg);
				$MD->{$pn}->{rel_gr}->{$src}->set_attribute('join', $s, $e, $MD->{$pn}->{r_g}->{$src}->get_attribute('join', $s, $e))
d66 43
d156 1
a156 5
				if ($m=~/metric/) {
#print Dumper($nMD->{$m});
				}
				if ($m=~/attr/) {
#print Dumper($nMD->{$m}) if $id==9202;
a184 1
							MD2graph($MD, $lmd->{$m}->{$i});
a187 1
						MD2graph($MD, $nMD->{$m}->{$id});
d191 1
a191 36
				}				
				
#				if ($m=~/relation/) {	# create relation for Directed Graph
#					my $c1 = $nMD->{$m}->{$_}->{from}->{cardinality};
#					my $c2 = $nMD->{$m}->{$_}->{to}->{cardinality};
#					my ($co1,$co2);
#					if (($c1 eq '1')&&($c2 eq 'N')) {
#						$co1 = $nMD->{$m}->{$_}->{from}->{content};
#						$co2 = $nMD->{$m}->{$_}->{to}->{content};
#					} elsif (($c1 eq 'N')&&($c2 eq '1')) {
#						$co1 = $nMD->{$m}->{$_}->{to}->{content};
#						$co2 = $nMD->{$m}->{$_}->{from}->{content};
#					}
#					next if (($co1=~/^_/) || ($co2=~/^_/));	# not physical relation
#					my ($src1,$src2,$t1,$t2,$k1,$k2);
#					($src1,$t1,$k1) = ($co1=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
#					($src2,$t2,$k2) = ($co2=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
#
#					if (($src1) && ($src2)) {	# add edge to the Graph
#						if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
#							$$MD->{r_g}->{$src1}->add_weighted_edge($t1, 1, $t2);
#							my $join = $nMD->{$m}->{$_}->{join};
#							$join = "$t1.$k1=$t2.$k2" if (!$join);
#							if (!$$MD->{r_g}->{$src1}->set_attribute('join', $t1, $t2, $join)) {
#								WriteLog("Directed Graph Set Attribute Fails",$join,1) if ($LogLevel>0);
#							}
#						} else {
#							WriteLog("Wrong Relation Definition in $pName","Relation between Different Sources",1) if ($LogLevel>0);
#						}
#					} else {
#						WriteLog("Wrong Relation Definition in $pName",'',1) if ($LogLevel>0);
#					}
#					
#					next
#				}
				
a197 33
sub MD2graph {
# create relation for Directed Graph, new metadata has to be of attribute type
	my $MD=shift;	# project specific subtree of metadata
	my $nMD=shift;	# new metadata

	return if !($nMD->{pk});	# return if pk is not defined, attributes without pk has to be solved separately
	
	my $co1 = $nMD->{pk};
	my ($src1,$src2,$t1,$t2,$k1,$k2);
	($src1,$t1,$k1) = ($co1=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
	if (ref($nMD->{fk}) eq 'ARRAY') {
		foreach my $co2 (@@{$nMD->{fk}}) {

			($src2,$t2,$k2) = ($co2=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);

			if (($src1) && ($src2)) {	# add edge to the Graph
				if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
					$$MD->{r_g}->{$src1}->add_weighted_edge($t1, 1, $t2);
					my $join = $nMD->{join};	# need reimplementation: join has to be an attribute of specific fk
					$join = "$t1.$k1=$t2.$k2" if (!$join);
					if (!$$MD->{r_g}->{$src1}->set_attribute('join', $t1, $t2, $join)) {
						WriteLog("Directed Graph Set Attribute Fails",$join,1) if ($LogLevel>0);
					}
				} else {
					WriteLog("Wrong Relation Definition for $co2","Relation between Different Sources",1) if ($LogLevel>0);
				}
			} else {
				WriteLog("Wrong Relation Definition for $co2",'',1) if ($LogLevel>0);
			}
		}					
	}
}

d220 13
@


1.49
log
@minor fix
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.48 2003/05/21 07:47:24 michald Exp $
d105 1
a105 1
		if (/attr|fact|folder|metric|filter|format|grid|report/) {
d132 1
a132 1
									$lmd->{$m}->{$i}->{name}->{$_} = $nMD->{$m}->{$id}->{name}->{$_}.' :'.$nMD->{role}->{$r}->{name}->{$_};
@


1.48
log
@implementation of attribute roles and groups
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.47 2003/05/14 14:28:21 jiri_schmid Exp $
d202 2
a203 1
	foreach my $co2 (@@{$nMD->{fk}}) {
d205 1
a205 1
		($src2,$t2,$k2) = ($co2=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
d207 10
a216 7
		if (($src1) && ($src2)) {	# add edge to the Graph
			if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
				$$MD->{r_g}->{$src1}->add_weighted_edge($t1, 1, $t2);
				my $join = $nMD->{join};	# need reimplementation: join has to be an attribute of specific fk
				$join = "$t1.$k1=$t2.$k2" if (!$join);
				if (!$$MD->{r_g}->{$src1}->set_attribute('join', $t1, $t2, $join)) {
					WriteLog("Directed Graph Set Attribute Fails",$join,1) if ($LogLevel>0);
d219 1
a219 1
				WriteLog("Wrong Relation Definition for $co2","Relation between Different Sources",1) if ($LogLevel>0);
d221 2
a222 4
		} else {
			WriteLog("Wrong Relation Definition for $co2",'',1) if ($LogLevel>0);
		}
	}					
@


1.47
log
@next report improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.46 2003/05/08 07:42:46 michald Exp $
d29 1
d33 1
d41 1
d44 3
d57 2
a58 1
		delete($MD->{$pn}->{r_g});
d105 3
a107 2
		if (/attr|fact|folder|metric|filter|format|grid|report|relation/) {
			foreach (keys %{$nMD->{$m}}) {	# foreach object ID
d109 30
a138 24
				if ($m=~/relation/) {	# create relation Directed Graph
					my $c1 = $nMD->{$m}->{$_}->{from}->{cardinality};
					my $c2 = $nMD->{$m}->{$_}->{to}->{cardinality};
					my ($co1,$co2);
					if (($c1 eq '1')&&($c2 eq 'N')) {
						$co1 = $nMD->{$m}->{$_}->{from}->{content};
						$co2 = $nMD->{$m}->{$_}->{to}->{content};
					} elsif (($c1 eq 'N')&&($c2 eq '1')) {
						$co1 = $nMD->{$m}->{$_}->{to}->{content};
						$co2 = $nMD->{$m}->{$_}->{from}->{content};
					}
					next if (($co1=~/^_/) || ($co2=~/^_/));	# not physical relation
					my ($src1,$src2,$t1,$t2,$k1,$k2);
					($src1,$t1,$k1) = ($co1=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);
					($src2,$t2,$k2) = ($co2=~/^([^\/]+\/[^\/]+)\/([^\/]+)\/([^\/]+)$/);

					if (($src1) && ($src2)) {	# add edge to the Graph
						if ($src1 eq $src2) {	# only relations between tables located in the same sources is implemented
							$$MD->{r_g}->{$src1}->add_weighted_edge($t1, 1, $t2);
							my $join = $nMD->{$m}->{$_}->{join};
							$join = "$t1.$k1=$t2.$k2" if (!$join);
#print "$join\n";			
							if (!$$MD->{r_g}->{$src1}->set_attribute('join', $t1, $t2, $join)) {
								WriteLog("Directed Graph Set Attribute Fails",$join,1) if ($LogLevel>0);
d140 3
a142 2
						} else {
							WriteLog("Wrong Relation Definition in $pName","Relation between Different Sources",1) if ($LogLevel>0);
d144 3
a146 2
					} else {
						WriteLog("Wrong Relation Definition in $pName",'',1) if ($LogLevel>0);
d148 37
a184 3
					
					next
				}
a185 11
				$$MD->{$m}->{$_} = $nMD->{$m}->{$_};	#store objects, $_ is object ID
				if ($m=~/attr|fact|folder|relation/) {	# delete unneded parameters to save some space
					delete($$MD->{$m}->{$_}->{'gui-presentation'}) if ($$MD->{$m}->{$_}->{'gui-presentation'});
					delete($$MD->{$m}->{$_}->{'directory'}) if ($$MD->{$m}->{$_}->{'directory'});
				}
				$$MDi->{$_}->{ptr} = \$$MD->{$m}->{$_};	#store pointer to object
				$$MDi->{$_}->{type} = $m;	#store object type
				$$MDi->{$_}->{path} = $path;	#store object disk location
				$$MDi->{$_}->{proj} = $pName;	#store project name
				$$MDn->{$$MD->{$m}->{$_}->{name}}->{ptr} = \$$MD->{$m}->{$_};	#store pointer to object
				$$MDn->{$$MD->{$m}->{$_}->{name}}->{id} = $_;	#store object's ID
d192 55
d273 1
a273 1
					'report']);
d484 2
a485 2
# $Lookup->{$Attr}->{data}->{$ID}=[form1,form2, ...]
#                 ->{form_idx}->{$form}=form1index		#index into ->{data} for each specific form
d529 2
a530 3
	# physical presentation of multiple forms has to be located in one host/source/table in present version 
	# for support of multiple host/source/table there will be necessary to go through this section in loop once per all PK
	# maybe there will be nice to prepare set of @@SelCl at first, then try to make joins on top of all @@SelCl belongs to specific PK
d727 1
a727 1
		if ($descr=~/HASH/) {
d730 1
a730 1
					if ($descr->{$_}=~/HASH/) {
@


1.46
log
@customization of report SQL
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.45 2003/05/07 08:21:59 jiri_schmid Exp $
d178 2
a179 1
					'metric','filter','format','grid','report','row','col','page']);
@


1.45
log
@code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.44 2003/05/06 20:48:38 michald Exp $
d435 2
@


1.44
log
@new format of attribute metadata - attribute display localization
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.43 2003/05/06 15:36:06 jiri_schmid Exp $
d351 1
a351 1
	my $Force=shift;#force reading from disk
a357 5
	if ($UserPref->{$User} && !$Force) {return $UserPref->{$User}};
	if (-e $fn) {
		my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces', forcearray=>['report']);
		$md = $PData->XMLin($fn);
	}
d359 9
a368 2
		# ad names to hash of IDs
#		my $removed;
a370 3
#			if ($md->{Beard}->{report}->{$_}->{name} eq "") {
#				delete($md->{Beard}->{report}->{$_});
#				$removed = 1;}
d372 1
a372 6
#		if (! keys(%{$md->{Beard}->{report}})) {delete($md->{Beard}->{report});}
#		if ($removed) {SaveUserPref($md,$User,$Path)};
	}
	
	if ($md) {
		WriteLog('Load Preferences', $fn, 4) if ($LogLevel>3);
@


1.43
log
@return to previous logic, when report removed and result saved
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.42 2003/05/06 15:06:12 jiri_schmid Exp $
d444 2
a445 2
		foreach my $l (keys %{${$main::MDi->{$_}->{ptr}}->{display}->{$d}}) {	# foreach lang
			my $fd=${$main::MDi->{$_}->{ptr}}->{display}->{$d}->{$l}->{content};
@


1.42
log
@bug fixies, code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.41 2003/05/06 09:21:01 jiri_schmid Exp $
d366 1
a366 1
		my $removed;
d369 3
a371 3
			if ($md->{Beard}->{report}->{$_}->{name} eq "") {
				delete($md->{Beard}->{report}->{$_});
				$removed = 1;}
d373 2
a374 2
		if (! keys(%{$md->{Beard}->{report}})) {delete($md->{Beard}->{report});}
		if ($removed) {SaveUserPref($md,$User,$Path)};
@


1.41
log
@loading user pref from cache, tabs length implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.40 2003/05/05 06:41:47 michald Exp $
d351 1
d358 1
a358 1
	if ($UserPref->{$User}) {return $UserPref->{$User}};
d366 1
d369 3
d373 2
@


1.40
log
@implementation of full localized metadata
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.20 2003/02/24 15:37:32 jiri_schmid Exp $
d357 1
@


1.39
log
@code improvment
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.38 2003/05/01 12:17:23 michald Exp $
d15 1
a15 1
use vars qw($MD $MDi $MDn $DBConn $USER $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile $MetricsIdent @@SQLErrors);
d25 1
a25 1
#---------------------------------------
d61 1
a63 1
print "host/source:md-$h-source-$s-src-conn\n";
d122 1
d135 1
d147 1
d180 1
d185 1
d187 1
a187 5
#-----------------------------------------------------
sub SaveUserPref {
	my $Obj=shift;	#object to save
	my $User=shift; #user name from apache server
	my $Path=shift;	#path (under $MDataDir, started with project name) where object will be saved
d189 2
a190 8
	if ($Path) {$Path = $MDataDir.$Path} 
	else {$Path = $MDataDir.'Prefer/'};
	
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces');
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$Path.$User.'.xml', xmldecl=>'<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?><!--file saved UTF-8, encoding ISO-8859-1 si forced for reading because of compatibility issue on Soap Server -->');
		
	if ($out) { WriteLog('Save Metadata',$User.'.xml',4) if ($LogLevel>3); return $User} # file save succeed
	else { WriteLog('Save Metadata Falied',$User.'.xml',1) if ($LogLevel>0); return undef} # file save failed 
d192 29
a221 12
#---------------------------------------

sub LoadUserPref {
	my $User=shift;
	my $Path=shift;	# path to metadata file

	if (!$Path) {$Path = 'Prefer/'};
	my $fn = $MDataDir.$Path.$User.'.xml';	 # preferences file
	if (! -e $fn) {$fn = $MDataDir.$Path.'implicit.xml'}

	my $md;
	my $PData = new XML::Simple(keyattr=>'id', rootname=>'prefernces', forcearray=>['report']);
d223 1
a223 2
	WriteLog('Load Metadata',"Load from $Path",4) if ($LogLevel>3);
	if (-e $fn) {$md = $PData->XMLin($fn)};
a224 11
	if ($md) {
		foreach (keys(%{$md->{Beard}->{report}})) {
		$md->{Beard}->{report}->{$_}->{name} = ${$main::MDi->{$_}->{ptr}}->{name};
		}
	}
	
	if ($md) { WriteLog('Load Metadata',"Load from $fn",4) if ($LogLevel>3) }
	else { WriteLog('Load Metadata Falied',"Load from $fn",1) if ($LogLevel>0); return undef} 
	return $md
} 
#-----------------------------------------------------
d238 1
a238 4
		#$fn=$Obj->{$objT}->{$objI}->{name};
		#$fn=~y/\/\'\"\\\$\*\?/_______/;	#'kick-off bad chars
		$fn = ($objI) ? $objI : IDGen();	# set filename appropiate to object ID
		#$fn=IDGen() if (!$fn);			# replace filename by generic ID in case filename is missing
a243 1
print "$Path, $projN, $fn\n";
d251 24
d276 3
d280 1
d295 1
d322 61
a382 1
#-----------------------------------------------------
d406 1
a406 1
sub LoadLookupsCache {
d409 1
a409 1
	foreach (keys %{$MD->{$projN}->{attr}}) {	# foreach object ID
a420 2
	WriteLog('Load Lookup Cache',"Attribute ID:$ID",4) if ($LogLevel>3);

d423 6
d432 3
a434 3
	#multiple forms physical presentation has to be in one host/source/table in present version 
	my $i=1;
	my %fdi;	#form def index
d458 2
d465 3
a489 3
	WriteLog('GetResultDataSet',"ID:$ID",4) if ($LogLevel>3);

	CheckCache($ID);
d491 5
d497 8
a504 2
print Dumper($MCache);
#print Dumper($Lookup->{1202});
d512 1
a512 1
# returns Cache ID or -1 if fails
d524 1
a524 1
# return if Cache already exists
d541 7
d553 4
a556 3
#		push( @@{$MCache->{$MCache->{lastid}}->{data}}, [splice(@@r, $nattr, $nmetr)] );								# keep this two lines in original order
		push( @@{$MCache->{$MCache->{lastid}}->{data}}, [@@r] );								# keep this two lines in original order
		$RCache->{$ID}->{data}->{join('|', splice(@@r, 0, $nattr))} = @@{$MCache->{$MCache->{lastid}}->{data}}[$i++];	# keep this two lines in original order
d565 8
a572 7
	$MCache->{$MCache->{lastid}}->{nref}=1;
	$MCache->{$MCache->{lastid}}->{attr}=join('|', @@attr);
	$MCache->{$MCache->{lastid}}->{metric}=join('|', @@metric);
	$RCache->{$ID}->{mcache}=$MCache->{lastid};
	@@{$RCache->{$ID}->{attr}}=@@attr;			#array of attribute IDs
	$RCache->{$ID}->{metric}=$grid->{metric};	#array of metric IDs
	
d598 1
d611 2
a612 1
	my $sql = "SELECT lu_date.year_id, lu_date.month_id, SUM(objem_prodeje_agr2.ks), SUM(objem_prodeje_agr2.cenaXks) FROM objem_prodeje_agr2 INNER JOIN lu_date ON objem_prodeje_agr2.date_id=lu_date.date_id GROUP BY lu_date.year_id, lu_date.month_id";
d616 28
@


1.38
log
@some minor fixes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.37 2003/04/30 09:53:40 jiri_schmid Exp $
d213 6
@


1.37
log
@tabs for results implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.36 2003/04/16 12:17:19 jiri_schmid Exp $
d241 1
@


1.36
log
@code improvment, minor fixies
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.35 2003/04/16 11:18:12 jiri_schmid Exp $
d191 2
a192 2
	my $PData = new XML::Simple(rootname=>'prefernces');
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$Path.$User.'.xml', xmldecl=>1);
d209 1
a209 1
	my $PData = new XML::Simple(rootname=>'prefernces');
@


1.35
log
@id substitution implemented in all of *_ed.pl
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.34 2003/04/14 08:39:03 jiri_schmid Exp $
a180 74
#-----------------------------------------------------

#sub SubstPtr2Name {
#returns: metrics > ID\tTYPE; others > NAME\tTYPE
#	my $objT = shift;
#	my $obj = shift;

#	if ($objT eq 'grid') {
	#	foreach my $oT ('page','col','row','metric') {
		#	my $i=$obj->{$oT};
#			my @@ta=();
	#		foreach (@@{$i}) {
		#		if ($_ eq $MetricsIdent) {	#metric group positioning
			#		push (@@ta, "$MetricsIdent\t$MetricsIdent");
				#} elsif (exists $main::MDi->{$_}) {
#					push (@@ta, $_."\t".$main::MDi->{$_}->{type});
	#			} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
		#			push (@@ta, $_.".$2\tattr_form") if (exists $main::MDi->{$1});
			#	} else {
				#	main::WriteLog('Substitution of ID Failed',"ID=$_",1) if ($main::LogLevel>0);
#				}
	#		}
		#	@@{$obj->{$oT}} = @@ta;
#		}
	#}# elsif ($objT eq 'report') {
	#	foreach my $oT ('grid','filter','format') {
		#	my $i=$obj->{$oT};	# ID of grid|filter|format object
			#if (exists $main::MDi->{$i}) {
#				$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
	#		} elsif ($i eq "") { $obj->{$oT} = "";}
		#		else {
			#		$obj->{$oT} = "NA ID($i)";
				#	main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
#			}
	#	}
	#}# elsif ($objT eq 'metric') {
#		foreach my $oT ('filter','aggr') {
	#		my $i=$obj->{$oT};	# ID of filter|aggr object
		#	if (exists $main::MDi->{$i}) {
			#	$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
#			} elsif ($i eq "") { $obj->{$oT} = "";}
	#			else {
		#			$obj->{$oT} = "NA ID($i)";
			#		main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
#			}
	#	}
	#}
#	return $obj;
#}

#--------------

#sub Name2Ptr {
#	my $s = shift;
#
#	our $lb='&lb;';	# substitution for '['
#	our $rb='&rb;';	# substitution for ']'
#	sub N2P {
#		my $n=shift;
#		$n=~s/$lb/[/g;
#		$n=~s/$rb/]/g;
#		return $main::MDn->{$n}->{id}
#	}
#	
#	while ($s=~s/\[([^[\]]*)\[([^[\]]*?)\]([^[\]]*)\]/\[$1$lb$2$rb$3\]/) {};	#substitute all '[',']' except first level
#	$s=~s/\[(.*?)\]/'['.&N2P($1).']'/eg;
#	return $s
#}
#
#sub Ptr2Name {
#	my $s = shift;
#	$s=~s/\[(.*?)\]/'['.${$main::MDi->{$1}->{ptr}}->{name}.']'/eg;
#	return $s
#}
a246 32

#print Dumper($Obj);
	#--- substitution of obj. names by ptr to objects ---
#	if ($objT eq 'grid') {	
	#	foreach my $oT ('page','col','row') { #substitution of Metrics ID is prohibited !!!
		#	my @@ta=();
#			foreach (@@{$Obj->{$objT}->{$objI}->{$oT}}) {
	#			if ($_ eq $MetricsIdent) {	#metric group positioning
		#			push (@@ta, $MetricsIdent)
			#	} elsif (exists $main::MDn->{$_}) {
				#	push (@@ta, $main::MDn->{$_}->{id})
#				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
	#				push (@@ta, $main::MDn->{$1}->{id}.".$2") if (exists $main::MDn->{$1});
		#		}
#			}
	#		@@{$Obj->{$objT}->{$objI}->{$oT}} = @@ta;
#		}
#	}# elsif ($objT eq 'report') {
	#	foreach my $oT ('grid','filter','format') {
		#	my $n=$Obj->{$objT}->{$objI}->{$oT};
			#if (exists $main::MDn->{$n}) {
				#$Obj->{$objT}->{$objI}->{$oT} = $main::MDn->{$n}->{id};
#			}
	#	}
	#} #elsif ($objT eq 'metric') {
#		foreach my $oT ('filter','aggr') {
	#		my $n=$Obj->{$objT}->{$objI}->{$oT};
		#	if (exists $main::MDn->{$n}) {
			#	$Obj->{$objT}->{$objI}->{$oT} = $main::MDn->{$n}->{id};
#			}
	#	}
	#}
@


1.34
log
@metric load and save only under ID implemented
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.33 2003/04/11 15:25:24 jiri_schmid Exp $
d183 1
a183 1
sub SubstPtr2Name {
d185 2
a186 2
	my $objT = shift;
	my $obj = shift;
d188 18
a205 22
	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
			my $i=$obj->{$oT};
			my @@ta=();
			foreach (@@{$i}) {
				if ($_ eq $MetricsIdent) {	#metric group positioning
					push (@@ta, "$MetricsIdent\tm_group");
				} elsif (exists $main::MDi->{$_}) {
					if ($oT eq 'metric') {
						push (@@ta, $_."\t".$main::MDi->{$_}->{type});
					} else {
						push (@@ta, ${$main::MDi->{$_}->{ptr}}->{name}."\t".$main::MDi->{$_}->{type});
					}
				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
					push (@@ta, ${$main::MDi->{$1}->{ptr}}->{name}.".$2\tattr_form") if (exists $main::MDi->{$1});
				} else {
					main::WriteLog('Substitution of ID Failed',"ID=$_",1) if ($main::LogLevel>0);
				}
			}
			@@{$obj->{$oT}} = @@ta;
		}
	}# elsif ($objT eq 'report') {
d228 2
a229 2
	return $obj;
}
d324 15
a338 15
	if ($objT eq 'grid') {	
		foreach my $oT ('page','col','row') { #substitution of Metrics ID is prohibited !!!
			my @@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{$oT}}) {
				if ($_ eq $MetricsIdent) {	#metric group positioning
					push (@@ta, $MetricsIdent)
				} elsif (exists $main::MDn->{$_}) {
					push (@@ta, $main::MDn->{$_}->{id})
				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
					push (@@ta, $main::MDn->{$1}->{id}.".$2") if (exists $main::MDn->{$1});
				}
			}
			@@{$Obj->{$objT}->{$objI}->{$oT}} = @@ta;
		}
	}# elsif ($objT eq 'report') {
@


1.33
log
@substitution of id on grid when loading fixed for Mozilla and IE
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.32 2003/04/10 14:19:16 jiri_schmid Exp $
d328 2
a329 2
	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
@


1.32
log
@metric, filter, report substitutes IDs by javascript, metric & filter resets the original expresion
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.31 2003/04/08 07:32:07 michald Exp $
d184 1
a184 1

d196 5
a200 1
					push (@@ta, ${$main::MDi->{$_}->{ptr}}->{name}."\t".$main::MDi->{$_}->{type});
@


1.31
log
@fix of Name2Ptr
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.30 2003/04/07 13:28:31 michald Exp $
a9 1
use Clone qw(clone);
a60 1

d63 1
a176 1
	
d205 23
a227 72
	} elsif ($objT eq 'report') {
		foreach my $oT ('grid','filter','format') {
			my $i=$obj->{$oT};	# ID of grid|filter|format object
			if (exists $main::MDi->{$i}) {
				$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
			} elsif ($i eq "") { 
				$obj->{$oT} = "";
			} else {
					$obj->{$oT} = "NA ID($i)";
					main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
			}
		}
	} elsif ($objT eq 'metric') {
		foreach my $oT ('filter','aggr') {
			my $i=$obj->{$oT};	# ID of filter|aggr object
			if (exists $main::MDi->{$i}) {
				$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
			} elsif ($i eq "") {
				$obj->{$oT} = "";
			} else {
					$obj->{$oT} = "NA ID($i)";
					main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
			}
		}
		$obj->{expr} = Ptr2Name($obj->{expr});
	} elsif ($objT eq 'filter') {
		$obj->{expr} = Ptr2Name($obj->{expr});
	}
	return $obj;
}

#-----------------------------------------------------

sub SubstName2Ptr {

	my $objT = shift;
	my $obj = shift;

	#--- substitution of obj. names by ptr to objects ---
	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
			my @@ta=();
			foreach (@@{$obj->{$oT}}) {
				if ($_ eq $MetricsIdent) {	#metric group positioning
					push (@@ta, $MetricsIdent)
				} elsif (exists $main::MDn->{$_}) {
					push (@@ta, $main::MDn->{$_}->{id})
				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
					push (@@ta, $main::MDn->{$1}->{id}.".$2") if (exists $main::MDn->{$1});
				}
			}
			@@{$obj->{$oT}} = @@ta;
		}
	} elsif ($objT eq 'report') {
		foreach my $oT ('grid','filter','format') {
			my $n=$obj->{$oT};
			if (exists $main::MDn->{$n}) {
				$obj->{$oT} = $main::MDn->{$n}->{id};
			}
		}
	} elsif ($objT eq 'metric') {
		foreach my $oT ('filter','aggr') {
			my $n=$obj->{$oT};
			if (exists $main::MDn->{$n}) {
				$obj->{$oT} = $main::MDn->{$n}->{id};
			}
		}
		$obj->{expr} = Name2Ptr($obj->{expr});
	} elsif ($objT eq 'filter') {
		$obj->{expr} = Name2Ptr($obj->{expr});
	}

d233 22
a254 22
sub Name2Ptr {
	my $s = shift;

	our $lb='&lb;';	# substitution for '['
	our $rb='&rb;';	# substitution for ']'
	sub N2P {
		my $n=shift;
		$n=~s/$lb/[/g;
		$n=~s/$rb/]/g;
		return $main::MDn->{$n}->{id}
	}
	
	while ($s=~s/\[([^[\]]*)\[([^[\]]*?)\]([^[\]]*)\]/\[$1$lb$2$rb$3\]/) {};	#substitute all '[',']' except first level
	$s=~s/\[(.*?)\]/'['.&N2P($1).']'/eg;
	return $s
}

sub Ptr2Name {
	my $s = shift;
	$s=~s/\[(.*?)\]/'['.${$main::MDi->{$1}->{ptr}}->{name}.']'/eg;
	return $s
}
a256 1

d317 2
a318 3
#	if ((-f $MDataDir.$fn)&&(!$Rewrit)) {
	if ( ( $main::MDn->{$Obj->{$objT}->{$objI}->{name}}->{id} ne $objI) ) {
		WriteLog('Unsuccessful Metadata Rewrite',"Attempt to involuntary rewrite $fn without",3) if ($LogLevel>3);
a321 5
#	if ( ( $main::MDn->{$Obj->{$objT}->{$objI}->{name}}->{id} ne $objI) ) {
#		WriteLog('Metadata Save Failure',"Object named '$Obj->{$objT}->{$objI}->{name}' is already exists",3) if ($LogLevel>3);
#		return -2	# object name is already used by another object
#	}

d323 30
a352 2

	$Obj->{$objT}->{$objI} = SubstName2Ptr($objT, $Obj->{$objT}->{$objI} );
@


1.30
log
@object name substitution in expressions
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.29 2003/04/04 09:33:49 jiri_schmid Exp $
d296 1
a296 1
	while ($s=~s/\[(.*)\[(.*?)\](.*)\]/\[$1$lb$2$rb$3\]/) {};	#substitute all '[',']' except first level
@


1.29
log
@metric checker improved, into filter page added buttons
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.28 2003/03/26 09:38:19 jiri_schmid Exp $
d10 1
d212 3
a214 2
			} elsif ($i eq "") { $obj->{$oT} = "";}
				else {
d224 3
a226 2
			} elsif ($i eq "") { $obj->{$oT} = "";}
				else {
d231 3
d239 70
d369 3
a371 2
	if ((-f $MDataDir.$fn)&&(!$Rewrit)) {
		WriteLog('Unsuccessful Rewrite',"Attempt to involuntary rewrite $fn without",3) if ($LogLevel>3);
d375 5
d381 2
a382 30
	#--- substitution of obj. names by ptr to objects ---
	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
			my @@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{$oT}}) {
				if ($_ eq $MetricsIdent) {	#metric group positioning
					push (@@ta, $MetricsIdent)
				} elsif (exists $main::MDn->{$_}) {
					push (@@ta, $main::MDn->{$_}->{id})
				} elsif ( /^([^.]*)\.([^.]*)$/ ) {	# attribute display
					push (@@ta, $main::MDn->{$1}->{id}.".$2") if (exists $main::MDn->{$1});
				}
			}
			@@{$Obj->{$objT}->{$objI}->{$oT}} = @@ta;
		}
	} elsif ($objT eq 'report') {
		foreach my $oT ('grid','filter','format') {
			my $n=$Obj->{$objT}->{$objI}->{$oT};
			if (exists $main::MDn->{$n}) {
				$Obj->{$objT}->{$objI}->{$oT} = $main::MDn->{$n}->{id};
			}
		}
	} elsif ($objT eq 'metric') {
		foreach my $oT ('filter','aggr') {
			my $n=$Obj->{$objT}->{$objI}->{$oT};
			if (exists $main::MDn->{$n}) {
				$Obj->{$objT}->{$objI}->{$oT} = $main::MDn->{$n}->{id};
			}
		}
	}
@


1.28
log
@fixed SuperBug saving&loading Metric into/from MetaData under proper ID
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.27 2003/03/24 12:17:54 jiri_schmid Exp $
d219 1
a219 1
			my $i=$obj->{$oT};	# ID of grid|filter|format object
@


1.27
log
@IE5 bug fixed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.26 2003/03/20 16:39:45 michald Exp $
d211 15
a225 3
			} else {
				$obj->{$oT} = "NA ID($i)";
				main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
d321 7
d331 1
a331 1
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$MDataDir.$fn, xmldecl=>'<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?><!-- encoding ISO-8859-1 is necessary because of compatibility issue on Soap Server -->');
@


1.26
log
@minor fixes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.25 2003/03/14 09:23:52 jiri_schmid Exp $
d248 2
a253 1
print Dumper($md);
d255 1
a255 1
}    
@


1.25
log
@solved problem with CZ chars, by forced 8bit operating XML-UTF8 files, removed unused images
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.24 2003/03/06 14:49:04 jiri_schmid Exp $
d58 3
a60 3
	my $md=shift;
	my $h=shift;
	my $s=shift;
d65 1
a65 1
	DBConnect($src , $s, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content});
d69 1
a69 1
		WriteLog('Open DB Connection', $src, 3) if ($LogLevel>2);
a121 1
print "$join\n";			
d176 2
a177 1
my $md = $PData->XMLin($mdf);
d240 1
a240 1
	my $Path=shift;	# metadata filename
d242 3
a244 2
	if ($Path) {$Path = $MDataDir.$Path.$User.'.xml'} 
	else {$Path = $MDataDir.'Prefer/'.$User.'.xml'};
d246 1
d248 1
a248 3
	my $md;
	if (-e $Path) {	$md = $PData->XMLin($Path)}
	else {$md = &LoadUserPref('implicit')};
d250 3
a252 1
	WriteLog('Load Metadata',"Load from $Path",4) if ($LogLevel>3);
d257 1
a257 1
	# Save metadata data
a325 1
#	print Dumper($MDn);
d354 169
d527 6
d536 3
a538 3
	foreach (@@{$grid->{row}}) {$a{$_}=1};
	foreach (@@{$grid->{col}}) {$a{$_}=1};
	foreach (@@{$grid->{page}}) {$a{$_}=1};
d549 1
a549 1
	# returns SQL
d554 2
a555 2
	my $sql = "SELECT zakaznik.typ_id, vyrobek.vyrobek_typ_id, lu_date_tmp.year_id, lu_date_tmp.month_id, SUM(faktura_agr_zdv.ks) FROM faktura_agr_zdv INNER JOIN zakaznik ON faktura_agr_zdv.zak_fak_id=zakaznik.ico INNER JOIN vyrobek ON faktura_agr_zdv.vyrobek_id=vyrobek.vyrobek_id INNER JOIN lu_date_tmp ON faktura_agr_zdv.dat_zuct=lu_date_tmp.date_id GROUP BY zakaznik.typ_id, vyrobek.vyrobek_typ_id, lu_date_tmp.year_id, lu_date_tmp.month_id";
	$sql .= "\n\n<p>".join('|',@@$attr).':'.join ('|',@@$metric)."\n";
d557 1
a557 1
	return ($sql);
@


1.24
log
@loading and saving user preferneces under its name functional, preferences affects edit.cgi, tabs.cgi and prefer.cgi for now
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.23 2003/03/06 08:49:36 jiri_schmid Exp $
d11 3
d177 1
a177 2
	my $md = $PData->XMLin($mdf);

d309 1
a309 1
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$MDataDir.$fn, xmldecl=>1);
d324 1
a324 1

@


1.23
log
@saving user pref under loged user name may work properly
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.22 2003/03/04 16:32:14 jiri_schmid Exp $
d244 4
a247 2
	my $md = $PData->XMLin($Path);

@


1.22
log
@saving prefernces into xml is functional, loading almost too
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.21 2003/03/03 16:44:03 jiri_schmid Exp $
d221 1
d228 1
a228 1
	my $out=$PData->XMLout($Obj, noattr=>0, outputfile=>$Path.$USER.'.xml', xmldecl=>1);
d230 2
a231 2
	if ($out) { WriteLog('Save Metadata',$USER.'.xml',4) if ($LogLevel>3); return $USER} # file save succeed
	else { WriteLog('Save Metadata Falied',$USER.'.xml',1) if ($LogLevel>0); return undef} # file save failed 
d237 1
d240 2
a241 2
	if ($Path) {$Path = $MDataDir.$Path.$USER.'.xml'} 
	else {$Path = $MDataDir.'Prefer/'.$USER.'.xml'};
@


1.21
log
@cookie managing improvment for better cooperation with user preferences
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.20 2003/02/24 15:37:32 jiri_schmid Exp $
d219 3
d223 25
@


1.20
log
@extra bug |$ID -> $id, line 304| in bearlib.pl previously added fixed :)
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.19 2003/02/24 15:31:21 jiri_schmid Exp $
d233 4
a236 4
		$fn=$Obj->{$objT}->{$objI}->{name};
		$fn=~y/\/\'\"\\\$\*\?/_______/; #	'kick-off bad chars
		$fn=$objI if (!$fn);	# replace filename by ID in case filename is missing
		$fn=IDGen() if (!$fn);	# replace filename by generic ID in case filename is missing
@


1.19
log
@new bugs just found fixed, some visual changes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.18 2003/02/14 09:56:51 michald Exp $
d304 1
a304 1
	return if (!$id);
@


1.18
log
@fix saving of metadata after Grid edit
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.17 2003/02/05 18:31:05 michald Exp $
d304 1
a304 1

@


1.17
log
@fix metrics group object in group_ed.pl
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.16 2003/01/30 06:36:23 michald Exp $
d26 10
a35 4
	foreach (GetFiles($MDataDir,$MDataExt)) {
		my $md=LoadOneMData($MDataDir.$_.$MDataExt);
		OpenDBConnection($md->{host});
#		print Dumper($md->{host}->{localhost}->{source}->{delta}->{'src-conn'});
d38 11
d55 12
a66 14
	my $host=shift;
	foreach (keys %{$host}) {
		my $h = $_;	#host name
		foreach (keys %{$host->{$h}->{source}}) {
			my $src = "$h/$_";
			my $conn = $host->{$h}->{source}->{$_}->{'src-conn'};
			next if ($conn->{driver} ne 'dbi:MySQL');
			DBConnect($src , $_, $conn->{user}->{content}, $conn->{password}->{content}, $h, $conn->{port}->{content});
			if (@@SQLErrors) {
				WriteLog('DB Connection Falied', $src, 1) if ($LogLevel>0);
			} else {
				WriteLog('Open DB Connection', $src, 3) if ($LogLevel>2);
			}
		}
d96 33
a128 2
			foreach (keys %{$nMD->{$m}}) {
				if ($m=~/relation/) {	# create relation hash
d136 1
a136 1
				}		
a261 1
					
@


1.16
log
@functionality for saving and retrieving attribute displays and metric groups in grid editor
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.15 2003/01/26 14:16:29 michald Exp $
d147 1
a147 1
					push (@@ta, "$MetricsIdent\tmetric");
@


1.15
log
@some small fixes
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.14 2003/01/20 18:33:57 michald Exp $
d136 38
d209 3
a211 1
				if (exists $main::MDn->{$_}) {
d213 2
a214 2
				} elsif ($_ eq $MetricsIdent) {	#metric positioning
					push (@@ta, $MetricsIdent)
d216 1
d300 1
a300 1
print join('|',@@$attr).':'.join ('|',@@$metric)."\n";
@


1.14
log
@fix Clone disappearing
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.13 2003/01/18 12:23:08 michald Exp $
d84 1
a84 1
#					next
@


1.13
log
@edit_obj with drag/drop functionality
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.12 2003/01/03 11:22:05 michald Exp $
d9 1
a11 2
require 'dbi_mysql.pl';

d82 4
d87 1
a87 1
				if ($m=~/attr|fact|folder/) {	# delete unneded parameters to save some space
@


1.12
log
@hard connection to test project in *_ed.pl wa removed
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.11 2002/11/26 08:08:32 michald Exp $
d11 3
a13 1
use vars qw($MD $MDi $MDn $USER $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile $MetricsIdent);
d28 4
a31 2
#		$MD->{$_}=LoadOneMData($MDataDir.$_.$MDataExt);
		JoinMetadata(\$MD->{$_}, \$MDi, \$MDn, LoadOneMData($MDataDir.$_.$MDataExt), undef, $_);
d34 3
a36 1
#print Dumper($MDi);
d38 16
d81 1
a81 1
		if (/attr|fact|folder|metric|filter|format|grid|report/) {
d84 4
a192 13
		#--- substitution of obj. names by ptr to objects ---
#		if ($objT eq 'grid') {
#			foreach ('page','col','row','metric') {
#				my @@ta=();
#				my $objT=$_;
#				foreach (@@{$Obj->{$objT}->{$objI}->{$objT}}) {
#					push (@@ta, $main::MDn->{$_}->{id}) if (exists $main::MDn->{$_});
#				}
#				@@{$Obj->{$objT}->{$objI}->{$objT}} = @@ta;
#			}
#print Dumper($Obj);
#		}

d235 8
a242 1
	my $sql=GetSQL($grid->{row},$grid->{col},$grid->{metric});
d249 1
a249 1
sub GetSQL {
d251 6
a256 1
	my ($row,$col,$metric)=@@_;	#object ID to drop
d258 1
a258 1
	return ($row);
@


1.11
log
@name to ID translation
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.10 2002/11/22 12:01:41 michald Exp $
d213 22
@


1.10
log
@minor fix in bearlib
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.9 2002/11/21 16:27:21 spanhel Exp $
d136 1
d150 7
d168 11
a178 11
		if ($objT eq 'grid') {
			foreach ('page','col','row','metric') {
				my @@ta=();
				my $objT=$_;
				foreach (@@{$Obj->{$objT}->{$objI}->{$objT}}) {
					push (@@ta, $main::MDn->{$_}->{id}) if (exists $main::MDn->{$_});
				}
				@@{$Obj->{$objT}->{$objI}->{$objT}} = @@ta;
			}
print Dumper($Obj);
		}
@


1.9
log
@loading and saving data
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.6 2002/11/11 10:36:04 michald Exp $
d11 1
a11 1
use vars qw($MD $MDi $MDn $USER $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile);
d136 15
d153 1
a153 1
	if ($out) {
d155 1
d158 14
d182 1
a182 1
	} else {
@


1.8
log
@new obj. name to ID transition in SaveMData
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.7 2002/11/12 12:04:01 michald Exp $
d98 1
a98 1
					'metric','filter','format','grid','report']);
d108 1
a108 1
	# Save metadata
d140 2
a141 14

		#--- substitution of obj. names by ptr to objects ---
		if ($objT eq 'grid') {
			foreach ('page','col','row','metric') {
				my @@ta=();
				my $objT=$_;
				foreach (@@{$Obj->{$objT}->{$objI}->{$objT}}) {
					push (@@ta, $main::MDn->{$_}->{id}) if (exists $main::MDn->{$_});
				}
				@@{$Obj->{$objT}->{$objI}->{$objT}} = @@ta;
			}
print Dumper($Obj);
		}

a154 11
	}
}

#-----------------------------------------------------

sub SubstPtr2Name {
	my $ot=shift;	#object type
	my $obj=shift;	#object to substitute in form 'metadata type'=>ID=>{params...}

	if ($ot eq 'grid') {
	
@


1.7
log
@substitution of obj. names by ptr to objects during SaveMData
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.6 2002/11/11 10:36:04 michald Exp $
d143 7
a149 3
			my @@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{page}}) {
				push (@@ta, $main::MDn->{$_}->{ptr});
a150 16
			@@{$Obj->{$objT}->{$objI}->{page}} = @@ta;
			@@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{col}}) {
				push (@@ta, $main::MDn->{$_}->{ptr});
			}
			@@{$Obj->{$objT}->{$objI}->{col}} = @@ta;
			@@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{row}}) {
				push (@@ta, $main::MDn->{$_}->{ptr});
			}
			@@{$Obj->{$objT}->{$objI}->{row}} = @@ta;
			@@ta=();
			foreach (@@{$Obj->{$objT}->{$objI}->{metric}}) {
				push (@@ta, $main::MDn->{$_}->{ptr});
			}
			@@{$Obj->{$objT}->{$objI}->{metric}} = @@ta;
d167 11
@


1.6
log
@new debug screen
metadata name index
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.5 2002/10/22 15:11:15 michald Exp $
d108 1
a108 1
	# Save metadata data
d140 26
a165 2
#print Dumper($main::MD->{$Proj}->{$type});
#print Dumper($main::MDi);
@


1.5
log
@add demo metadata
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.4 2002/10/05 17:32:03 michald Exp $
d11 1
a11 1
use vars qw($MD $MDi $USER $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile);
d27 1
a27 1
		JoinMetadata(\$MD->{$_}, \$MDi, LoadOneMData($MDataDir.$_.$MDataExt), undef, $_);
d30 1
a30 1
print Dumper($MDi);
d40 1
a40 1
		JoinMetadata(\$MD->{$pName}, \$MDi, LoadOneMData($MDataDir.$_.$MDataExt), $MDataDir.$_.$MDataExt, $pName);
d50 1
d55 1
a55 1
	$path=~s/^$MDataDir//;	# cut $MDataDir from beginning of the path
d66 2
d142 1
d148 2
@


1.4
log
@grid edit window
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.3 2002/10/02 16:53:05 michald Exp $
d27 1
a27 1
		JoinMetadata(\$MD->{$_}, \$MDi->{$_}, LoadOneMData($MDataDir.$_.$MDataExt));
d40 1
a40 1
		JoinMetadata(\$MD->{$pName}, \$MDi->{$pName}, LoadOneMData($MDataDir.$_.$MDataExt),$MDataDir.$_.$MDataExt);
d52 4
a55 1
	
d64 1
d107 1
a108 1
	my $Rewrit=shift;	#force rewrite
d112 1
a112 2
	my $fn=$Obj->{$objT}->{$objI}->{name};	#object name
	my ($projN)=($Path=~/^([^\/]+)\/.*$/);	#project name
d114 13
a126 4
	$fn=~y/\/\'\"\\\$\*\?/_______/; #	'kick-off bad chars
	$fn=$objI if (!$fn);	# replace filename by ID in case filename is missing
	$fn=IDGen() if (!$fn);	# replace filename by generic ID in case filename is missing
	$fn=$Path.$fn.'.xml';
d132 1
d137 8
a144 1
		$main::MD->{$projN}->{$objT}->{$objI}=$Obj->{$objT}->{$objI};
d159 2
a160 2
	if (unlink($main::MDi->{$Proj}->{$ID}->{path})) {
		my $type=$main::MDi->{$Proj}->{$ID}->{type};
d162 1
a162 1
		delete $main::MDi->{$Proj}->{$ID};
@


1.3
log
@create new object implementation
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.2 2002/10/02 11:14:05 michald Exp $
d11 1
a11 1
use vars qw($MD $USER $HOSTNAME $PWD $MDataDir $MDataExt $LogLevel $LogFile);
d26 2
a27 1
		$MD->{$_}=LoadOneMData($MDataDir.$_.$MDataExt);
d30 1
a30 1
#print Dumper($MD);
d40 1
a40 1
		JoinMetadata(\$MD->{$pName}, LoadOneMData($MDataDir.$_.$MDataExt));
d49 1
d51 1
d55 7
a61 2
		foreach (keys %{$nMD->{$m}}) {
			$$MD->{$m}->{$_} = $nMD->{$m}->{$_};
d85 1
d93 2
a94 1
	WriteLog('Load Metadata',"Load from $mdf",3) if ($LogLevel>3);
d123 1
a123 1
		WriteLog('Save Metadata',"$fn",3) if ($LogLevel>3);
d127 20
a146 1
		WriteLog('Save Metadata Falied',"$fn",3) if ($LogLevel>3);
@


1.2
log
@Create New Objects functionality
@
text
@d4 1
a4 1
# $Id: bearlib.pl,v 1.1 2002/09/30 10:04:46 michald Exp $
d47 3
a49 2
	my $MD=shift;
	my $nMD=shift;
d51 1
a51 1
		my $m=$_;
d63 1
d81 2
a82 1
					'input','output','attr','fact','folder']);
d93 1
a93 1
	my $Path=shift;	#path under $MDataDir to save
d96 4
a99 2
	my $objT=(keys %{$Obj})[0];
	my $fn=$Obj->{$objT}->{name};
d102 1
a102 1
	$fn=$Obj->{$objT}->{id} if (!$fn);	# replace filename by ID in case filename is missing
d105 1
d114 1
d154 1
a154 1
1;
@


1.1
log
@new icons
@
text
@d4 1
a4 1
# $Id$
d74 1
a74 1
	my $mdf=shift;
d87 30
a124 1

a125 1

a126 1

@

