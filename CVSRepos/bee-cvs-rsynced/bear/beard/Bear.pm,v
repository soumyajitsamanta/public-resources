head	1.114;
access;
symbols;
locks; strict;
comment	@# @;


1.114
date	2004.05.06.00.25.02;	author michald;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.03.09.06.44;	author michald;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.14.14.17.57;	author jiri_schmid;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.14.09.06.43;	author jiri_schmid;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.13.12.42.37;	author michald;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.09.07.04.39;	author michald;	state Exp;
branches;
next	1.108;

1.108
date	2004.03.21.07.01.13;	author michald;	state Exp;
branches;
next	1.107;

1.107
date	2004.03.11.07.58.59;	author michald;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.10.15.14.18;	author jiri_schmid;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.05.11.37.09;	author jiri_schmid;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.02.13.00.58;	author jiri_schmid;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.25.16.05.07;	author jiri_schmid;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.24.10.21.48;	author jiri_schmid;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.23.12.09.27;	author jiri_schmid;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.19.13.26.06;	author jiri_schmid;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.18.16.19.16;	author jiri_schmid;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.13.17.09.40;	author jiri_schmid;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.12.16.24.26;	author jiri_schmid;	state Exp;
branches;
next	1.96;

1.96
date	2004.02.09.14.26.33;	author jiri_schmid;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.05.09.43.20;	author jiri_schmid;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.02.09.14.07;	author michald;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.12.13.42.03;	author michald;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.09.12.42.50;	author jiri_schmid;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.06.08.17.37;	author jiri_schmid;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.18.12.59.54;	author jiri_schmid;	state Exp;
branches;
next	1.89;

1.89
date	2003.12.16.13.44.24;	author jiri_schmid;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.12.12.12.16;	author jiri_schmid;	state Exp;
branches;
next	1.87;

1.87
date	2003.12.11.16.20.07;	author jiri_schmid;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.10.15.54.31;	author jiri_schmid;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.08.14.58.37;	author jiri_schmid;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.28.13.03.22;	author jiri_schmid;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.28.07.06.06;	author michald;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.27.16.41.09;	author jiri_schmid;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.27.08.52.44;	author jiri_schmid;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.25.10.07.13;	author michald;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.22.18.38.26;	author michald;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.20.09.42.50;	author michald;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.20.08.17.34;	author michald;	state Exp;
branches;
next	1.76;

1.76
date	2003.11.13.16.27.50;	author jiri_schmid;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.12.09.58.53;	author jiri_schmid;	state Exp;
branches;
next	1.74;

1.74
date	2003.11.11.14.03.18;	author jiri_schmid;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.10.06.35.57;	author michald;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.05.15.47.52;	author jiri_schmid;	state Exp;
branches;
next	1.71;

1.71
date	2003.11.04.15.19.00;	author jiri_schmid;	state Exp;
branches;
next	1.70;

1.70
date	2003.09.29.05.43.19;	author michald;	state Exp;
branches;
next	1.69;

1.69
date	2003.09.24.14.59.18;	author jiri_schmid;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.23.13.06.57;	author jiri_schmid;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.22.10.58.12;	author vacula;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.15.10.46.12;	author jiri_schmid;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.26.15.35.45;	author jiri_schmid;	state Exp;
branches;
next	1.64;

1.64
date	2003.08.25.15.09.20;	author jiri_schmid;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.22.16.01.03;	author jiri_schmid;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.21.12.02.13;	author jiri_schmid;	state Exp;
branches;
next	1.61;

1.61
date	2003.08.20.14.23.45;	author jiri_schmid;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.18.13.17.13;	author jiri_schmid;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.15.10.59.39;	author michald;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.12.09.19.19;	author jiri_schmid;	state Exp;
branches;
next	1.57;

1.57
date	2003.08.06.09.36.32;	author michald;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.06.07.50.33;	author jiri_schmid;	state Exp;
branches;
next	1.55;

1.55
date	2003.08.04.08.12.48;	author jiri_schmid;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.30.15.30.47;	author jiri_schmid;	state Exp;
branches;
next	1.53;

1.53
date	2003.07.29.06.52.46;	author michald;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.14.11.52.26;	author jiri_schmid;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.04.14.29.33;	author jiri_schmid;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.04.06.19.18;	author michald;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.25.15.40.29;	author jiri_schmid;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.23.08.31.13;	author jiri_schmid;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.23.08.14.38;	author michald;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.21.16.13.10;	author michald;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.20.16.21.23;	author jiri_schmid;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.20.08.42.32;	author michald;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.19.14.59.45;	author jiri_schmid;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.13.15.35.23;	author jiri_schmid;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.13.13.08.24;	author jiri_schmid;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.13.11.33.00;	author jiri_schmid;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.12.08.44.34;	author jiri_schmid;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.03.08.16.07;	author jiri_schmid;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.30.12.39.40;	author jiri_schmid;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.30.09.14.38;	author jiri_schmid;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.30.09.13.31;	author jiri_schmid;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.28.15.33.34;	author michald;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.23.15.03.43;	author jiri_schmid;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.23.06.40.49;	author michald;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.21.15.00.51;	author jiri_schmid;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.21.07.47.24;	author michald;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.07.14.24.39;	author jiri_schmid;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.07.13.11.51;	author jiri_schmid;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.07.08.21.59;	author jiri_schmid;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.06.15.06.10;	author jiri_schmid;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.05.06.41.47;	author michald;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.25.11.27.34;	author jiri_schmid;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.14.09.23.52;	author jiri_schmid;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.06.08.49.36;	author jiri_schmid;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.04.16.32.14;	author jiri_schmid;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.30.06.36.23;	author michald;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.26.14.16.29;	author michald;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.20.18.33.56;	author michald;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.20.18.23.50;	author spanhel;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.18.12.23.08;	author michald;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.03.11.22.05;	author michald;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.26.08.08.32;	author michald;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.12.18.18.43;	author michald;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.11.10.36.04;	author michald;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.02.09.28.05;	author michald;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.01.13.20.46;	author spanhel;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.22.15.11.14;	author michald;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.05.17.32.03;	author michald;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.02.16.53.04;	author michald;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.02.11.14.05;	author michald;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.30.13.56.53;	author michald;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.30.12.01.16;	author michald;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.30.10.02.24;	author michald;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.25.18.24.13;	author michald;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.15.42.38;	author michald;	state Exp;
branches;
next	;


desc
@@


1.114
log
@fix creation of the report without explicit format definition
@
text
@#-----------------------------------------------------
#  The Bear Daemon Public Package
#-----------------------------------------------------
# $Id: Bear.pm,v 1.112 2004/04/14 14:17:57 jiri_schmid Exp $

package Bear;

use strict;
use utf8;

my $run_mod_perl = defined(&Apache::RequestRec::BINMODE);	# are we running under mod_perl?
if ($run_mod_perl) { Apache::RequestRec::BINMODE(':utf8') } else { binmode(STDOUT,":utf8"); binmode(STDIN, ":utf8"); }

use Const;
require Bearlib;

use SQLGen;
use Cache;
use Acl;
use DecompLE;

our $lePO = DecompLE->new($Const::LEGrm, 'F');	# create object for parsing and decompositionof the filter logical expresion

#---------------------------------------

sub about {                    
  return "Bear Server v$Const::version\n$Const::copyright\n"  
}

#---------------------------------------

sub echo { 
	my ($class, $s) = @@_;
	if ($Cache::LogLevel>3) {
		my $st=$s;
		$st=~s/\n/\\n/g;
		Bearlib::WriteLog('Ping responded',"Data:$st:",4) if ($Cache::LogLevel>3);
	}
	return $s
}

#---------------------------------------

sub GetProjectName {	# returns Project Name for given Object ID
	my ($class,$ID) = @@_;
	Bearlib::WriteLog('Metadata Request',"GetProjectName($ID)",4) if (($Const::LogLevel>3)&&($class)); #don't log if called locally
	return $main::MDi->{$ID}->{proj};

}

#---------------------------------------

sub GetProjects {	# returns list of names of available projects
	my ($class, $user) = @@_;
	my @@pr;
	my $nn;
	foreach my $pn (sort keys %{$main::MD}) {	# !!! only match to allow-puser is implemented now
		if (exists($main::MD->{$pn}->{pacl})) {
			if ($user) {
				my $allow = $main::MD->{$pn}->{pacl}->{allow};
				push @@pr, $pn if exists($allow->{puser}->{$user}) && ($allow->{puser}->{$user}->{ac}=~/R/);
			}
		} else {
			# push @@pr, $pn;
			$nn .= $pn.',';
		}
	}
	if ($nn) { chop $nn; $nn = "Projects ($nn) have no ACL" } else { $nn = "All projects have defined ACL" };
	Bearlib::WriteLog("GetProjects Names for $user", $nn,4) if ($Const::LogLevel>3);
	return @@pr;
}

#---------------------------------------

sub GetDataSources {	# returns list of data sources of the specific project
	my ($class, $project) = @@_;
	Bearlib::WriteLog("GetDataSources Names for $project", '',4) if ($Const::LogLevel>3);
	return sort keys %{$main::MDk->{$project}};
}

#---------------------------------------

sub GetObjSuccessors {	# returns list of objects depending on specific object
	my ($class, $ID, $prox, $type) = @@_;	# return proximate successors if $prox is set, otherwise return all successors
	my $pn = GetProjectName($class,$ID);

	my @@v;
	if ($prox) {
		Bearlib::WriteLog('Get Proximate Successors',"$pn/$ID",4) if ($Const::LogLevel>3);
		@@v = $main::MDgo->{$pn}->successors($ID);
	} else {
		Bearlib::WriteLog('Get All Successors',"$pn/$ID",4) if ($Const::LogLevel>3);
		my $gr = $main::MDgo->{$pn}->TransitiveClosure_Floyd_Warshall;
		@@v = grep {!/^$ID$/} $gr->successors($ID);
	}
	if ($type) {
		my @@vv;
		foreach (@@v) {
			push @@vv,$_ if ($main::MDi->{$_}->{type}=~/$type/);
		}
		@@v=@@vv;
	}
	return (@@v)
}

#---------------------------------------

sub GetObjPredecessors {	# returns list of objects depending on specific object
	my ($class, $ID, $prox, $type) = @@_;	# return proximate predecessors if $prox is set, otherwise return all predecessors
	my $pn = GetProjectName($class,$ID);

	my @@v;
	if ($prox) {
		Bearlib::WriteLog('Get Proximate Predecessors',"$pn/$ID",4) if ($Const::LogLevel>3);
		@@v = $main::MDgo->{$pn}->predecessors($ID);
	} else {
		Bearlib::WriteLog('Get All Predecessors',"$pn/$ID",4) if ($Const::LogLevel>3);
		my $gr = $main::MDgo->{$pn}->TransitiveClosure_Floyd_Warshall;
		@@v = grep {!/^$ID$/} $gr->predecessors($ID);
	}
	if ($type) {
		my @@vv;
		foreach (@@v) {
			push @@vv,$_ if ($main::MDi->{$_}->{type}=~/$type/);
		}
		@@v=@@vv;
	}
	return (@@v)
}

#---------------------------------------

sub HasPath {	# returns true if path from $ID1 to $ID2 exists
	my ($class, $ID1, $ID2) = @@_;
	my $pn = GetProjectName($class,$ID1);
	Bearlib::WriteLog('Has Path',"$pn/($ID1, $ID2)",4) if ($Const::LogLevel>3);
	my $gr = $main::MDgo->{$pn}->TransitiveClosure_Floyd_Warshall;
	return $gr->has_path($ID1,$ID2);
}

#---------------------------------------

sub GetDebug {	# returns hash of metadata for debuging purposes
	my ($class,$var,$ID,$dataSrc,$lang) = @@_;
	Bearlib::WriteLog('Debug Metadata Request',"$var/$ID",2) if ($Const::LogLevel>1);
	if ($var eq 'MD') {
		my $pn = GetProjectName($class,$ID);
		return $main::MD->{$pn};
	} elsif ($var eq 'MDi') {
		return $main::MDi;
	} elsif ($var eq 'MDk') {
		my $pn = GetProjectName($class,$ID);
		return $main::MDk->{$pn};
	} elsif ($var eq 'MDl') {
		my $pn = GetProjectName($class,$ID);
		return $main::MDl->{$pn};
	} elsif ($var eq 'MDg') {
		my $pn = GetProjectName($class,$ID);
		return $main::MDg->{$pn};
	} elsif ($var eq 'MDgV') {
		my $pn = GetProjectName($class,$ID);
		my @@e = $main::MDg->{$pn}->{$dataSrc}->edges();
		my $ret;
		while (@@e) {
			my $f = shift @@e;
			my $t = shift @@e;
			next if $f eq $t;
			next if scalar @@{$main::MDg->{$pn}->{$dataSrc}->get_attribute('path',$f,$t)} !=2;	# we will use only direct connections between tables
			$ret->{$f}->{$t}->{w} = $main::MDg->{$pn}->{$dataSrc}->get_attribute('weight', $f, $t);
		}
		return $ret
	} elsif ($var eq 'MDga') {
		my $pn = GetProjectName($class,$ID);
		return $main::MDga->{$pn};
	} elsif ($var eq 'MDgaV') {
		my $pn = GetProjectName($class,$ID);
		my @@e = @@{$main::MDgaV->{$pn}};
		my $ret;
		while (@@e) {
			my $f = shift @@e;
			my $t = shift @@e;
			my ($fr,$tr) = split('\|', shift @@e);
			my $fn = Bearlib::LocalizedObj(${$main::MDi->{$f.$fr}->{ptr}}->{name}, $f, $lang, $Const::DefaultLanguage);
			$fn =~ s/\(.*\)$//;
			my $tn = Bearlib::LocalizedObj(${$main::MDi->{$t.$tr}->{ptr}}->{name}, $t, $lang, $Const::DefaultLanguage);
			$tn =~ s/\(.*\)$//;
			next if $f eq $t;
			$ret->{$f}->{$t}->{fn}=$fn;
			$ret->{$f}->{$t}->{tn}=$tn;
		}
		return $ret
	} elsif ($var eq 'MDgo') {
		my $pn = GetProjectName($class,$ID);
		return $main::MDgo->{$pn};
	} elsif ($var eq 'MDgoV') {
		my $pn = GetProjectName($class,$ID);
		my @@e = $main::MDgo->{$pn}->edges();
		my $ret;
		while (@@e) {
			my $f = shift @@e;
			$f = Bearlib::LocalizedObj(${$main::MDi->{$f}->{ptr}}->{name}, $f, $lang, $Const::DefaultLanguage);
			my $t = shift @@e;
			$t = Bearlib::LocalizedObj(${$main::MDi->{$t}->{ptr}}->{name}, $t, $lang, $Const::DefaultLanguage);
			next if $f eq $t;
			$ret->{$f}->{$t}->{nf}=$main::MDi->{$f}->{type};
			$ret->{$f}->{$t}->{nt}=$main::MDi->{$t}->{type};
		}
		return $ret
	} elsif ($var eq 'RCache') {
		return $Cache::RCache->{$ID};
	} elsif ($var eq 'SCache') {
		return $Cache::SCache;
	} elsif ($var eq 'Lookup') {
		return $Cache::Lookup;
	} elsif ($var eq 'UsRL') {
		my $pn = GetProjectName($class,$ID);
		return $Acl::UsRL->{$pn};
	} elsif ($var eq 'Users') {
		return $Acl::ACL;
	} elsif ($var eq 'UserPref') {
		return $main::UserPref;
	}
}

#---------------------------------------

sub GetInvolvedReportMetadata {	# returns hash of metadata in form 'metadata type'=>ID=>{params...}
	my ($class,$ID) = @@_;
	Bearlib::WriteLog('Involved Report Definition Metadata Request',"GetInvolvedReportMetadata($ID)",4) if (($main::LogLevel>3)&&($class));	#don't log if called localy
	return &Bearlib::GetInvolvedReportMetadata($ID);
}

#---------------------------------------

sub GetMetadata {	# returns hash of metadata in form 'metadata type'=>ID=>{params...}
	my ($class,$ID) = @@_;
	Bearlib::WriteLog('Metadata Request',"GetMetadata($ID)",4) if (($Const::LogLevel>3)&&($class));	#don't log if called localy
	return {$main::MDi->{$ID}->{type} => { $ID => ${$main::MDi->{$ID}->{ptr}} }}
}

#---------------------------------------

sub GetMetadataList {
# returns list of $ObjType objects with their names and shortened description
	my ($class, $Proj, $ObjType, $User, $lang, $AFID) = @@_; #afid - active folder id
	
	my $DescrLimit = $Const::DescrLPadLimit-3;	# lpad limit dor description field, default is 80 chars
	$lang = $Const::DefaultLanguage if (!$lang);

	Bearlib::WriteLog('Metadata List Request',"GetMetadataList('$Proj','$ObjType','$lang')",4) if ($Const::LogLevel>3);

	my $m;
	if (exists $main::MD->{$Proj}) {
		if ($ObjType eq 'attr') {
			my $cntnt = 0; #specifices if folder has content
			foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
				$cntnt++;
				my $GID = $main::MD->{$Proj}{attr}{$id}{group} if exists $main::MD->{$Proj}{attr}{$id}{group}; #GROUP ID
				my $group = (exists $main::MD->{$Proj}{attr}{$id}{group}) ? \$m->{$AFID}{$main::MD->{$Proj}{attr}{$id}{group}} : \$m->{$AFID}; #when no group is defined, set ptr 2 pseudo group

				if (!ref($$group->{'~name'}) && exists $main::MD->{$Proj}{group}{$GID}) {#set name and description for group folder
					$$group->{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$GID}{name}, "group by: $id", $lang);
					$$group->{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$GID}{description}, "", $lang);
					$$group->{'~content'} = $main::MD->{$Proj}{folder}{$AFID}{type};#store type of attribute folder
				}

				my $role = ($id =~ /\.(.*)$/) ? \$$group->{"$GID.$1"} : $group;#when no rule is not defined, add item into group
				if (!ref($$role->{'~name'}) && exists $main::MD->{$Proj}{group}{$GID}{role}{$1}) { #set name and description for role folder
					$$role->{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$GID}{role}{$1}{name}, "role by: $id", $lang);
					$$role->{'~desc'} = Bearlib::LocalizedObj($main::MD{$Proj}{group}{$GID}{role}{$1}{description}, "", $lang);
					$$role->{'~content'} = $main::MD->{$Proj}{folder}{$AFID}{type};#store type of attribute folder
				}
				$$role->{$id}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "role by: $id", $lang);
				$$role->{$id}{desc} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				foreach (keys %{$main::MD->{$Proj}{attr}{$id}{display}}) {#add item display forms
					$$role->{$id}{'~display'}{$_}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{name}, "Object ~$_", $lang);
					$$role->{$id}{'~display'}{$_}{desc} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{description}, '', $lang);
				}
			}
			#set root folder name and des
			$m->{$AFID}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{name}, "folder ~$AFID", $lang);
			$m->{$AFID}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{description}, '', $lang);
			$m->{$AFID}{'~content'} = $cntnt ? $main::MD->{$Proj}{folder}{$AFID}{type} : '';
		} elsif ($ObjType eq 'folder') { #return list of localized folders
			foreach my $id (keys %{$main::MD->{$Proj}{folder}}) {
				next if $main::MD->{$Proj}{folder}{$id}{parent};
				$m->{$id}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$id}{name}, "folder by: $id", $lang);
				$m->{$id}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$id}{description}, '', $lang);
				$m->{$id}{'~content'} = $main::MD->{$Proj}{$ObjType}{$id}{type}; #export predefined folder type
				$m->{$id}{'~order'} = $main::MD->{$Proj}{$ObjType}{$id}{order}; #export predefined folder type
			}
		} else { #return list of localized and grouped facts
			my $cntnt = 0; #specifices if folder has content
			my $namedFolders = {}; #defines which folder has been already defined
			foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
				next if $main::MDi->{$id}{path} =~ /PrivateMD/;
				$cntnt++;
				my $folderPtr = \$m->{$AFID}; #points 2 root folder
				if (exists $main::MD->{$Proj}{$ObjType}{$id}{folder}) {
					my $folderId = $main::MD->{$Proj}{$ObjType}{$id}{folder};
					if (exists $namedFolders->{$folderId}) { #item folder was already defined
						$folderPtr = $namedFolders->{$folderId};
					} elsif (exists $main::MD->{$Proj}{folder}{$folderId}) {
						my @@folders = &getParentFolders($folderId,$Proj); #returns at least itself - folderId
						foreach my $FID (@@folders) {	#deepest folder is not defined, search whole path
							$folderPtr = \$$folderPtr->{$FID};
							if (!ref($$folderPtr->{'~name'})) {
								$$folderPtr->{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$FID}{name}, "Object ~$FID", $lang);
								$$folderPtr->{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$FID}{description}, '', $lang);
								$$folderPtr->{'~content'} = $cntnt ? $main::MD->{$Proj}{folder}{$FID}{type} : ''; #no content
								$namedFolders->{$FID} = $folderPtr; #store pointer to folder
							}
						}
					} else {
						Bearlib::WriteLog("Item ($id) uses missing folder ($folderId), will be placed into root folder instead","GetMetadataList(...)",2) if ($Const::LogLevel>1);
					}
				}
				$$folderPtr->{$id}{'name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object ~$id", $lang);
				$$folderPtr->{$id}{'desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				$$folderPtr->{$id}{'rights'} = $main::MD->{$Proj}{$ObjType}{$id}{rights} if $ObjType eq 'urole'; #export predefined rights
			}
			#store localozation 4 root folder
			$m->{$AFID}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{name}, "folder ~$AFID", $lang);
			$m->{$AFID}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{description}, '', $lang);
			$m->{$AFID}{'~content'} = $cntnt ? $main::MD->{$Proj}{folder}{$AFID}{type} : ''; #no content
		}
	}
	return $m
}

sub getParentFolders {
my ($FID,$Proj) = @@_; #source Folder ID, project
return exists $main::MD->{$Proj}{folder}{$FID} && defined $main::MD->{$Proj}{folder}{$FID}{parent} ? (&getParentFolders($main::MD->{$Proj}{folder}{$FID}{parent},$Proj),$FID) : (); #search 4 parent folder if defined
}

#---------------------------------------

sub NewID {	#returns unique ID
	my $i;
	$i=Bearlib::IDGen();
	Bearlib::WriteLog('New ID',$i,4) if ($Const::LogLevel>3);
	return $i
}

#---------------------------------------

sub SaveMData {	# save one object
	my $class=shift;
	my $Obj=shift;	#object to save
	my $Rewrit=shift;	#force rewrite
	my $Path=shift;	#path (under $Cache::MDataDir, included Project Name) where object will be saved

	return Bearlib::SaveMData($Obj,$Rewrit,$Path);
}

#---------------------------------------

sub DropMData {	# drop specified object from metadata
	my $class=shift;
	my $proj=shift;	#project
	my $id=shift;	#object ID to drop

	return Bearlib::DropMData($proj,$id);
}

#---------------------------------------

sub SaveUserPref {	# save one object
	my $class=shift;
	my $Obj=shift;	#object to save
	my $User=shift; #user name from apache
	my $Path=shift;	#path (under $Cache::MDataDir, included Project Name) where object will be saved

	return Bearlib::SaveUserPref($Obj,$User,$Path);
}

#---------------------------------------

sub LoadUserPref {
	my $class=shift;
	my $User=shift;
	my $Path=shift;	#path

	return Bearlib::LoadUserPref($User,$Path);
}

#---------------------------------------

sub GetUserPref {
	my $class=shift;
	my $User=shift;
	my $Project=shift;
	my $Item=shift;

	return Bearlib::GetUserPref($User,$Project,$Item);
}

#---------------------------------------

sub PrepareSQL {	# returns hash containing SQL for specific report
	my ($class,$ID) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Prepare SQL Request',"$ID",4) if ($Const::LogLevel>3);
	return SQLGen::PrepareSQL($ID)
}

#---------------------------------------

sub GetResultName {	# returns report as hash with localized names of the attribute elements already substituted
	my ($class,$ID,$lang) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Result Request',"GetResultName($ID)",4) if ($Const::LogLevel>3);
	return &Cache::RCache2XTabName($ID,$lang)
}

#---------------------------------------

sub GetResultWeb {	# returns report as hash with localized names of the attribute elements already substituted
	my ($class,$ID,$lang) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Result Request',"GetResultWeb($ID)",4) if ($Const::LogLevel>3);
	return &Cache::RCache2XTabWeb($ID,$lang)
}

#---------------------------------------

sub GetResultId {	# returns report as hash containing IDs of the attributes
	my ($class,$ID) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Result Request',"GetResultId($ID)",4) if ($Const::LogLevel>3);
	return &Cache::RCache2XTabId($ID)
}

#---------------------------------------

sub ModifyReport {	# modify specific report 
	my ($class,$ID,$user,$modification,$lang) = @@_;	# ID of the original report, metadata of the modyfication
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Report Modification Request', $ID, 4) if ($Const::LogLevel>3);
	return &Bearlib::ModifyReport($ID,$user,$modification,$lang);	# returns ID of the new report
}

#---------------------------------------

sub GetAttrElements {	# returns array of array of elements for specific attribute
	my ($class, $Lang, $Filter, $Sort, $SortOrd, $attr, $fact, $limit) = @@_;	# language, filter expression, sort index, sort order, attribute (in form attr.role~display), fact for join, max number of elements returned
	                                                         	# sort index = 0 ... sort by ID
	                                                         	# sort index = 1 ... sort by description
	                                                         	# sort index = [^01] ... don't sort
	                                                         	# sort order = 'A' ... ascending
	                                                         	# sort order = 'D' ... ascending
	                                                         	# sort order = [^AD] ... don't sort
	return &Cache::GetAttrElements($Lang, $Filter, $Sort, $SortOrd, $attr, $fact, $limit)
}


#---------------------------------------

sub GetObjectType {
	my ($class,$ID) = @@_;
	return (exists $main::MDi->{$ID}) ? $main::MDi->{$ID}->{type} : undef
}

#---------------------------------------
sub GetAccessTreeDefinition {
	my $class = shift;
	my $lang = lc( shift );
	my $user = shift;
	my $rtrn;
	$rtrn = Acl::GetTreeDefinition($lang);
	foreach my $fid (keys %{$rtrn}) {
		if ($rtrn->{$fid}{'~content'} eq "roles") {
			foreach my $p (GetProjects(undef,$user)) {
				$rtrn->{$fid}{$p} = Bearlib::GetAllLocalizedRights($lang,$p);
				$rtrn->{$fid}{$p}{'~name'} = $p;
				$rtrn->{$fid}{$p}{'~content'} = 'roles';
			}
		}
	}
	return $rtrn
}

#---------------------------------------
sub GetUserDetail {	# in: user ID; out: HASH
	return &Acl::GetUserDetail($_[1])
}

#---------------------------------------
sub GetGroupDetail {	# in: group ID; out: HASH
	return &Acl::GetGroupDetail($_[1])
}

#---------------------------------------
sub GetLocalizedUsersList {	#in: lang, user's ids; out: localized names ARRAY
	my $class = shift;
	return &Acl::GetLocalizedUsersList(@@_)
}

#---------------------------------------
sub GetLocalizedGroupsList {	#in: lang, group's ids; out: localized names ARRAY
	my $class = shift;
	return &Acl::GetLocalizedGroupsList(@@_)
}

#---------------------------------------
sub GetRoles {	#in: project || undef,item id; out: HASH
my ($class,$project,$ID) = @@_;
	Bearlib::WriteLog('Roles Request',"GetRoles( [$project|$ID] )",4) if ($Const::LogLevel>3);
	$project = GetProjectName($class,$ID) if $ID;
	return $main::MD->{$project}{urole}
}

#---------------------------------------
sub GetRolesList {	#in: project || undef,item id; out: ids ARRAY
my ($class,$project,$ID) = @@_;
	Bearlib::WriteLog('Roles Request',"GetRoles( [$project|$ID] )",4) if ($Const::LogLevel>3);
	$project = GetProjectName($class,$ID) if $ID;
	return keys %{$main::MD->{$project}{urole}}
}

#---------------------------------------
sub GetAllLocalizedRights {	# lang, project || undef,item id; out: HASH
my ($class,$use_lang,$project,$ID) = @@_;
	Bearlib::WriteLog('Rights Request',"GetAllLocalizedRights( [$project|$ID] )",4) if ($Const::LogLevel>3);
	$project = GetProjectName($class,$ID) if $ID;
	return &Bearlib::GetAllLocalizedRights($use_lang,$project)
}

#---------------------------------------
sub GetLocalizedRights {	# lang, item id, roles ids; out: HASH
my ($class,$use_lang,$project,$ID,@@ids) = @@_;
	Bearlib::WriteLog('Rights Request',"GetLocalizedRights(@@ids)",4) if ($Const::LogLevel>3);
	$project = GetProjectName($class,$ID) if $ID;
	return Bearlib::GetLocalizedRights($use_lang,$project,@@ids)
}

#---------------------------------------
sub GetLocalizedRolesList { #in: project || undef,item id; out: localized names ARRAY
my ($class,$use_lang,$project,$ID) = @@_;
	$project = GetProjectName($class,$ID) if $ID;
	return Bearlib::GetLocalizedRolesList($use_lang,$project)
}

#---------------------------------------

sub Get3dReport {	# returns hash of report
	my ($class,$ID) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	Bearlib::WriteLog('Result Request',"Get3DReport($ID)",4) if ($Const::LogLevel>3);
	
	return &Cache::Report3d($ID)
}


#---------------------------------------

sub Get3dData {	# returns hash(mdata with id)  array(data) 
	my ($class,$reportID) = @@_;
#	return if ($main::MDi->{$reportID}->{report_type} ne 'graph3d');
	Bearlib::WriteLog('Result Request',"Get3dData($reportID)",4) if ($Const::LogLevel>3);

	return &Cache::RCache2data3d($reportID)
}

#---------------------------------------

sub Get3dMap {	# returns hash of mdata with name
	my ($class,$mdata,$lang) = @@_;
#	return if ($main::MDi->{$ID}->{type} ne 'graph3d');
#	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);

	return &Cache::Mdata2map3d($mdata,$lang)
}


#----------------------------------

sub GetDynamicParamsInReport {
	my ($class,$ID,$lang,$user) = @@_;
	Bearlib::WriteLog('Get dynamic params in report request',"GetDynamicParamsInReport($ID,$lang,$user)",4) if ($Const::LogLevel>3);
	return &Bearlib::GetDynamicParamsInReport($ID,$lang,$user)
}
	
#---------------------------------------

sub GetDerivatedReports {
	my ($class,$user,$proj,$lang) = @@_;
	Bearlib::WriteLog('Modified reports request',"getDerivatedReports($user,$proj)",4) if ($Const::LogLevel>3);
	return &Bearlib::GetDerivatedReports("$Const::MDataDir$proj/PrivateMD/$user/Reports","xml",$lang,$proj)
}

#---------------------------------------

sub RemoveModifiedReport {	#temporarily !!!
my ($class,$proj,$itemId,$user) = @@_;
	unlink("$Const::MDataDir$proj/PrivateMD/$user/Reports/$itemId.xml");
}

#---------------------------------------

sub SetDynamicParams {
my ($class,$user,$rid,$lang,$param) = @@_;
	Bearlib::WriteLog('Set dynamic params request',"SetDynamicParams($user,$rid)",4) if ($Const::LogLevel>3);
	return &Bearlib::SetDynamicParams($user,$rid,$lang,$param)
}

#---------------------------------------

sub SubstituteParamsInReport {
my ($class,$dynamics,$user,$lang,$id) = @@_;
	Bearlib::WriteLog('Substitution request',"SubstituteParamsInReport($user,$lang,$id)",4)if ($Const::LogLevel>3);
	return &Bearlib::SubstituteParamsInReport($dynamics,$id,$user,$lang)
}

#---------------------------------------

sub GetSQL {
my ($class,$id) = @@_;
Bearlib::WriteLog('GetSQL request',"($id)",4)if ($Const::LogLevel>3);
return "return of function SOAP->GetSQL not implemented (Bear.pm line 516 at 5th. february,2004; 10:43)"
}

#---------------------------------------


sub GetRoleTabs { #returns concatenated string of all forbidden tabs in each role assigned to user or 0
my ($class,$user,$project) = @@_;
Bearlib::WriteLog('GetRoleTabs',"($user,$project)",4)if ($Const::LogLevel>3);
return &Bearlib::GetRoleTabs($project,$user)
}

#---------------------------------------
sub CheckAccess { #returns: 0 no access to tab, 1 no access to object, 2 access to object (access granted at all)
my ($class,$tab,$user,$project,$id,@@rght) = @@_;
my $rtrn = 0;
$rtrn += &Bearlib::CheckAccess2Tab($tab,$user,$project) if ($tab && $user);	#0 no access to tab, 1 access allowed
$rtrn += &Bearlib::CheckAccess2Object($user,$project,$id,@@rght) if $rtrn && $id && @@rght > 0; #0 no access to object, 1 access granted
Bearlib::WriteLog("Check access with result '$rtrn'","($user,$project,$tab,$id,@@rght)",3)if ($Const::LogLevel>1);
return $rtrn 
}

#---------------------------------------
sub GetSqlAccess {
my ($class,$user,$project) = @@_;
Bearlib::WriteLog("Check sql access","($user)",4) if $Const::LogLevel>1;
return &Bearlib::GetSqlAccess($user,$project)
}

#---------------------------------------
1
__END__

=head1 NAME

Bear - class to implement API for beard

=head1 SYNOPSIS

=head2 client site usage

 eval "use SOAP::Lite +autodispatch => 
 	uri => 'Bear', 
 	proxy => ['http://$bearHost:$bearPort/', 
 	options => {compress_threshold => $compress_threshold}]; 
 	1"
 or ( &ErrorDie("ERROR in eval of \"use SOAP::Lite ...\".") );
 
 my $serverVerbName="SOAP Server http://$bearHost:$bearPort/";
 if (! eval "SOAP::Lite->self->fault") {
 	ErrorDie('ERROR: '.$serverVerbName.' not responding<br><form><input type="submit" name="Refresh" value="Refresh" /></form>');
 }

=head2 class methods

 @@names = SOAP->GetProjects($user);		# returns list of all project names available for current user
 $pr = SOAP->GetProjectName($ID);	# returns name of project containing object of specific ID
 $m=SOAP->GetMetadataList($ProjectName, $ObjectType, $User, $DescrLimit);      # returns list of $ObjType objects with their names and shortened description

 $obj = SOAP->GetMetadata($ID);
 $r=SOAP->SaveMData($Obj, $Rewrit, $Path);
 SOAP->DropMData($ProjectName, $ID);
 
 $ObjPref = SOAP->LoadUserPref($User);
 $r=SOAP->SaveUserPref($ObjPref,$User);

 @@suc = SOAP->GetObjSuccessors($ObjID);	# returns list of objects depending on specific object
 @@suc = SOAP->GetObjPredecessors($ObjID);	# returns list of objects on which specific object depends
 $t = SOAP->HasPath('MDga', $ObjID1, $ObjID2);	# returns true if path from $ObjID1 to $ObjID2 exists
 
 SOAP->GetResult($ID);
 ((id1,desc1), (id2,desc2), ...) = SOAP->GetAttrElements($Lang, $Filter, $Sort, $SortOrd, @@attr)	#  returns elements for specific attribute
                                                                                                	# language, filter expression, sort index, sort order, list of attributes (in form attr.role~display)
 
 $id=SOAP->NewID();	# returns unique ID
 
 $obj = SOAP->GetDebug('MD', $ID);	# returns MD metadata for project containing $ID object
 $obj = SOAP->GetDebug('MDi');
 $obj = SOAP->GetDebug('RCache');
 $obj = SOAP->GetDebug('SCache');
 $obj = SOAP->GetDebug('Lookup', $ID);	# returns lookup cache for specific $ID (should be ID of attribute)
 $obj = SOAP->GetDebug('UserPref');
 
=head2 Log Levels
 ($LogLevel defined on server side)
 0 ... no logging
 1 ... Error & Start/Stop
 2 ... Warning
 3 ... Info
 4 ... Trace
 5 ... Trace Details

=head1 DESCRIPTION

=cut

@


1.113
log
@N:M implementation, foundation for slowly changing dimensions
@
text
@a186 1
print "$lang===== $f ===== $fn ===== $t ===== $tn ===== $fr,$tr =====\n";
a190 2
use Data::Dumper;
print Dumper($ret);
d412 1
a412 1
	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);
d421 1
a421 1
	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);
d430 1
a430 1
	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);
d549 1
a549 1
	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);
d560 1
a560 1
	Bearlib::WriteLog('Result Request',"GetResult($reportID)",4) if ($Const::LogLevel>3);
@


1.112
log
@code improvments
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.111 2004/04/14 09:06:43 jiri_schmid Exp $
a180 1
			$f = Bearlib::LocalizedObj(${$main::MDi->{$f}->{ptr}}->{name}, $f, $lang, $Const::DefaultLanguage);
d182 6
a187 1
			$t = Bearlib::LocalizedObj(${$main::MDi->{$t}->{ptr}}->{name}, $t, $lang, $Const::DefaultLanguage);
d189 2
a190 1
			$ret->{$f}->{$t}->{n}++;
d192 2
@


1.111
log
@universal custom folders system implemented 4 facts
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.110 2004/04/13 12:42:37 michald Exp $
d288 1
a288 1
		} elsif ($ObjType eq 'fact') { #return list of localized and grouped facts
d291 2
a292 1
			foreach my $id (keys %{$main::MD->{$Proj}{fact}}) {
d295 2
a296 2
				if (exists $main::MD->{$Proj}{fact}{$id}{folder}) {
					my $folderId = $main::MD->{$Proj}{fact}{$id}{folder};
d299 1
a299 1
					} else {
d310 2
a311 6
					}
				} else {
					if (!ref($$folderPtr->{'~name'})) { #item is in root folder
						$$folderPtr->{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{name}, "folder ~$AFID", $lang);
						$$folderPtr->{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$AFID}{description}, '', $lang);
						$$folderPtr->{'~content'} = $cntnt ? $main::MD->{$Proj}{folder}{$AFID}{type} : ''; #no content
d316 1
d318 1
a318 9
		} else { #return folder with items and subfolders (not implemented yet)
			my $cntnt = 0; #specifices if folder has content
			foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
				next if $main::MDi->{$id}{path} =~ /PrivateMD/;
				$cntnt++;
				$m->{$AFID}{$id}{'name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object ~$id", $lang);
				$m->{$AFID}{$id}{'desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				$m->{$AFID}{$id}{'rights'} = $main::MD->{$Proj}{$ObjType}{$id}{rights} if $ObjType eq 'urole'; #export predefined rights
			}
d329 1
a329 1
return defined $main::MD->{$Proj}{folder}{$FID}{parent} ? (&getParentFolders($main::MD->{$Proj}{folder}{$FID}{parent},$Proj),$FID) : (); #search 4 parent folder if defined
@


1.110
log
@foundation for N:M relations
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.109 2004/04/09 07:04:39 michald Exp $
d281 4
a284 3
			foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
				$m->{$id}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "folder by: $id", $lang);
				$m->{$id}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
d288 32
d337 5
@


1.109
log
@Directed Graph visualization for debugging purposes implemented - need to install GraphViz (look at README)
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.108 2004/03/21 07:01:13 michald Exp $
d144 1
a144 1
	my ($class,$var,$ID,$dataSrc) = @@_;
d163 1
a163 1
		my @@ret;
d168 2
a169 3
			next if scalar @@{$main::MDg->{$pn}->{$dataSrc}->get_attribute('path',$f,$t)} !=2;
			push @@ret, $f;
			push @@ret, $t;
d171 1
a171 1
		return @@ret
d177 2
a178 5
		return @@{$main::MDgaV->{$pn}};
		
		my @@e = $main::MDga->{$pn}->edges();
		my @@ret;
		my $v;
d180 4
a183 2
			my $f = shift @@e; $f =~ s/\..*$//;
			my $t = shift @@e; $t =~ s/\..*$//;
d185 1
a185 1
			$v->{$f}->{$t}++;
d187 1
a187 7
		foreach my $f (keys %{$v}) {
			foreach my $t (keys %{$v->{$f}}) {
				push @@ret, $f;
				push @@ret, $t;
			}
		}
		return @@ret
d193 12
a204 1
		return $main::MDgo->{$pn}->edges();
a209 1
#		return $Cache::Lookup->{$ID};
@


1.108
log
@slight modification of the Metric Filter Intersection MD presentation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.107 2004/03/11 07:58:59 michald Exp $
d75 8
d144 1
a144 1
	my ($class,$var,$ID) = @@_;
d160 13
d176 20
d199 3
a663 1
 $obj = SOAP->GetDebug('MDn');
@


1.107
log
@initial implementation of caches in the local DB
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.106 2004/03/10 15:14:18 jiri_schmid Exp $
d20 3
a33 6
	sleep 1;
	return $s." ($$)";
}

sub echoX { 
	my ($class, $s) = @@_;
@


1.106
log
@object tree creation implemented as full recursive
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.105 2004/03/05 11:37:09 jiri_schmid Exp $
d166 2
a167 1
		return $Cache::Lookup->{$ID};
d636 1
@


1.105
log
@recursive non-attr objects tree creation implemented, order attr added into folder def.
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.104 2004/03/02 13:00:58 jiri_schmid Exp $
d197 1
a197 1
	my ($class, $Proj, $ObjType, $User, $lang, $activeFolderId) = @@_;
d207 1
d209 9
a217 1
				my $group = (exists $main::MD->{$Proj}{attr}{$id}{group}) ? $main::MD->{$Proj}{attr}{$id}{group} : '~group'; #when no group is defined, the non-viewable pseudo group is set to keep structure
d219 11
a229 14
				if (!ref($m->{$group}{display})) {
					$m->{$group}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{name}, "Object ~$group", $lang);
					$m->{$group}{display}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{description}, "Object #$group", $lang);
				};
				my $role = ($id =~ /\.(.*)$/) ? $1 : '~role';	#when no rule is defined, the non-viewable pseudo rule is set to keep structure
				if (!ref($m->{$group}{$role}{display})) {
					$m->{$group}{$role}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{role}{$role}{name}, "Object ~$id", $lang);
					$m->{$group}{$role}{display}{description} = Bearlib::LocalizedObj($main::MD{$Proj}{group}{$group}{role}{$role}{description}, "Object #$id", $lang);				
				};
				$m->{$group}{$role}{$id}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
				$m->{$group}{$role}{$id}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				foreach (keys %{$main::MD->{$Proj}{attr}{$id}{display}}) {
					$m->{$group}{$role}{$id}{display}{$_}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{name}, "Object ~$_", $lang);
					$m->{$group}{$role}{$id}{display}{$_}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{description}, '', $lang);
d232 4
d238 2
a239 2
				$m->{$id}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object ~$id", $lang);
				$m->{$id}{'~description'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
d243 2
a244 1
		} else { #return folder with items or subfolders (not implemented yet)
d247 4
a250 3
				$m->{$activeFolderId}{$id}{'name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object ~$id", $lang);
				$m->{$activeFolderId}{$id}{'desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				$m->{$activeFolderId}{$id}{'rights'} = $main::MD->{$Proj}{$ObjType}{$id}{rights} if $ObjType eq 'urole'; #export predefined rights
d252 3
a254 3
			$m->{$activeFolderId}{'~name'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$activeFolderId}{name}, "Object ~$activeFolderId", $lang);
			$m->{$activeFolderId}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$Proj}{folder}{$activeFolderId}{description}, '', $lang);
			$m->{$activeFolderId}{'~content'} = $main::MD->{$Proj}{folder}{$activeFolderId}{type};
@


1.104
log
@changed id handling 4 access tree
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.103 2004/02/25 16:05:07 jiri_schmid Exp $
d197 1
a197 1
	my ($class, $Proj, $ObjType, $User, $lang, $DescrLimit) = @@_;
d199 1
a199 1
	if ($DescrLimit) { $DescrLimit=$DescrLimit-3 } else {$DescrLimit=$Const::DescrLPadLimit-3};	# lpad limit dor description field, default is 80 chars
d206 2
a207 2
		foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
			if ($ObjType eq 'attr') {
d225 10
a234 1
			} else {
d236 3
a238 4
				$m->{$id}->{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object ~$id", $lang);
				$m->{$id}->{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
				$m->{$id}->{rights} = $main::MD->{$Proj}{$ObjType}{$id}{rights} if $ObjType eq 'urole'; #export predefined rights
				$m->{$id}->{type} = $main::MD->{$Proj}{$ObjType}{$id}{type} if $ObjType eq 'folder'; #export predefined rights
d240 3
@


1.103
log
@fixed rights logic and folder XML definition files are specific for each project now
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.102 2004/02/24 10:21:48 jiri_schmid Exp $
d67 2
a68 1
			push @@pr, $pn; $nn .= $pn.',';
d372 8
a379 5
	foreach my $p (GetProjects(undef,$user)) {
		$rtrn->{roles}{$p} = Bearlib::GetAllLocalizedRights($lang,$p);
		$rtrn->{roles}{$p}{'~name'} = $p;
		$rtrn->{roles}{$p}{'~content'} = 'role';
		$rtrn->{roles}{$p}{'~desc'} = Bearlib::LocalizedObj($main::MD->{$p}{folder}{_ROLES_}{description},"? $_",$lang,'en') if exists $main::MD->{$p}{folder}{_ROLES_}{description};
@


1.102
log
@prefer access and rights logic changed
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.101 2004/02/23 12:09:27 jiri_schmid Exp $
d229 1
d534 1
a534 1
$rtrn += &Bearlib::CheckAccess2Object($user,$project,$id,@@rght) if $rtrn && @@rght > 0; #0 no access to object, 1 access granted
@


1.101
log
@fixed access tree creation depending on ACL
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.100 2004/02/19 13:26:06 jiri_schmid Exp $
d539 7
@


1.100
log
@edit page rights fixies and improvments
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.99 2004/02/18 16:19:16 jiri_schmid Exp $
d70 1
a70 1
	if ($nn) { chop $nn; $nn = "Projects ($nn) have no ACL" } else { $nn = "All projects have set ACL" };
d370 1
a370 1
	foreach my $p (GetProjects($user)) {
@


1.99
log
@rights implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.98 2004/02/13 17:09:40 jiri_schmid Exp $
d507 1
a507 1
	Bearlib::WriteLog('Substitution request',"SubstituteParamsInReport($user,$lang,$id)")if ($Const::LogLevel>3);
d515 1
a515 1
Bearlib::WriteLog('GetSQL request',"($id)")if ($Const::LogLevel>3);
d524 1
a524 1
Bearlib::WriteLog('GetRoleTabs',"($user,$project)")if ($Const::LogLevel>3);
a530 1
Bearlib::WriteLog('CheckAccess',"($user,$project,$tab,$id,@@rght)")if ($Const::LogLevel>3);
d534 1
@


1.98
log
@major tabs control implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.97 2004/02/12 16:24:26 jiri_schmid Exp $
a528 1

d530 2
a531 2
my ($class,$tab,$user,$project) = @@_;
Bearlib::WriteLog('CheckAccess',"($user,$project,$tab)")if ($Const::LogLevel>3);
d533 2
a534 2
$rtrn += &Bearlib::CheckAccess2Tab($user,$project,$tab) if ($tab && $user && $project);	#0 no access to tab, 1 access allowed
#$rtrn += &Bearlib::CheckAccess2Object($user,$project) if $rtrn; #0 no access to object, 1 access granted
a537 1

@


1.97
log
@prototype of tabs hidding implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.96 2004/02/09 14:26:33 jiri_schmid Exp $
d522 1
a522 1
sub getRoleTabs {
d524 2
a525 2
Bearlib::WriteLog('getRoleTabs',"($user,$project)")if ($Const::LogLevel>3);
return $main::MD->{$project}{urole}{"${project}_all"}{tabs}
d530 11
@


1.96
log
@object tree remembers opened directory till webbrowser restarts
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.95 2004/02/05 09:43:20 jiri_schmid Exp $
d521 9
@


1.95
log
@prototype of GetSQL implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.94 2004/02/02 09:14:07 michald Exp $
d485 1
a485 1
	return &Bearlib::GetDerivatedReports("$Const::MDataDir$proj/PrivateMD/$user/Reports","xml",$lang)
@


1.94
log
@Make independent project specific spaces in MDk, MDl
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.93 2004/01/12 13:42:03 michald Exp $
a504 1

d512 9
@


1.93
log
@add limit to list of the elements
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.92 2004/01/09 12:42:50 jiri_schmid Exp $
d31 6
a144 2
	} elsif ($var eq 'MDn') {
		return $main::MDn;
d146 2
a147 1
		return $main::MDk;
d149 2
a150 1
		return $main::MDl;
@


1.92
log
@dynamic param code imrpovment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.91 2004/01/06 08:17:37 jiri_schmid Exp $
a16 1
use SOAP::Transport::HTTP;
d339 1
a339 1
	my ($class, $Lang, $Filter, $Sort, $SortOrd, $attr, $fact) = @@_;	# language, filter expression, sort index, sort order, attribute (in form attr.role~display), fact for join
d346 1
a346 1
	return &Cache::GetAttrElements($Lang, $Filter, $Sort, $SortOrd, $attr, $fact)
@


1.91
log
@dynamic params implemented into grid
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.90 2003/12/18 12:59:54 jiri_schmid Exp $
d493 1
a493 1
my ($class,$user,$rid,$dynamic) = @@_;
d495 1
a495 1
	return &Bearlib::SetDynamicParams($user,$rid,$dynamic)
@


1.90
log
@defining of dynamic params within use rules implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.89 2003/12/16 13:44:24 jiri_schmid Exp $
d500 8
@


1.89
log
@setting and checking values of params agains memory
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.88 2003/12/12 12:12:16 jiri_schmid Exp $
d493 3
a495 3
my ($class,$user,$rid,$values) = @@_;
	Bearlib::WriteLog('Set dynamic params request',"SetDynamicParams($user,$rid,$values)",4) if ($Const::LogLevel>3);
	return &Bearlib::SetDynamicParams($user,$rid,$values)
@


1.88
log
@found a fixed bug manipulating dynamic params in grid
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.87 2003/12/11 16:20:07 jiri_schmid Exp $
d470 3
a472 3
	my ($class,$ID,$lang) = @@_;
	Bearlib::WriteLog('Get dynamic params in report request',"GetDynamicParamsInReport($ID,$lang)",4) if ($Const::LogLevel>3);
	return &Bearlib::GetDynamicParamsInReport($ID,$lang)
d476 1
d484 1
d491 9
@


1.87
log
@last pivot rule implenmeted, removing modified reports enhanced
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.86 2003/12/10 15:54:31 jiri_schmid Exp $
d175 2
a176 1
	return &Bearlib::GetInvolvedReportMetadata($ID,$class);
d467 1
a467 1
#---------------------------------------
d469 1
a469 1
sub dynamicReport {
d471 2
a472 44
	my $rtrn;
	my $proj = &GetProjectName(undef,$ID);
	my $rprt = &GetInvolvedReportMetadata($class,$ID);

	$rtrn->{object} = {};
	$rtrn->{filter} = {};

	foreach my $key (keys %{$rprt->{var_def}}) {
		next if $key eq 'orig_id';
		if ($rprt->{report_type} eq 'grid') {
			foreach (@@{$rprt->{var_def}{$key}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = 1
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		} elsif ($rprt->{report_type} eq 'graph3d') {
			foreach (@@{$rprt->{var_def}{$key}{items}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = 1
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		}
	}

	while ($rprt->{filter_def}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$rtrn->{filter}{$1} = 1
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			&paramsInMetric($1,$rtrn->{filter});
		}
	}

	delete $rtrn->{object}{metrics}; # remove recursive break for analyzing grid and graph3d
	delete $rtrn->{filter}{metrics}; # remove recursive break for analyzing filter

#use Time::HiRes;
#my $stime = Time::HiRes::time();
#print sprintf("Response time: %.5f s\n", Time::HiRes::time()-$stime);

	return $rtrn
d474 1
a474 18

#-----

sub paramsInMetric {
	my ($metricId, $definitions) = (shift,shift);
	my $proj = &GetProjectName(undef,$metricId);
	my $obj = GetMetadata(undef,$metricId);	#undef -> do not log call
	$definitions->{metrics}{$metricId} = 1;	#avoid recursive deadlock in metrics
	while ($obj->{metric}{$metricId}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$definitions->{$1} = 1
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			next if exists $definitions->{metrics}{$1};
			&paramsInMetric($1,$definitions);
		}
	}
}

d476 1
a476 1
sub getDerivatedReports {
@


1.86
log
@code and functionality improvments for pivoting and modified reports page
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.85 2003/12/08 14:58:37 jiri_schmid Exp $
d541 6
a547 1

@


1.85
log
@reading of privatemd implemented, derivated reports are no longer in tree generated
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.84 2003/11/28 13:03:22 jiri_schmid Exp $
d330 1
a330 1
	my ($class,$ID,$user,$modification) = @@_;	# ID of the original report, metadata of the modyfication
d333 1
a333 1
	return &Bearlib::ModifyReport($ID,$user,$modification);	# returns ID of the new report
d535 1
a535 1
	my ($class,$user,$proj) = @@_;
d537 1
a537 1
	return &Bearlib::GetDerivatedReports("$Const::MDataDir$proj/PrivateMD/$user/Reports","xml")
@


1.84
log
@MD5 hashing implemented, sorting menus implemented etc...
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.83 2003/11/28 07:06:06 michald Exp $
d219 1
d534 5
d540 1
@


1.83
log
@report/metric filter join
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.82 2003/11/27 16:41:09 jiri_schmid Exp $
d305 2
d308 7
a314 6
	#	my $rtrn = &Cache::RCache2XTabName($ID,$lang);
	#	use Data::Dumper;
	#	print Dumper($rtrn);
	#	return $rtrn
	
	return &Cache::RCache2XTabName($ID,$lang)
@


1.82
log
@something like drill implemeted
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.81 2003/11/27 08:52:44 jiri_schmid Exp $
d326 1
a326 1
	my ($class,$ID,$user,$modification) = @@_;
d329 1
a329 1
	return &Bearlib::ModifyReport($ID,$user,$modification);
@


1.81
log
@1.step for drilling implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.80 2003/11/25 10:07:13 michald Exp $
a20 1
use Clone qw(clone);
d326 1
a326 1
	my ($class,$ID,$modification) = @@_;
d329 1
a329 1
	return &Bearlib::ModifyReport($ID,$modification)
@


1.80
log
@Project ACL implementation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.79 2003/11/22 18:38:26 michald Exp $
a9 1
use Storable;	#needed for creating independent copy of hash
d176 1
a176 43

	my $obj = GetMetadata(undef,$ID);	#undef -> do not log call
	my $rtrn = &Storable::dclone($obj->{report}{$ID});

	#handle main definition object
	my $delete = (ref $rtrn->{var_def} eq 'HASH') ? undef : delete $rtrn->{var_def};
	if ($delete) {
		my $hlp = GetMetadata(undef,$delete,1);
		if ($rtrn->{report_type} eq 'grid') {
			foreach ('page','col','row','metric'){
				$rtrn->{var_def}{$_} = $hlp->{grid}{$delete}{$_};
			}
		} elsif ($rtrn->{report_type} eq 'graph3d') {
			foreach ('x','z','y','pages','diameter','shape','color','transparency'){
				$rtrn->{var_def}{$_} = $hlp->{graph3d}{$delete}{$_};
			}
		}
		$rtrn->{var_def}{orig_id} = $delete;
	};
	
	#handle filter
	$delete = (ref $rtrn->{filter_def} eq 'HASH') ? undef : delete $rtrn->{filter_def};
	if ($delete) {
		my $hlp = GetMetadata(undef,$delete);
		$rtrn->{filter_def}{expr} = $hlp->{filter}{$delete}{expr};
		$rtrn->{filter_def}{orig_id} = $delete;
	};

	#handle filter
	$delete = (ref $rtrn->{format_def} eq 'HASH') ? undef : delete $rtrn->{format_def};
	if ($delete) {
		my $hlp = GetMetadata(undef,$delete);
		my $type = GetObjectType($class,$delete);
		foreach ('form','type') {
			$rtrn->{format_def}{$_} = $hlp->{$type}{$delete}{$_};
		}
		$rtrn->{format_def}{header} = $hlp->{$type}{$delete}{header} if $type eq 'format';
		$rtrn->{format_def}{orig_id} = $delete;
	};
	
	main::WriteLog('Involved Report Definition Metadata Request',"GetInvolvedReportMetadata($ID)",4) if (($main::LogLevel>3)&&($class));	#don't log if called localy
	
	return $rtrn
a178 2


d205 1
a205 1
					$m->{$group}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{name}, "Object #$group", $lang);
d210 1
a210 1
					$m->{$group}{$role}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{role}{$role}{name}, "Object #$id", $lang);
d216 1
a216 1
					$m->{$group}{$role}{$id}{display}{$_}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{name}, "Object #$_", $lang);
d220 1
a220 1
				$m->{$id}->{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
d327 1
a327 1
	my ($class,$ID) = @@_;
d330 1
a330 1
	return &Cache::RCache2XTabId($ID)
@


1.79
log
@fix undefined call to decode in case attr descr is NULL
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.78 2003/11/20 09:42:50 michald Exp $
a24 64
sub dynamicReport {
	my ($class,$ID,$lang) = @@_;
	my $rtrn;
	my $proj = &GetProjectName(undef,$ID);
	my $rprt = &GetInvolvedReportMetadata($class,$ID);

	$rtrn->{object} = {};
	$rtrn->{filter} = {};

	foreach my $key (keys %{$rprt->{var_def}}) {
		next if $key eq 'orig_id';
		if ($rprt->{report_type} eq 'grid') {
			foreach (@@{$rprt->{var_def}{$key}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = 1
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		} elsif ($rprt->{report_type} eq 'graph3d') {
			foreach (@@{$rprt->{var_def}{$key}{items}}) {
				if (exists $main::MD->{$proj}{param}{$_}) {
					$rtrn->{object}{$_} = 1
				} elsif (exists $main::MD->{$proj}{metric}{$_}) {
					&paramsInMetric($_,$rtrn->{object});
				}
			}
		}
	}

	while ($rprt->{filter_def}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$rtrn->{filter}{$1} = 1
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			&paramsInMetric($1,$rtrn->{filter});
		}
	}

	delete $rtrn->{object}{metrics}; # remove recursive break for analyzing grid and graph3d
	delete $rtrn->{filter}{metrics}; # remove recursive break for analyzing filter

#use Time::HiRes;
#my $stime = Time::HiRes::time();
#print sprintf("Response time: %.5f s\n", Time::HiRes::time()-$stime);

	return $rtrn
}
#---------------------------------------
sub paramsInMetric {
	my ($metricId, $definitions) = (shift,shift);
	my $proj = &GetProjectName(undef,$metricId);
	my $obj = GetMetadata(undef,$metricId);	#undef -> do not log call
	$definitions->{metrics}{$metricId} = 1;	#avoid recursive deadlock in metrics
	while ($obj->{metric}{$metricId}{expr} =~ /\[(.*?)\]/g) {
		if (exists $main::MD->{$proj}{param}{$1}) {
			$definitions->{$1} = 1
		} elsif (exists $main::MD->{$proj}{metric}{$1}) {
			next if exists $definitions->{metrics}{$1};
			&paramsInMetric($1,$definitions);
		}
	}
}

#---------------------------------------
d54 16
a69 2
	Bearlib::WriteLog('Metadata Request',"GetProjects",4) if ($Const::LogLevel>3);
	return (keys %{$main::MD})
d374 1
a374 1
	Bearlib::WriteLog('Result Request',"GetResult($ID)",4) if ($Const::LogLevel>3);
d403 1
d406 1
a406 1
	foreach my $p (GetProjects()) {
d510 67
d603 1
a603 1
 @@names = SOAP->GetProjects();		# returns list of all available project names
@


1.78
log
@fix of LDM, cleanup of some obsolete files
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.77 2003/11/20 08:17:34 michald Exp $
d397 1
a397 1
sub GetResultName {	# returns hash and arrays of names
d412 1
a412 1
sub GetResultId {	# returns hash and arrays of ids
d419 8
@


1.77
log
@fix of LDM, cleanup of some obsolete files
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.76 2003/11/13 16:27:50 jiri_schmid Exp $
d286 1
a286 1
	my ($class,$Proj, $ObjType, $User, $lang, $DescrLimit) = @@_;
a292 2
#use Data::Dumper;

d294 24
a317 19
if (exists $main::MD->{$Proj}) {
	foreach my $id (keys %{$main::MD->{$Proj}{$ObjType}}) {
		if ($ObjType eq 'attr') {
			my $group = (exists $main::MD->{$Proj}{attr}{$id}{group}) ? $main::MD->{$Proj}{attr}{$id}{group} : '~group'; #when no group is defined, the non-viewable pseudo group is set to keep structure
			
			if (!ref($m->{$group}{display})) {
				$m->{$group}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{name}, "Object #$group", $lang);
				$m->{$group}{display}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{description}, "Object #$group", $lang);
			};
			my $role = ($id =~ /\.(.*)$/) ? $1 : '~role';	#when no rule is defined, the non-viewable pseudo rule is set to keep structure
			if (!ref($m->{$group}{$role}{display})) {
				$m->{$group}{$role}{display}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{group}{$group}{role}{$role}{name}, "Object #$id", $lang);
				$m->{$group}{$role}{display}{description} = Bearlib::LocalizedObj($main::MD{$Proj}{group}{$group}{role}{$role}{description}, "Object #$id", $lang);				
			};
			$m->{$group}{$role}{$id}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
			$m->{$group}{$role}{$id}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
			foreach (keys %{$main::MD->{$Proj}{attr}{$id}{display}}) {
				$m->{$group}{$role}{$id}{display}{$_}{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{name}, "Object #$_", $lang);
				$m->{$group}{$role}{$id}{display}{$_}{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{description}, '', $lang);
a318 4
		} else {
			$m->{$id}->{name} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
			$m->{$id}->{description} = Bearlib::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
			$m->{$id}->{rights} = $main::MD->{$Proj}{$ObjType}{$id}{rights} if $ObjType eq 'urole'; #export predefined rights
a320 4
#	use Data::Dumper;
#	print ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $ObjType\n";
#	print Dumper($m);
}
@


1.76
log
@fixed bugs and dynamicparam finder implemeted
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.75 2003/11/12 09:58:53 jiri_schmid Exp $
a18 1
#use Bear; #? what is that !!! (disabled by JS)?
@


1.75
log
@report generating - labeling changes
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.74 2003/11/11 14:03:18 jiri_schmid Exp $
d19 1
a19 1
use Bear;
d27 1
a27 1
	my ($class,$ID) = @@_;
d29 1
d32 3
d37 16
a52 2
		foreach (@@{$rprt->{var_def}{$key}}) {
			push(@@{$rtrn->{object}},$_) if &GetObjectType($class,$_) eq 'param';
d57 5
a61 2
		print &GetObjectType($class,$1);
		push(@@{$rtrn->{filter}},$1) if &GetObjectType($class,$1) eq 'param';
d64 7
d74 16
d229 1
a229 1
	my $obj = GetMetadata(undef,$ID,1);	#undef -> do not log call
d241 1
a241 1
			foreach ('x','z','y','pages'){
d251 1
a251 1
		my $hlp = GetMetadata(undef,$delete,1);
d259 1
a259 1
		my $hlp = GetMetadata(undef,$delete,1);
@


1.74
log
@creating report - minor bugs fixed, seems to be working properly
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.73 2003/11/10 06:35:57 michald Exp $
d32 1
d39 1
d400 1
a400 1
	return (exists $main::MDi->{$ID}) ? $main::MDi->{$ID}->{type} : $ID
@


1.73
log
@map graph prototype
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.72 2003/11/05 15:47:52 jiri_schmid Exp $
d10 2
d26 18
d177 50
@


1.72
log
@minor javascript improvments and fixies
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.71 2003/11/04 15:19:00 jiri_schmid Exp $
d10 2
a11 2
binmode(STDOUT, ':utf8');
binmode(STDIN, ':utf8');
d13 8
a22 2
use vars qw($DescrLPadLimit $DefaultLanguage);	# vars from const.def

d26 1
a26 1
  return "Bear Server v$main::version\n$main::copyright\n"  
d33 1
a33 1
	if ($main::LogLevel>3) {
d36 1
a36 1
		main::WriteLog('Ping responded',"Data:$st:",4) if ($main::LogLevel>3);
d45 1
a45 1
	main::WriteLog('Metadata Request',"GetProjectName($ID)",4) if (($main::LogLevel>3)&&($class)); #don't log if called locally
d53 1
a53 1
	main::WriteLog('Metadata Request',"GetProjects",4) if ($main::LogLevel>3);
d65 1
a65 1
		main::WriteLog('Get Proximate Successors',"$pn/$ID",4) if ($main::LogLevel>3);
d68 1
a68 1
		main::WriteLog('Get All Successors',"$pn/$ID",4) if ($main::LogLevel>3);
d90 1
a90 1
		main::WriteLog('Get Proximate Predecessors',"$pn/$ID",4) if ($main::LogLevel>3);
d93 1
a93 1
		main::WriteLog('Get All Predecessors',"$pn/$ID",4) if ($main::LogLevel>3);
d112 1
a112 1
	main::WriteLog('Has Path',"$pn/($ID1, $ID2)",4) if ($main::LogLevel>3);
d121 1
a121 1
	main::WriteLog('Debug Metadata Request',"$var/$ID",2) if ($main::LogLevel>1);
d163 1
a163 1
	main::WriteLog('Metadata Request',"GetMetadata($ID)",4) if (($main::LogLevel>3)&&($class));	#don't log if called localy
d173 2
a174 2
	if ($DescrLimit) { $DescrLimit=$DescrLimit-3 } else {$DescrLimit=$main::DescrLPadLimit-3};	# lpad limit dor description field, default is 80 chars
	$lang = $main::DefaultLanguage if (!$lang);
d176 1
a176 1
	main::WriteLog('Metadata List Request',"GetMetadataList('$Proj','$ObjType','$lang')",4) if ($main::LogLevel>3);
d187 2
a188 2
				$m->{$group}{display}{name} = main::LocalizedObj($main::MD->{$Proj}{group}{$group}{name}, "Object #$group", $lang);
				$m->{$group}{display}{description} = main::LocalizedObj($main::MD->{$Proj}{group}{$group}{description}, "Object #$group", $lang);
d192 2
a193 2
				$m->{$group}{$role}{display}{name} = main::LocalizedObj($main::MD->{$Proj}{group}{$group}{role}{$role}{name}, "Object #$id", $lang);
				$m->{$group}{$role}{display}{description} = main::LocalizedObj($main::MD{$Proj}{group}{$group}{role}{$role}{description}, "Object #$id", $lang);				
d195 2
a196 2
			$m->{$group}{$role}{$id}{name} = main::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
			$m->{$group}{$role}{$id}{description} = main::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
d198 2
a199 2
				$m->{$group}{$role}{$id}{display}{$_}{name} = main::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{name}, "Object #$_", $lang);
				$m->{$group}{$role}{$id}{display}{$_}{description} = main::LocalizedObj($main::MD->{$Proj}{attr}{$id}{display}{$_}{description}, '', $lang);
d202 2
a203 2
			$m->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{name}, "Object #$id", $lang);
			$m->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}{$ObjType}{$id}{description}, '', $lang);
d218 2
a219 2
	$i=main::IDGen();
	main::WriteLog('New ID',$i,4) if ($main::LogLevel>3);
d229 1
a229 1
	my $Path=shift;	#path (under $MDataDir, included Project Name) where object will be saved
d231 1
a231 1
	return main::SaveMData($Obj,$Rewrit,$Path);
d241 1
a241 1
	return main::DropMData($proj,$id);
d250 1
a250 1
	my $Path=shift;	#path (under $MDataDir, included Project Name) where object will be saved
d252 1
a252 1
	return main::SaveUserPref($Obj,$User,$Path);
d262 1
a262 1
	return main::LoadUserPref($User,$Path);
d273 1
a273 1
	return main::GetUserPref($User,$Project,$Item);
d281 1
a281 1
	main::WriteLog('Prepare SQL Request',"$ID",4) if ($main::LogLevel>3);
d290 1
a290 1
	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
d305 1
a305 1
	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
d336 1
a336 1
	$rtrn = &Acl::GetTreeDefinition($lang);
d338 1
a338 1
		$rtrn->{roles}{$p} = &main::GetAllLocalizedRights($lang,$p);
d341 1
a341 1
		$rtrn->{roles}{$p}{'~desc'} = &main::LocalizedObj($main::MD->{$p}{folder}{_ROLES_}{description},"? $_",$lang,'en') if exists $main::MD->{$p}{folder}{_ROLES_}{description};
d371 1
a371 1
	main::WriteLog('Roles Request',"GetRoles( [$project|$ID] )",4) if ($main::LogLevel>3);
d379 1
a379 1
	main::WriteLog('Roles Request',"GetRoles( [$project|$ID] )",4) if ($main::LogLevel>3);
d387 1
a387 1
	main::WriteLog('Rights Request',"GetAllLocalizedRights( [$project|$ID] )",4) if ($main::LogLevel>3);
d389 1
a389 1
	return &main::GetAllLocalizedRights($use_lang,$project)
d395 1
a395 1
	main::WriteLog('Rights Request',"GetLocalizedRights(@@ids)",4) if ($main::LogLevel>3);
d397 1
a397 1
	return &main::GetLocalizedRights($use_lang,$project,@@ids)
d404 1
a404 1
	return &main::GetLocalizedRolesList($use_lang,$project)
d412 1
a412 1
	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
d423 1
a423 1
	main::WriteLog('Result Request',"GetResult($reportID)",4) if ($main::LogLevel>3);
d433 1
a433 1
#	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
@


1.71
log
@save as - modperl fixies, code improvments
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.70 2003/09/29 05:43:19 michald Exp $
d175 1
d204 1
a204 1

@


1.70
log
@new version of the metadata - multiple attribute PK implementation; improvement of the PrepareSQL
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.68 2003/09/23 13:06:57 jiri_schmid Exp $
d171 3
a178 1
			
d200 4
a203 2
	#use Data::Dumper;
	#print Dumper($m) if $ObjType eq 'attr';
@


1.69
log
@graph2d improvments
@
text
@d137 3
a139 3
		return $Cache::RCache;
	} elsif ($var eq 'MCache') {
		return $Cache::MCache;
d175 2
d198 2
a199 2
#	use Data::Dumper;
#	print Dumper($m->{'9990'}{'dodani'}) if $ObjType eq 'attr';
d481 1
a481 1
 $obj = SOAP->GetDebug('MCache');
@


1.68
log
@bee demo changes
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.67 2003/09/22 10:58:12 vacula Exp $
a174 2
			
			
d196 2
a197 2
	#use Data::Dumper;
	#print Dumper($m) if $ObjType eq 'attr';
@


1.67
log
@added functions for 3d graphs
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.66 2003/09/15 10:46:12 jiri_schmid Exp $
a170 1

d172 1
a172 1
	foreach my $id (keys %{$main::MD->{$Proj}->{$ObjType}}) {
d174 6
a179 4
			my $group = (exists $main::MD->{$Proj}->{attr}->{$id}->{group}) ? $main::MD->{$Proj}->{attr}->{$id}->{group} : '~group'; #when no group is defined, the non-viewable pseudo group is set to keep structure
			if (!ref($m->{$group}->{display})) {
				$m->{$group}->{display}->{name} = main::LocalizedObj($main::MD->{$Proj}->{group}->{$group}->{name}, "Object #$group", $lang);
				$m->{$group}->{display}->{description} = main::LocalizedObj($main::MD->{$Proj}->{group}->{$group}->{description}, "Object #$group", $lang);
d181 4
a184 4
			my $rule = ($id =~ /\.(.*)$/) ? $1 : '~role';	#when no rule is defined, the non-viewable pseudo rule is set to keep structure
			if (!ref($m->{$group}->{$rule}->{display})) {
				$m->{$group}->{$rule}->{display}->{name} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{name}, "Object #$id", $lang);
				$m->{$group}->{$rule}->{display}->{description} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{description}, "Object #$id", $lang);				
d186 5
a190 7
			$m->{$group}->{$rule}->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang);
			$m->{$group}->{$rule}->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang);
			$m->{$group}->{$rule}->{$id}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
			foreach (keys %{$main::MD->{$Proj}->{attr}->{$id}->{display}}) {
				$m->{$group}->{$rule}->{$id}->{display}->{$_}->{name} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{name}, "Object #$_", $lang);
				$m->{$group}->{$rule}->{$id}->{display}->{$_}->{description} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{description}, '', $lang);
				$m->{$group}->{$rule}->{$id}->{display}->{$_}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
d193 3
a195 4
			$m->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang);
			$m->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang);
			$m->{$id}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
			$m->{$id}->{rights} = $main::MD->{$Proj}->{$ObjType}->{$id}->{rights} if $ObjType eq 'urole';
d198 2
@


1.66
log
@acl changes implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.65 2003/08/26 15:35:45 jiri_schmid Exp $
d395 34
@


1.65
log
@rights improvment, create delete duplicate rule implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.64 2003/08/25 15:09:20 jiri_schmid Exp $
d197 1
@


1.64
log
@object acl, owner, modifier, datetime creation and modification implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.63 2003/08/22 16:01:03 jiri_schmid Exp $
d326 1
a326 1
		$rtrn->{roles}{$p} = &main::GetLocalizedRights($lang,$p);
d373 1
a373 1
sub GetLocalizedRights {	# lang, project || undef,item id; out: HASH
d375 1
a375 1
	main::WriteLog('Rights Request',"GetLocalizedRights( [$project|$ID] )",4) if ($main::LogLevel>3);
d377 1
a377 1
	return &main::GetLocalizedRights($use_lang,$project)
d380 7
@


1.63
log
@access - rules changing implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.62 2003/08/21 12:02:13 jiri_schmid Exp $
d326 1
a326 5
		my $hlp = GetRoles($class,$p);
		foreach (keys %{$hlp}) {
			$rtrn->{roles}{$p}{$_}{name} = &main::LocalizedObj($hlp->{$_}{name},"? $_",$lang,'en');
			$rtrn->{roles}{$p}{$_}{desc} = &main::LocalizedObj($hlp->{$_}{description},"? $_",$lang,'en') if $hlp->{$_}{description};
		}
d335 1
a335 1
sub GetUserDetail {
d340 1
a340 1
sub GetGroupDetail {
d345 1
a345 1
sub GetLocalizedUsersList {	#class, local lang, users id
d351 1
a351 1
sub GetLocalizedGroupsList {	#class, local lang, groups id
d357 1
a357 1
sub GetRoles {
d359 1
d361 6
d368 10
a377 1
	return $main::MD->{$project}{urole}
d382 4
a385 4
sub GetRolesList {
my ($class,$ID,$use_lang) = @@_;
	my $pn = GetProjectName($class,$ID);
	return &main::GetRolesList($pn,$use_lang)
@


1.62
log
@description for access tree changes
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.61 2003/08/20 14:23:45 jiri_schmid Exp $
d349 12
d364 1
a364 1
	main::WriteLog('Roles Request',"GetRoles($project | $ID)",4) if ($main::LogLevel>3);
@


1.61
log
@access object implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.60 2003/08/18 13:17:13 jiri_schmid Exp $
d324 1
a324 1
	$rtrn = &Acl::GetAccessTreeDefinition($lang);
d331 3
@


1.60
log
@admin page reading rutines implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.59 2003/08/15 10:59:39 michald Exp $
d146 1
a146 1
		return { 'users'=>$Acl::Usr, 'groups'=>$Acl::Grp };
d180 1
a180 1
			my $rule = ($id =~ /\.(.*)$/) ? $1 : '~rule';	#when no rule is defined, the non-viewable pseudo rule is set to keep structure
d321 12
a332 1
	return &Acl::GetAccessTreeDefinition(lc($_[1]))
d345 15
@


1.59
log
@initial ACL implementation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.58 2003/08/12 09:19:19 jiri_schmid Exp $
d320 2
a321 3
sub GetAccessObjects {
	my $Lang = shift;
	return &Cache::GetAccessObjects($Lang)
d323 11
@


1.58
log
@ACL implementation, datas moved into beard"s caches
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.57 2003/08/06 09:36:32 michald Exp $
d142 5
@


1.57
log
@filter call implementation to GetAttrElements
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.56 2003/08/06 07:50:33 jiri_schmid Exp $
d312 6
@


1.56
log
@elements
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.55 2003/08/04 08:12:48 jiri_schmid Exp $
d296 1
a296 1
	my ($class, $Lang, $Filter, $Sort, $SortOrd, $attr, $fact) = @@_;	# language, filter expression, sort index, sort order, attribute (in form attr.role~display), join-fact
a302 1
	main::WriteLog('Attribute Elements Request', join(', ', @@attr), 4) if ($main::LogLevel>3);
d311 1
a311 1
return (exists $main::MDi->{$ID}) ? $main::MDi->{$ID}->{type} : $ID
@


1.55
log
@changes depending on implemntation of right pane on graph3d page done
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.54 2003/07/30 15:30:47 jiri_schmid Exp $
d296 1
a296 1
	my ($class, $Lang, $Filter, $Sort, $SortOrd, @@attr) = @@_;	# language, filter expression, sort index, sort order, list of attributes (in form attr.role~display)
d304 1
a304 1
	return &Cache::GetAttrElements($Lang, $Filter, $Sort, $SortOrd, @@attr)
@


1.54
log
@right pane implementation stage 2
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.53 2003/07/29 06:52:46 michald Exp $
d309 5
@


1.53
log
@Cache::GetAttrElements implementation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.52 2003/07/14 11:52:26 jiri_schmid Exp $
d295 1
a295 1
sub GetAttrElements {	# returns elements for specific attribute
@


1.52
log
@3dgraph webpage-rules implantation, minor code changes
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.51 2003/07/04 14:29:33 jiri_schmid Exp $
d270 1
a270 1
sub GetResultName {	# returns hash and arraies of names
a282 1

d285 1
a285 1
sub GetResultId {	# returns hash and arraies of ids
d293 17
d352 2
@


1.51
log
@utf8 handling fixed
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.50 2003/07/04 06:19:18 michald Exp $
d170 1
a170 1
			my $group = ($main::MD->{$Proj}->{attr}->{$id}->{group}) ? $main::MD->{$Proj}->{attr}->{$id}->{group} : '~group'; #when no group is defined, the non-viewable pseudo group is set to keep structure
d175 1
a175 2
			my ($hlp) = $id =~ /\.(.*)$/;
			my $rule = ($hlp) ? $hlp : '~rule';	#when no rule is defined, the non-viewable pseudo rule is set to keep structure
d177 2
a178 2
				$m->{$group}->{$rule}->{display}->{name} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{name}, "Object #$hlp", $lang);
				$m->{$group}->{$rule}->{display}->{description} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{description}, "Object #$hlp", $lang);				
@


1.50
log
@some fixes for proper utf8 encoding, see README for details
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.49 2003/06/25 15:40:29 jiri_schmid Exp $
d275 6
@


1.49
log
@code changes a fixies
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.48 2003/06/23 08:31:13 jiri_schmid Exp $
d10 2
a11 2
binmode(STDOUT, ":utf8");
binmode(STDIN, ":utf8");
@


1.48
log
@clearCache rebuild
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.47 2003/06/23 08:14:38 michald Exp $
d271 7
a277 6
#sub GetResult {	# returns result hash of cells
#	my ($class,$ID) = @@_;
#	return if ($main::MDi->{$ID}->{type} ne 'report');
#	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
#	return main::GetResult($ID);
#}
d281 2
a282 2
sub GetResult {	# returns result hash of cells
	my ($class,$ID,$lang) = @@_;
d285 1
a285 1
	return &Cache::RCache2XTabId($ID,$lang)
@


1.47
log
@fix HasPath, add type param in GetObjPredecessors
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.46 2003/06/21 16:13:10 michald Exp $
d54 1
a54 1
	my ($class, $ID, $prox) = @@_;	# return proximate successors if $prox is set, otherwise return all successors
d69 1
a69 1
			push @@vv,$_ if ($main::MDi->{$ID}->{type}=~/$type/);
d85 1
a85 1
		@@v = $main::MDgo->{$pn}->predecessors($ID));
d94 1
a94 1
			push @@vv,$_ if ($main::MDi->{$ID}->{type}=~/$type/);
a286 6
#---------------------------------------

sub IsUsedInReport() {
my ($class, $ID) = @@_;
return (main::IsUsedInReport($ID))
}
@


1.46
log
@improvement of object dependency directed graph
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.45 2003/06/20 16:21:23 jiri_schmid Exp $
d57 1
d60 1
a60 1
		return ($main::MDgo->{$pn}->successors($ID));
d64 1
a64 1
		return (grep {!/^$ID$/} $gr->successors($ID));
d66 8
d79 1
a79 1
	my ($class, $ID, $prox) = @@_;	# return proximate predecessors if $prox is set, otherwise return all predecessors
d82 1
d85 1
a85 1
		return ($main::MDgo->{$pn}->predecessors($ID));
d89 8
a96 1
		return (grep {!/^$ID$/} $gr->predecessors($ID));
d98 1
d104 1
a104 1
	my ($class, $graph, $ID1, $ID2) = @@_;
d107 2
a108 1
	return $main::MDga->{$pn}->has_path($ID1,$ID2);
@


1.45
log
@result of clearing HTML cache depends on HasPath() now
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.44 2003/06/20 08:42:32 michald Exp $
d54 1
a54 1
	my ($class, $graph, $ID) = @@_;
a55 1
	main::WriteLog('Get Successors',"$pn/$ID",4) if ($main::LogLevel>3);
d57 8
a64 3
	my $gr = $main::MDgo->{$pn}->TransitiveClosure_Floyd_Warshall;

	return (grep {!/^$ID$/} $gr->successors($ID));
d70 1
a70 1
	my ($class, $graph, $ID) = @@_;
a71 1
	main::WriteLog('Get Predecessors',"$pn/$ID",4) if ($main::LogLevel>3);
d73 8
a80 3
	my $gr = $main::MDgo->{$pn}->TransitiveClosure_Floyd_Warshall;

	return (grep {!/^$ID$/} $gr->predecessors($ID));
a138 30
#sub GetResult {	# returns result hash of cells
#	my ($class,$ID) = @@_;
#	return if ($main::MDi->{$ID}->{type} ne 'report');
#	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
#	return main::GetResult($ID);
#}

#---------------------------------------

sub PrepareSQL {	# returns hash containing SQL for specific report
	my ($class,$ID) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	main::WriteLog('Prepare SQL Request',"$ID",4) if ($main::LogLevel>3);
	return SQLGen::PrepareSQL($ID)
}

#---------------------------------------
#
#sub GetMetadataSubstPtr2Name {	# same as GetMetadata with substitution of ptrs by obj. names
#	my ($class,$ID) = @@_;
#	main::WriteLog('Metadata Request (obj. name substitution)',"GetMetadata($ID)",4) if ($main::LogLevel>3);
#	
#	my $objT = $main::MDi->{$ID}->{type};
#	my $obj = main::SubstPtr2Name ($objT, clone( ${ $main::MDi->{$ID}->{ptr} } ));
#
#	return {$objT => { $ID => $obj }}
#}
#
#---------------------------------------

a142 3
#	use Data::Dumper;
#	print Dumper(GetDebug($class,'UserPref'));

d243 18
d268 1
a269 1
#---------------------------------------
d312 2
a313 1
 @@suc = SOAP->GetObjSuccessors('MDga', $ObjID);	# returns list of objects depending on specific object
@


1.44
log
@introduction of new directed graph structures MDga and MDgo
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.43 2003/06/19 14:59:45 jiri_schmid Exp $
a281 11
#---------------------------------------
sub IsMetricUsedInReport() {
my ($class, $ID) = @@_;
return (main::IsMetricUsedInReport($ID))
}

#---------------------------------------
sub IsUsedInMetricInReport() {
my ($class, $ID) = @@_;
return (main::IsUsedInMetricInReport($ID))
}
@


1.43
log
@huge improvment on format page
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.42 2003/06/13 15:35:23 jiri_schmid Exp $
d53 33
d98 2
d103 6
d125 1
a125 1
	main::WriteLog('Metadata Request',"GetMetadata($ID)",4) if ($main::LogLevel>3);
d139 9
d233 1
d330 3
@


1.42
log
@code improvmnent
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.41 2003/06/13 13:08:24 jiri_schmid Exp $
d126 1
a126 1
			my $group = ($main::MD->{$Proj}->{attr}->{$id}->{group}) ? $main::MD->{$Proj}->{attr}->{$id}->{group} : '~group';
d132 1
a132 1
			my $rule = ($hlp) ? $hlp : '~rule';
@


1.41
log
@clearing html cache improved
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.40 2003/06/13 11:33:00 jiri_schmid Exp $
d39 1
a39 4

	main::WriteLog('Metadata Request',"GetProjectName($ID)",4) 
		if (($main::LogLevel>3)&&($class)); #don't log if called locally

d228 1
a228 10
my $projectName = GetProjectName($class,$ID);
my $mdReports = $main::MD->{$projectName}->{report};
my $itemType = $main::MDi->{$ID}->{type};
my @@rtrn;
foreach (keys(%{$mdReports})) {
	if ($mdReports->{$_}{$itemType."_def"} eq $ID) {
		push(@@rtrn,$_);
	}
}
return (@@rtrn)
d234 1
a234 32
my $projectName = GetProjectName($class,$ID);
my $md = $main::MD->{$projectName}->{grid};
my $itemType = $main::MDi->{$ID}->{type};
my $grids;
my $rtrn;

foreach my $grid (keys(%{$md})) {
	foreach (@@{$md->{$grid}{metric}}) {
		if ($_ eq $ID) {
			$grids->{$grid} = 1;
		}
	}
}

$md = $main::MD->{$projectName}->{report};
foreach my $report (keys(%{$md})) {
	if (ref($md->{$report}{grid_def}) =~ /HASH/) {
		foreach (@@{$md->{$report}{grid_def}{metric}}) {
			if ($_ eq $ID) {
				$rtrn->{$report} = 1;
			};
		}
	} else {
		foreach (keys(%{$grids})) {
			if ($md->{$report}{grid_def} eq $_) {
				$rtrn->{$report} = 1;
			};
		}
	}
}

return (keys(%{$rtrn}))
d240 1
a240 19
my $projectName = GetProjectName($class,$ID);
print "$projectName";
my $md = $main::MD->{$projectName}->{metric};
my $itemType = $main::MDi->{$ID}->{type};
my $metrics;
my $rtrn;

foreach (keys(%{$md})) {
	if ($md->{$_}{filter_id} eq $ID) {
		$metrics->{$_} = 1;
	}
}

foreach (keys(%{$metrics})) {
	my @@hlp = &IsMetricUsedInReport($class,$_);
	foreach (@@hlp) { $rtrn->{$_} = 1; }
}

return (keys(%{$rtrn}))
@


1.40
log
@metric in report implemented, clearcache implemented, when part of report changed
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.39 2003/06/12 08:44:34 jiri_schmid Exp $
d229 1
a229 1
sub IsUsedInReoprt() {
d280 20
d301 2
@


1.39
log
@create HTML report on artificial datas implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.38 2003/06/03 08:16:07 jiri_schmid Exp $
d221 1
a221 1
	my ($class,$ID) = @@_;
d224 51
a274 1
	return main::GetResult($ID);
d277 2
@


1.38
log
@code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.37 2003/05/30 12:39:40 jiri_schmid Exp $
d93 6
a98 6
sub GetResult {	# returns result hash of cells
	my ($class,$ID) = @@_;
	return if ($main::MDi->{$ID}->{type} ne 'report');
	main::WriteLog('Result Request',"GetResult($ID)",4) if ($main::LogLevel>3);
	return main::GetResult($ID);
}
d219 9
@


1.37
log
@fixed bug with user prefernces
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.36 2003/05/30 09:14:38 jiri_schmid Exp $
a202 1
	my $Force=shift; #do not add names to report id
d204 1
a204 1
	return main::LoadUserPref($User,$Path,$Force);
@


1.36
log
@char-overtype fix in bear.pm
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.35 2003/05/30 09:13:31 jiri_schmid Exp $
d116 1
a116 1
	my ($class,$Proj, $ObjType, $User, $DescrLimit) = @@_;
d122 1
a122 1
	my $lang = ($main::UserPref->{$User}->{Beard}->{language}) ? lc($main::UserPref->{$User}->{Beard}->{language}) : $main::DefaultLanguage;
d124 1
a124 1
	main::WriteLog('Metadata List Request',"GetMetadataList('$Proj','$ObjType')",4) if ($main::LogLevel>3);
d206 11
@


1.35
log
@minor fixies and code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.34 2003/05/28 15:33:34 michald Exp $
d121 1
a121 1
	if ($DescrLimit) { $DescrLimit=$DescrLimit-3 } else {$DescrLimit=$mani::DescrLPadLimit-3};	# lpad limit dor description field, default is 80 chars
@


1.34
log
@move of some code into separate modules
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.33 2003/05/23 15:03:43 jiri_schmid Exp $
d78 1
a78 1
		return $Cache::UserPref;
d117 6
a122 3
	if ($DescrLimit) { $DescrLimit=$DescrLimit-3 } else {$DescrLimit=$DescrLPadLimit-3};	# lpad limit dor description field, default is 80 chars
	my $lang = lc($main::UserPref->{$User}->{Beard}->{language});
	$lang = $DefaultLanguage if (!$lang);
d131 2
a132 2
				$m->{$group}->{display}->{name} = main::LocalizedObj($main::MD->{$Proj}->{group}->{$group}->{name}, "Object #$group", $lang, $DefaultLanguage);
				$m->{$group}->{display}->{description} = main::LocalizedObj($main::MD->{$Proj}->{group}->{$group}->{description}, "Object #$group", $lang, $DefaultLanguage);
d137 2
a138 2
				$m->{$group}->{$rule}->{display}->{name} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{name}, "Object #$hlp", $lang, $DefaultLanguage);
				$m->{$group}->{$rule}->{display}->{description} = main::LocalizedObj($main::MD->{$Proj}->{role}->{$rule}->{description}, "Object #$hlp", $lang, $DefaultLanguage);				
d140 2
a141 2
			$m->{$group}->{$rule}->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang, $DefaultLanguage);
			$m->{$group}->{$rule}->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang, $DefaultLanguage);
d144 2
a145 2
				$m->{$group}->{$rule}->{$id}->{display}->{$_}->{name} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{name}, "Object #$_", $lang, $DefaultLanguage);
				$m->{$group}->{$rule}->{$id}->{display}->{$_}->{description} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{description}, '', $lang, $DefaultLanguage);
d149 2
a150 2
			$m->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang, $DefaultLanguage);
			$m->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang, $DefaultLanguage);
@


1.33
log
@rules and groups for attributes implemented, metric & filter checker remaked
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.32 2003/05/23 06:40:49 michald Exp $
d11 1
d15 1
a15 1
use vars qw($MD $MDi $UserPref $DescrLPadLimit $DefaultLanguage);
d72 1
a72 1
		return $main::RCache;
d74 1
a74 1
		return $main::MCache;
d76 1
a76 1
		return $main::Lookup->{$ID};
d78 1
a78 1
		return $main::UserPref;
@


1.32
log
@implementation of attribute roles into directed graph
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.31 2003/05/21 15:00:51 jiri_schmid Exp $
d125 14
a138 4
			my $group = ($main::MD->{$Proj}->{attr}->{$id}->{group}) ? $main::MD->{$Proj}->{attr}->{$id}->{group} : "111111111111";
			$m->{$group}->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang, $DefaultLanguage);
			$m->{$group}->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang, $DefaultLanguage);
			$m->{$group}->{$id}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
d140 3
a142 3
				$m->{$group}->{$id}->{display}->{$_}->{name} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{name}, "Object #$_", $lang, $DefaultLanguage);
				$m->{$group}->{$id}->{display}->{$_}->{description} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{description}, '', $lang, $DefaultLanguage);
				$m->{$group}->{$id}->{display}->{$_}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
@


1.31
log
@subfolders in attributes implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.30 2003/05/21 07:47:24 michald Exp $
d65 5
@


1.30
log
@implementation of attribute roles and groups
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.29 2003/05/07 14:24:39 jiri_schmid Exp $
a118 3
		$m->{$id}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{name}, "Object #$id", $lang, $DefaultLanguage);
		$m->{$id}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$id}->{description}, '', $lang, $DefaultLanguage);
		$m->{$id}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
d120 4
d125 3
a127 3
				$m->{$id}->{display}->{$_}->{name} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{name}, "Object #$_", $lang, $DefaultLanguage);
				$m->{$id}->{display}->{$_}->{description} = main::LocalizedObj($main::MD->{$Proj}->{attr}->{$id}->{display}->{$_}->{description}, '', $lang, $DefaultLanguage);
				$m->{$id}->{display}->{$_}->{description} =~ s/^(.{$DescrLimit}).{3,}$/$1.../;
d129 5
a133 1
		}	
@


1.29
log
@tuning, code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.28 2003/05/07 13:11:51 jiri_schmid Exp $
d56 2
a57 2
	my ($class,$var,$Proj) = @@_;
	main::WriteLog('Debug Metadata Request',"$var/$Proj",2) if ($main::LogLevel>1);
d59 2
a60 1
		return $main::MD->{$Proj};
d70 1
a70 1
		return $main::Lookup;
d109 3
a111 1
	my ($class,$Proj, $ObjType, $User) = @@_;
d121 1
d126 1
a134 19
sub GetMetadataShortList {	# returns list of $ObjType objects with their names and shortened description
	my ($class, $Proj, $ObjType, $User, $DescrLimit) = @@_;
	if ($DescrLimit) { $DescrLimit=$DescrLimit-3 } else {$DescrLimit=$DescrLPadLimit-3};	# lpad limit dor description field, default is 80 chars
	my $lang = lc($main::UserPref->{$User}->{Beard}->{language});
	$lang = $DefaultLanguage if (!$lang);

	main::WriteLog('Metadata Short List Request',"GetMetadataShortList('$Proj','$ObjType', '$User', '$lang')",4) if ($main::LogLevel>3);

	my $m;
	foreach (keys %{$main::MD->{$Proj}->{$ObjType}}) {
		$m->{$_}->{name} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$_}->{name}, "Object #$_", $lang, $DefaultLanguage);
		$m->{$_}->{description} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$_}->{description}, '', $lang, $DefaultLanguage);
		$m->{$_}->{description} =~s/^(.{$DescrLimit}).{3,}$/$1.../;
	}
	return $m
}

#---------------------------------------

d214 1
a214 2
 $m=SOAP->GetMetadataList($ProjectName, $ObjectType, $User);      #full List 
 $m=SOAP->GetMetadataShortList($ProjectName, $ObjectType, $User, $DescrLimit);
d225 1
a225 1
 $id=SOAP->NewID();
d227 1
a227 1
 $obj = SOAP->GetDebug('MD', $ProjectName);
d232 1
a232 1
 $obj = SOAP->GetDebug('Lookup');
@


1.28
log
@bug fixies, code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.27 2003/05/07 08:21:59 jiri_schmid Exp $
a140 1
		$m->{$_}->{en} = main::LocalizedObj($main::MD->{$Proj}->{$ObjType}->{$_}->{name}, "Object #$_", 'en', $DefaultLanguage);
@


1.27
log
@code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.26 2003/05/06 15:06:10 jiri_schmid Exp $
d141 1
@


1.26
log
@bug fixies, code improvment
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.25 2003/05/05 06:41:47 michald Exp $
d193 1
a193 1
	my $Force=shift;
@


1.25
log
@implementation of full localized metadata
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.24 2003/04/25 11:27:34 jiri_schmid Exp $
d193 1
d195 1
a195 1
	return main::LoadUserPref($User,$Path);
@


1.24
log
@switching among projects implemented
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.23 2003/03/14 09:23:52 jiri_schmid Exp $
d14 1
a14 1
use vars qw($MD $MDi $DescrLPadLimit);
d48 7
d64 8
a77 7
sub getProjectsNames {	# returns hash of project names
	main::WriteLog('Project names Request',"",4) if ($main::LogLevel>3);
	return sort(keys(%{$main::MD}))
}

#---------------------------------------

d94 11
a104 11

sub GetMetadataSubstPtr2Name {	# same as GetMetadata with substitution of ptrs by obj. names
	my ($class,$ID) = @@_;
	main::WriteLog('Metadata Request (obj. name substitution)',"GetMetadata($ID)",4) if ($main::LogLevel>3);
	
	my $objT = $main::MDi->{$ID}->{type};
	my $obj = main::SubstPtr2Name ($objT, clone( ${ $main::MDi->{$ID}->{ptr} } ));

	return {$objT => { $ID => $obj }}
}

d108 4
a111 1
	my ($class,$Proj,$ObjType) = @@_;
d113 13
a125 1
	return $main::MD->{$Proj}->{$ObjType};
d131 1
a131 1
	my ($class,$Proj,$ObjType,$DescrLimit) = @@_;
d133 4
a136 1
	main::WriteLog('Metadata Short List Request',"GetMetadataShortList('$Proj','$ObjType')",4) if ($main::LogLevel>3);
d140 3
a142 2
		$m->{$_}->{name}=$main::MD->{$Proj}->{$ObjType}->{$_}->{name};
		($m->{$_}->{description}=$main::MD->{$Proj}->{$ObjType}->{$_}->{description})=~s/^(.{$DescrLimit}).{3,}$/$1.../;
a148 7
sub GetProjects {	# returns list of available projects
	main::WriteLog('Metadata Request',"GetProjects",4) if ($main::LogLevel>3);
	return (keys %{$main::MD})
}

#---------------------------------------

d166 10
d188 1
d199 11
a209 4
sub DropMData {	# drop specified object from metadata
	my $class=shift;
	my $proj=shift;	#project
	my $id=shift;	#object ID to drop
d211 45
a255 2
	return main::DropMData($proj,$id);
}
d257 1
a257 1
#---------------------------------------
d259 1
a259 1
1
a260 1
__END__
@


1.23
log
@solved problem with CZ chars, by forced 8bit operating XML-UTF8 files, removed unused images
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.22 2003/03/06 08:49:36 jiri_schmid Exp $
d58 8
@


1.22
log
@saving user pref under loged user name may work properly
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.21 2003/03/04 16:32:14 jiri_schmid Exp $
d9 2
@


1.21
log
@saving prefernces into xml is functional, loading almost too
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.20 2003/01/30 06:36:23 michald Exp $
d141 1
d144 1
a144 1
	return main::SaveUserPref($Obj,$Path);
d150 1
d153 1
a153 1
	return main::LoadUserPref($Path);
@


1.20
log
@functionality for saving and retrieving attribute displays and metric groups in grid editor
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.19 2003/01/26 14:16:29 michald Exp $
d135 17
@


1.19
log
@some small fixes
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.18 2003/01/20 18:33:56 michald Exp $
d82 1
a82 1
	my $obj = clone( ${ $main::MDi->{$ID}->{ptr} } );
a83 25
	if ($objT eq 'grid') {
		foreach my $oT ('page','col','row','metric') {
			my $i=$obj->{$oT};
			my @@ta=();
			foreach (@@{$i}) {
				if (exists $main::MDi->{$_}) {
					push (@@ta, ${$main::MDi->{$_}->{ptr}}->{name}."\t".$main::MDi->{$_}->{type});
				} else {
					main::WriteLog('Substitution of ID Failed',"ID=$_",1) if ($main::LogLevel>0);
				}
			}
			@@{$obj->{$oT}} = @@ta;
		}
	} elsif ($objT eq 'report') {
		foreach my $oT ('grid','filter','format') {
			my $i=$obj->{$oT};	# ID of grid|filter|format object
			if (exists $main::MDi->{$i}) {
				$obj->{$oT} = ${$main::MDi->{$i}->{ptr}}->{name};
			} else {
				$obj->{$oT} = "NA ID($i)";
				main::WriteLog('Substitution of ID Failed',"ID=$i",1) if ($main::LogLevel>0);
			}
		}
	}
	
@


1.18
log
@fix Clone disappearing
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.15 2003/01/03 11:22:05 michald Exp $
d90 1
a90 1
					push (@@ta, ${$main::MDi->{$_}->{ptr}}->{name})
@


1.17
log
@reduce number of tabs
@
text
@d10 2
d82 1
a82 1
	my $obj = ${ $main::MDi->{$ID}->{ptr} };      
d99 1
a99 1
			my $i=$obj->{$oT};
@


1.16
log
@edit_obj with drag/drop functionality
@
text
@a9 2
use Clone qw(clone);

d80 1
a80 1
	my $obj = clone( ${ $main::MDi->{$ID}->{ptr} } );
d97 1
a97 1
			my $i=$obj->{$oT};	# ID of grid|filter|format object
@


1.15
log
@hard connection to test project in *_ed.pl wa removed
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.14 2002/11/26 08:08:32 michald Exp $
d10 2
d82 1
a82 1
	my $obj = ${ $main::MDi->{$ID}->{ptr} };
d99 1
a99 1
			my $i=$obj->{$oT};
@


1.14
log
@name to ID translation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.13 2002/11/12 18:18:43 michald Exp $
d62 9
@


1.13
log
@new obj. name to ID transition in SaveMData
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.12 2002/11/11 10:36:04 michald Exp $
d61 1
a61 1
	return {$main::MDi->{$ID}->{type} => {$ID => ${$main::MDi->{$ID}->{ptr}}}}
d70 27
a96 1
	my $tm = {$main::MDi->{$ID}->{type} => {$ID => ${$main::MDi->{$ID}->{ptr}}}};
d98 1
a98 1
	return $tm
d105 1
a105 1
	main::WriteLog('MMetadata List Request',"GetMetadataList('$Proj','$ObjType')",4) if ($main::LogLevel>3);
@


1.12
log
@new debug screen
metadata name index
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.11 2002/11/02 09:28:05 michald Exp $
d10 1
a10 1
use vars qw($MD $MDi);
d58 1
a58 1
sub GetMetadata {	# returns hash of metadata in form 'metadata type'=>{params...}
d66 11
d86 2
a87 1
	my ($class,$Proj,$ObjType) = @@_;
d89 1
a90 2
#use Data::Dumper;
#main::WriteLog('XXX',Dumper($main::MD->{$Proj}->{$ObjType}),4);
d93 1
a93 1
		($m->{$_}->{description}=$main::MD->{$Proj}->{$ObjType}->{$_}->{description})=~s/^(.{77}).{3,}$/$1.../;
@


1.11
log
@fix GetMetadata to be fully reciprocal to SaveMData
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.10 2002/11/01 13:20:46 spanhel Exp $
d40 14
@


1.10
log
@change folder metadata
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.9 2002/10/22 15:11:14 michald Exp $
d47 1
a47 1
	return {$main::MDi->{$ID}->{type} => $ID => ${$main::MDi->{$ID}->{ptr}}}
@


1.9
log
@add demo metadata
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.8 2002/10/05 17:32:03 michald Exp $
d47 1
a47 1
	return {$main::MDi->{$ID}->{type} => ${$main::MDi->{$ID}->{ptr}}}
@


1.8
log
@grid edit window
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.7 2002/10/02 16:53:04 michald Exp $
d34 1
d37 3
a39 3
	foreach (keys %{$main::MD}) {
		return $_ if (exists $main::MDi->{$_}->{$ID});
	}
d45 3
a47 8
	my ($class,$ID,$Proj) = @@_;
	main::WriteLog('Metadata Request',"GetMetadata($ID,'$Proj')",4) if ($main::LogLevel>3);
	if ($Proj) {
		return {$main::MDi->{$Proj}->{$ID}->{type} => ${$main::MDi->{$Proj}->{$ID}->{ptr}}}
	} else {
		$Proj=GetProjectName(undef,$ID);
		return {$main::MDi->{$Proj}->{$ID}->{type} => ${$main::MDi->{$Proj}->{$ID}->{ptr}}}
	}
d94 1
a95 1
	my $Rewrit=shift;	#force rewrite
d97 1
a97 1
	return main::SaveMData($Obj,$Path,$Rewrit);
@


1.7
log
@create new object implementation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.6 2002/10/02 11:14:05 michald Exp $
d10 1
a10 1
use vars qw($MD);
d18 2
d30 9
a38 4
sub GetMetadata {
	my ($class,$Proj,$ObjType,$ID) = @@_;
	main::WriteLog('Metadata Request',"GetMetadata('$Proj','$ObjType',$ID)",4) if ($main::LogLevel>3);
	return $main::MD->{$Proj}->{$ObjType}->{$ID}
d41 15
d58 1
a58 1
	main::WriteLog('MMetadata List Request',"GetMetadata('$Proj','$ObjType')",4) if ($main::LogLevel>3);
d62 2
d66 1
a66 1
	main::WriteLog('Metadata Short List Request',"GetMetadata('$Proj','$ObjType')",4) if ($main::LogLevel>3);
d68 2
a69 2
use Data::Dumper;
main::WriteLog('XXX',Dumper($main::MD->{$Proj}->{$ObjType}),4);
d77 2
d84 2
d93 3
a95 1
sub SaveMData {
d102 10
@


1.6
log
@Create New Objects functionality
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.5 2002/09/30 13:56:53 michald Exp $
d36 1
a36 1
	main::WriteLog('Metadata List Request',"GetMetadata('$Proj','$ObjType')",4) if ($main::LogLevel>3);
a37 1
	main::WriteLog('XXX',Data::Dumper($main::MD->{$Proj}),4);
d44 2
d68 1
a68 1
	my $Path=shift;	#path under $MDataDir to save
@


1.5
log
@add new icon
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.4 2002/09/30 12:01:16 michald Exp $
d37 2
a38 1
	return $main::MD->{$Proj}->{$ObjType}
d41 1
a41 1
sub GetMetadataShortList {	# returns list of $ObjType objects with their names and shortaged 
d47 1
a47 1
		$m->{$_}->{description}=$main::MD->{$Proj}->{$ObjType}->{$_}->{description};
d62 9
@


1.4
log
@add comments
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.3 2002/09/30 10:02:24 michald Exp $
d40 1
a40 1
sub GetMetadataShortList {	# returns list of $ObjType objects with their names and 
@


1.3
log
@client metadata connection, client tree presentation
@
text
@d4 1
a4 1
# $Id: Bear.pm,v 1.2 2002/09/25 18:24:13 michald Exp $
d40 1
a40 1
sub GetMetadataShortList {
d51 1
a51 1
sub GetProjects {
d53 1
a53 1
	return (keys %{$main::MD});
d56 5
a60 3
sub NewID {
	main::WriteLog('Metadata Request',"GetProjects",4) if ($main::LogLevel>3);
	return (keys %{$main::MD});
@


1.2
log
@beard metadata connection
@
text
@d4 1
a4 1
# $Id$
d10 2
a13 54
my $MetaData = { 'meta' => [
	{
		'id' => '1',
		'type' => 'DIR',
		'name' => 'Attributes',
		'desc' => 'Attributes Directory',
		'cont' => [
			{ 
				'id' => '22',
				'type' => 'ATTR',
				'name' => 'Day',
				'desc' => 'Day of Transaction',
				'def' => {}
			},
			{
				'id' => '6',
				'type' => 'ATTR',
				'name' => 'Month',
				'desc' => 'Day of Transaction',
				'def' => {}
			},
			{
				'id' => '4',
				'type' => 'ATTR',
				'name' => 'Product',
				'desc' => 'Product SKU',
				'def' => {}
			},
		],				
	},
	{
		'id' => '3',
		'type' => 'DIR',
		'name' => 'Metrics',
		'desc' => 'Metrics Directory',
		'cont' => [
			{ 
				'id' => '7',
				'type' => 'METR',
				'name' => 'Revenue',
				'desc' => 'Total Revenue',
				'def' => {}
			},
			{
				'id' => '5',
				'type' => 'METR',
				'name' => 'Cost',
				'desc' => 'Total Cost',
				'def' => {}
			},
		],				
	},
]};	

d23 1
a23 1
		main::WriteLog('Ping responded',"Data:$st:",4);
d29 19
a47 2
	my ($class, $node, @@param) = @@_;
	my $m = $MetaData->{meta};
d51 9
a59 1
1;
d62 2
@


1.1
log
@minor change of cvs tree structure
@
text
@d1 5
a5 1
# zmena zmena zmena g 
d10 1
a10 4
use vars qw($MetaData);

my $version = '0.01';
my $copyright = '(C) Insight Strategy, a. s., 2002';
d67 1
a67 1
  return "Bear Server v$version\n$copyright\n";     
d72 6
a77 1
	return $s;
d83 1
a83 1
	return $m;
d88 2
a90 2

# zmena zmena zmena@

