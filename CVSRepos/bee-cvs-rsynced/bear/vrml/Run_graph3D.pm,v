head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2004.03.22.13.53.24;	author vacula;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.18.16.46.44;	author vacula;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.17.14.08.32;	author vacula;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.16.23.43.36;	author vacula;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.12.09.28.42;	author vacula;	state Exp;
branches;
next	;


desc
@@


1.5
log
@fix number of color in IndexedFaceSet
@
text
@
package Run_graph3D;

use strict;

use VRML;
require "vrml/Texture.pm";
require "vrml/Style.pm";
require "const/Const.pm";

use Data::Dumper;

##########################################################################################################################################

our $vrml;		## global vrml obj

sub exportToHTML {

	my $variables = shift;				# information about html file (file,skin,id,imgType,user ...)
	my $style = shift;
	my $report = shift;
	my $mdata = shift;
	my $Data = shift;

	my $Style = Style::getStyle($style->{form});
	my $Map = Style::getMap($mdata,$Style);
	undef $style; undef $mdata;

	my $http_texdir = &localDirToHttpDir($Const::texture_dir);	## global path to texture directory from web
	my $file = "$Const::myPath$Const::cache3DReport/$$variables->{id}-$$variables->{useLang}.wrl";

	$vrml = new VRML(2);		
	
	$vrml->comment("------------------------------------------------------------------------");
	$vrml->comment("                    GENERAL PARAMETERS OF SCENE                         ");
	$vrml->comment("------------------------------------------------------------------------");
	generalParameters( $report, $$variables->{useLang}, $Style );
	
	$vrml->comment("------------------------------------------------------------------------");
	$vrml->comment("                            	AXIS                                    ");
	$vrml->comment("------------------------------------------------------------------------");
	my $X = Style::defineAxis('X',$Map,$Style);				## -------------------------------------------------------
	my $Y = Style::defineAxis('Y',$Map,$Style);				## 	definition parameters of axis			   
	my $Z = Style::defineAxis('Z',$Map,$Style);				##--------------------------------------------------------
	if ( defined $X and $X->{size} != 0 and $X->{length} != 0 ) {			
		generateAxis($X);						# drawing axis X
		if ( defined $X->{label} ) {
			generateLabel( $X->{label}, $http_texdir );
		}
	}   
	if ( defined $Y and $Y->{size} != 0 and $Y->{length} != 0 ) {			
		generateAxis($Y);						# drawing axis Y
		if ( defined $Y->{label} ) {
			generateLabel( $Y->{label}, $http_texdir );
		}
	}   
	if ( defined $Z and $Z->{size} != 0 and $Z->{length} != 0 ) {			
		generateAxis($Z);						# drawing axis Z
		if ( defined $Z->{label} ) {
			generateLabel( $Z->{label}, $http_texdir );
		}
	}   
	
	$vrml->comment("------------------------------------------------------------------------");
	$vrml->comment("                   	       LATTICES                                 ");
	$vrml->comment("------------------------------------------------------------------------");
	my $xy = (defined $X and defined $Y) ? Style::defineLattice( $Style, 'xy', $Map->{X}{minstep} ) : undef;	##---------------------------------------------------------		
	my $yx = (defined $Y and defined $X) ? Style::defineLattice( $Style, 'yx', $Map->{Y}{minstep} ) : undef;	##							   
	my $xz = (defined $X and defined $Z) ? Style::defineLattice( $Style, 'xz', $Map->{X}{minstep} ) : undef;	## 	definition parameters of lattices		   
	my $zx = (defined $Z and defined $X) ? Style::defineLattice( $Style, 'zx', $Map->{Z}{minstep} ) : undef;	## 	(example: xy-> on axis 'X',tendendy 'Y') 	   
	my $yz = (defined $Y and defined $Z) ? Style::defineLattice( $Style, 'yz', $Map->{Y}{minstep} ) : undef;	##							   
	my $zy = (defined $Z and defined $Y) ? Style::defineLattice( $Style, 'zy', $Map->{Z}{minstep} ) : undef;	##---------------------------------------------------------
	if (defined $xy ) {  generateLattice( $Style, $Map, $xy, $http_texdir ); }		## -------------------------------------------------------
	if (defined $yx ) {  generateLattice( $Style, $Map, $yx, $http_texdir ); }		## 
	if (defined $xz ) {  generateLattice( $Style, $Map, $xz, $http_texdir ); }		## draw lattices on defined lattices
	if (defined $zx ) {  generateLattice( $Style, $Map, $zx, $http_texdir ); }		##
	if (defined $yz ) {  generateLattice( $Style, $Map, $yz, $http_texdir ); }		##
	if (defined $zy ) {  generateLattice( $Style, $Map, $zy, $http_texdir ); }		##--------------------------------------------------------
	
	$vrml->comment("------------------------------------------------------------------------");
	$vrml->comment("                   	       OBJECTS                                  ");
	$vrml->comment("------------------------------------------------------------------------");
	generateObjects( $Data, $Style, $Map );

	#$vrml->print(1);				## $vrml->print(1, 'gzip -f9')   		$vrml->print(mime,'pipe')
	#$vrml->save("$file","gzip -f9");		## $vrml->save(undef, 'gzip -f9')		$vrml->save(filename,'pipe')
	$vrml->save("$file");				## viewer Freewrl not supports gzip  
	
	my $htmlHead = htmlHead($variables);								## create header of HTML file
	my $htmlBody = htmlBody($variables);

	open(RT,">$$variables->{file}") || &ErrorDie(" ERROR: can't write into report cache.");		## create HTML file
	print RT <<END; 
$htmlHead
$htmlBody
END
	close(RT);


	return 1;
}

############################################################################################################################################
#--------------------------------------------------------------------------------------------------------------------------------------------

sub generalParameters {
	my $report = shift;
	my $lang = lc(shift);
	my $style = shift;

	#$vrml->navigationinfo('EXAMINE', 1, 1, 1000);	## navigationinfo('type', speed, headlight, visibilityLimit, avatarSize)
	$vrml->backgroundcolor('black');		## backgroundcolor('skyColor', 'groundColor')
	#$vrml->worldinfo( "$report->{name}{$lang}",
	#		[ "Type - $report->{report_type}",
	#		  "Name - $report->{name}{$lang}",
	#		  "Description - $report->{description}{$lang}",
    	#		  "Created - $report->{meta}{created}",
	#		  "Creator - $report->{meta}{creator}",
	#		  "Modifier - $report->{meta}{modifier}",
	#		  "Modified - $report->{meta}{modified}"  ]	);		

	my ($viewpointX,$viewpointY,$viewpointZ) = Style::defineViewpoint($style);

	$vrml->viewpoint_begin;
	$vrml->viewpoint("Start","$viewpointX $viewpointY $viewpointZ","0 1 0 45","45");
	$vrml->viewpoint_set('0 0 0','10','45');
	$vrml->viewpoint_end;

	return $vrml;
}

#-------------------------------------------------------------------------------------------------------------------------------------------

sub localDirToHttpDir {
	my $local_dir = shift;									#/var/www/html/cache_texture_png
	my $path = $local_dir;

	if ( ! -e -d $local_dir ) {
       		mkdir($local_dir);
	}

	my $server = $ENV{SERVER_NAME};		# name of curent webserver			myson.instrat.cz
	my $root = $ENV{DOCUMENT_ROOT}; 	# document root of curent webserver 		/var/www/html
	$path =~ s/$root\///;

	my $http_dir = "http://$server/$path";

	return ($http_dir);
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub generateAxis {
	my $axis = shift;

	my @@translation = @@{$axis->{translation}};
	my @@rotation = @@{$axis->{rotation}};
	my @@color = @@{$axis->{color}};
	my $length =  $axis->{length};

	if (! defined $axis->{crowfoot} ) {				##
		$length = $axis->{length}+$axis->{indent};		## enlargenent length of axis  (length + indent)
		foreach  (@@translation){  				##
        		if ($_ != 0){  					##
                		$_ = $length/2; 			##
        		}
		}
	}
	$vrml->transform_begin("t=@@translation","r=@@rotation");						## draw axis
	vrmlMethods($axis->{format},$axis->{size},$length,$axis->{transparency},@@{$axis->{color}});	## 
	$vrml->transform_end;										##

	if ( defined $axis->{crowfoot} ) {
		my @@translation = @@{$axis->{crowfoot}{translation}};
		my @@rotation = @@{$axis->{crowfoot}{rotation}};
		$vrml->transform_begin("t=@@translation","r=@@rotation");						## draw crowfoot
		vrmlMethods(											##
				$axis->{crowfoot}{format},$axis->{crowfoot}{size},$axis->{crowfoot}{length},	##
				$axis->{crowfoot}{transparency},@@{$axis->{crowfoot}{color}}			##
		);												##
		$vrml->transform_end;										##
	}

	return 1;
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub generateLattice {
	my $Style = shift;							## draw on $axis (X ->step), tendency drawing (Y->length)
	my $Map = shift;
	my $lattice = shift;
	my $http_texdir = shift;

	my @@index = (0);
	my @@rotation = @@{$lattice->{rotation}};
	my @@translation = @@{$lattice->{translation}};

	for (my $i=0;$i < scalar @@{$lattice->{steps}};$i++ ) {
		my ($j); 
		if ( $lattice->{lattice} eq 'xz' ) { $j = 0; }
		if ( $lattice->{lattice} eq 'yx' ) { $j = 1; }
		if ( $lattice->{lattice} eq 'zx' ) { $j = 2; }
		my $align = $lattice->{steps}[$i]{label}{translation}[$j] if ( exists $lattice->{steps}[$i]{label} ) ;
		my $trans = 0;my $title_index = 0;

		while ( $trans <= $lattice->{axis_length} ) {
			my $sign = 0;
			$trans = $trans + $lattice->{steps}[$i]{step};
			$title_index = $title_index + $Style->{lattice}{lc($lattice->{axis})}[$i]{step};		# step can be 1,2,3 ...
			#foreach (@@index) {				# detect if lattice on current place has been drawn
        		#	if ($trans == $_) { $sign = 1; }
			#} 
			if ( $trans <= $lattice->{axis_length} and $sign == 0) {
        			push (@@index,$trans);
        			if ( $lattice->{axis} eq 'X' ) { 
					$translation[0] = $trans; 
					if ( $Map->{$lattice->{axis}}{type} eq 'qualit' ) {
						$lattice->{steps}[$i]{label}{string} = $Map->{$lattice->{axis}}{values}[$title_index] if ( exists $lattice->{steps}[$i]{label} ); 
					}
					elsif ( $Map->{$lattice->{axis}}{type} eq 'quantit' ) {
						$lattice->{steps}[$i]{label}{string} = ($title_index / $Map->{$lattice->{axis}}{scale} ) * $Map->{$lattice->{axis}}{rmin};
					}
				}
        			elsif ( $lattice->{axis} eq 'Y' ) { 
					$translation[1] = $trans; 
					if ( $Map->{$lattice->{axis}}{type} eq 'qualit' ) {
						$lattice->{steps}[$i]{label}{string} = $Map->{$lattice->{axis}}{values}[$title_index] if ( exists $lattice->{steps}[$i]{label} ); 
					}
					elsif ( $Map->{$lattice->{axis}}{type} eq 'quantit' ) {
						$lattice->{steps}[$i]{label}{string} = ($title_index / $Map->{$lattice->{axis}}{scale} ) * $Map->{$lattice->{axis}}{rmin};
					}
				}
        			elsif ( $lattice->{axis} eq 'Z' ) { 
					$translation[2] = $trans; 
					if ( $Map->{$lattice->{axis}}{type} eq 'qualit' ) {
						$lattice->{steps}[$i]{label}{string} = $Map->{$lattice->{axis}}{values}[$title_index] if ( exists $lattice->{steps}[$i]{label} ); 
					}
					elsif ( $Map->{$lattice->{axis}}{type} eq 'quantit' ) {
						$lattice->{steps}[$i]{label}{string} = ( $title_index / $Map->{$lattice->{axis}}{scale} ) + $Map->{$lattice->{axis}}{rmin};
					}
				}  

				if ( $lattice->{steps}[$i]{size} != 0 ) {
					$vrml->transform_begin("t=@@translation","r=@@rotation");						
        				vrmlMethods( 	$lattice->{steps}[$i]{format},
							$lattice->{steps}[$i]{size},
							$lattice->{steps}[$i]{length},
                        			      	$lattice->{steps}[$i]{transparency},
							@@{$lattice->{steps}[$i]{color}} 
	     	        			    );			
        				$vrml->transform_end;
					if ( exists $lattice->{steps}[$i]{label} ) {
	        				if (defined $align) {
	        					$lattice->{steps}[$i]{label}{translation}[$j] = $align + $trans;
	        					generateLabel( $lattice->{steps}[$i]{label}, $http_texdir );
	        				}
					}
				}   
			}
		}
	}  											

	return 1;
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub generateLabel {
	my $p_label = shift;
	my $http_texdir = shift;

	my @@translation = @@{$p_label->{translation}};
	my @@rotation = @@{$p_label->{rotation}};
	my $height = $p_label->{fheight};
	my $width = length($p_label->{string})*$p_label->{fheight};
	
	my $file   = Texture::Textures( $p_label, $Const::texture_dir );
	my (@@coordIndex);

	if ( $p_label->{coord} == 0) {
		@@coordIndex = (0,1,2,3,-1);
	}
	if ( $p_label->{coord} == 90) {
		@@coordIndex = (2,1,0,3,-1);
	}
	if ( $p_label->{coord} == 180) {
		@@coordIndex = (2,3,0,1,-1);
	}

	if ( $p_label->{coord} == 270) {
		@@coordIndex = (1,0,3,2,-1);
	}
	if ( $p_label->{switch} == 1 ) {
		my $temp = $height;
		$height = $width;
		$width = $temp;
	}

	## solid TRUE - vsechny plochy jednostranne
	## ccw TRUE - profil je zadan proti smeru hodinovych rucicek

	$vrml->transform_begin("t=@@translation","r=@@rotation");
	$vrml->insert("Shape {
			geometry IndexedFaceSet {
				solid TRUE
				coord Coordinate  { point [ 0 0 0,
							    $width 0 0,
							    $width $height 0,
					    		    0 $height 0        ] }
				coordIndex [ @@coordIndex ]
				texCoord TextureCoordinate {
				   point [0 0,
					  1 0,
					  1 1,
					  0 1        ]
				}
				texCoordIndex [ 0 1 2 3 -1]
				}
				appearance Appearance {
					texture ImageTexture{url \"$http_texdir/$file.png\" 	
								repeatS FALSE
								repeatT FALSE}
				} 
		     }
		     Shape {
			geometry IndexedFaceSet {
				solid TRUE
				coord Coordinate  { point [ $width 0 0,
							     0 0 0,  
							     0 $height 0 ,
							     $width $height 0,       ] }
				coordIndex [ @@coordIndex ]
				texCoord TextureCoordinate {
				   point [0 0,
					  1 0,
					  1 1,
					  0 1        ]
				}
				texCoordIndex [ 0 1 2 3 -1]
				}
				appearance Appearance {
					texture ImageTexture{url \"$http_texdir/$file.png\" 	
								repeatS FALSE
								repeatT FALSE}
				} 
		     }\n");	# 2 shapes -> front view and back view 
	$vrml->transform_end;	     

	return 1;
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub generateObjects {
	my $Data = shift;
	my $Style = shift;
	my $Map = shift;
#open TEST,">$Const::myPath/html/data.tst";
#print TEST Dumper($Map);
#print TEST Dumper($Data);
#close TEST;
	
	for ( my $i=1; $i < scalar @@{$Data}; $i++ ) {
		my $object = Style::defineObject( $Data->[$i], $Style, $Map );

		if (defined $object) {
			my @@translation = @@{$object->{translation}};
			my @@rotation = @@{$object->{rotation}};	

			$vrml->transform_begin("t=@@translation","r=@@rotation");			## t = translation, r = rotation
			vrmlMethods (								## draw current object
                			$object->{shape},
					$object->{bottom},
					$object->{height},					
					$object->{transparency},
					@@{$object->{color}}					
     			);									
			$vrml->transform_end;
		}
	}

	return 1;
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub vrmlMethods {
	my ($format,$bottom,$height,$transparency,@@color) = @@_;

	if ($format eq 'cylinder'){
		my $radius = $bottom/2;
		$vrml->cylinder("$radius $height","d=@@color;tr=$transparency,");	## cylinder('radius height', 'appearance') ->d = diffuse color
	}
	if ($format eq 'box') {
		my $width =  my $depth = $bottom;
		$vrml->box("$width $height $depth","d=@@color;tr=$transparency,");
	}
	if ($format eq 'sphere') {
		my $radius = $bottom/2;
		$vrml->sphere("$radius","d=@@color;tr=$transparency,");
	}
	if ($format eq 'cone') {
		my $bottomRadius = $bottom/2;
		$vrml->cone("$bottomRadius $height","d=@@color;tr=$transparency,");
	}
	if ($format eq 'pyramid') {
		my $width =  my $depth = $bottom;
		$vrml->pyramid("$width $height $depth","d=@@color;tr=$transparency,");
	}
	if ($format eq 'line') {
		my $from = -$height/2;
		my $to = $height/2;
		$vrml->line("0 $from 0", "0 $to 0", 0,"d=@@color;tr=$transparency,");
	}
	if ($format eq 'quadrilateral') {
		my $tg30 = 0.577350269;
		my $a = $bottom/2;
		my $b = $a * $tg30; 
		my $c = (sqrt(($bottom*$bottom) - ($a*$a))) - $b;
		my $d = $height/2;
		$vrml->indexedfaceset("-$a -$d $b, $a -$d  $b, 0  -$d -$c, 0   $d   0",		## coord
       				      "2 1 0 -1, 0 1 3 -1, 1 2 3 -1, 2 0 3 -1,",		## coordIndex
       				      "d=@@color,@@color,@@color,@@color;tr=$transparency,"				## appearance
				      );
	}
	if ($format eq 'NULL' or $format eq '') {  }

	return 1;
}

#---------------------------------------------------------------------------------------------------------------------------------------------

sub htmlHead {				# return html head of report 
	my $variables = shift;
	my $htmlHead = "";
	
	$htmlHead .= &Local::customHTMLHead(0,0,$$variables->{useEnc},$Const::languages->{$$variables->{useLang}}->{lang},'Report Result');
	
	return $htmlHead;
}

#--------------------------------------------------------------------------------------------------------------------------------------
sub htmlBody {				# return html body of report 
	my $variables = shift;
	my $htmlBody = "";
	my $server = $ENV{SERVER_NAME};
	my $path = "bear";			# =~ /$ENV{SCRIPT_NAME}\///; SCRIPT_NAME' = /bear/run.cgi'
	my $cache = $Const::cache3DReport;
	my $filename = "$$variables->{id}-$$variables->{useLang}.wrl";
	
	$htmlBody = "<script> window.location.href = 'http://$server/$path/$cache/$filename'</script>" ;
	
	return $htmlBody;
}
#--------------------------------------------------------------------------------------------------------------------------------------

1;
@


1.4
log
@fix color for quadrilateral
@
text
@d424 1
a424 1
       				      "d=@@color,@@color,@@color;tr=$transparency,"				## appearance
@


1.3
log
@fix path to .wrl script
@
text
@d424 1
a424 1
       				      "d=@@color;tr=$transparency,"				## appearance
@


1.2
log
@finaly data generation from bear
@
text
@d89 2
a90 5
open(RT,">$$variables->{file}") || &ErrorDie(" ERROR: can't write into report cache.");		## create HTML file
my $http_cachedir = &localDirToHttpDir($Const::cache3DReport);
print RT "$http_cachedir";
print RT "<script> window.location.href = 'http://beaver.instrat.cz/bear/html/aadXQBjfbD-cz.wrl'</script> Graph 3d "; 
close(RT);
d92 6
a98 13
#open TEST,">$Const::myPath/html/data.tst";
#print TEST Dumper($xy);
#print TEST Dumper($yx);
#rint TEST Dumper($xz);
#print TEST Dumper($zx);
#print TEST Dumper($yz);
#print TEST Dumper($zy);
#print TEST Dumper($style);
#print TEST Dumper($report);
#print TEST Dumper($mdata);
#print TEST Dumper($Map);
#print TEST Dumper($Data);
#close TEST;
d434 24
@


1.1
log
@new script generating vrml code
@
text
@a1 1

d9 1
a9 2

use CGI qw(:standard);
d13 1
a13 1
our $vrml;
d15 1
a15 1
##########################################################################################################################################
d19 90
a108 30
#  my $q = new CGI;
#  print $q->header();
 
 our $NAME = shift;					## hash NAME of report
 our $ID   = shift;					## ID of report
 our $lang = shift;					## used lang
 our $wrldir = shift;					## path to cache of wrl scene  
 our $texture_dir = shift;				## path to cache of textures  

 our $LNAME = &Local::LocalizedObj($NAME, "$ID", lc($lang),"en" );
 our $http_texdir = &localDirToHttpDir($texture_dir);	## path to texture directory from web
 our $report = &Style::report($ID,$lang);		## load  report 

 $Run_graph3D::vrml = new VRML(2);
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
 $Run_graph3D::vrml->comment("                    GENERAL PARAMETERS OF SCENE                         ");
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
							&generalParameters($report,lc($lang));
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
 $Run_graph3D::vrml->comment("                            	AXIS                                    ");
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
					my ($X,$Y,$Z) =	&axis;
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
 $Run_graph3D::vrml->comment("                   	       LATTICES                                 ");
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
			 my ($xy,$yx,$xz,$zx,$yz,$zy) = &lattices($X,$Y,$Z);
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
 $Run_graph3D::vrml->comment("                   	       OBJECTS                                 ");
 $Run_graph3D::vrml->comment("------------------------------------------------------------------------");
							&generateObjects;
d110 1
a110 4
 $vrml->print(1,'gzip -f9');				## $vrml->print(1, 'gzip -f9')   		$vrml->print(mime,'pipe')
 $vrml->save("$wrldir/$ID.wrl","gzip -f9");		## $vrml->save(undef, 'gzip -f9')		$vrml->save(filename,'pipe')

 return 1;
d117 21
a137 2
 my $report = shift;
 my $lang = shift;
d139 1
a139 13
    $Run_graph3D::vrml->navigationinfo('EXAMINE', 1, 1, 1000);		## navigationinfo('type', speed, headlight, visibilityLimit, avatarSize)
    $Run_graph3D::vrml->backgroundcolor('black');			## backgroundcolor('skyColor', 'groundColor')
    $Run_graph3D::vrml->worldinfo("Type - $report->{report_type}","Name - $report->{name}{$lang}","Description - $report->{description}",
    		     "Modifier - $report->{meta}{modifier}","Modified - $report->{meta}{modified}");		

 my ($viewpointX,$viewpointY,$viewpointZ) = &defineViewpoint;

 $Run_graph3D::vrml->viewpoint_begin;
# $Run_graph3D::vrml->viewpoint("Start","$viewpointX $viewpointY $viewpointZ","0 1 0 45","45");
 $Run_graph3D::vrml->viewpoint_set('0 0 0','10','45');
 $Run_graph3D::vrml->viewpoint_end;
 
 return 1;
d145 2
a146 10
my $local_dir = shift;									#/var/www/html/cache_texture_png
my $path = $local_dir;

if ( ! -e -d $local_dir ) {
       mkdir($local_dir);
}

my $server = $ENV{SERVER_NAME};		# name of curent webserver			myson.instrat.cz
my $root = $ENV{DOCUMENT_ROOT}; 	# document root of curent webserver 		/var/www/html
$path =~ s/$root\///;
d148 3
a150 1
my $http_dir = "http://$server/$path";
d152 3
a154 25
return ($http_dir);
}

#---------------------------------------------------------------------------------------------------------------------------------------------
sub axis {

 my $X = &Style::defineAxis('X');							## -------------------------------------------------------
 my $Y = &Style::defineAxis('Y');							## 	definition parameters of axis			   
 my $Z = &Style::defineAxis('Z');							##--------------------------------------------------------

 if ( defined $X and $X->{size} != 0 and $X->{length} != 0 ) {			
    &generateAxis('X');	
 }   

 if ( defined $Y and $Y->{size} != 0 and $Y->{length} != 0 ) {			
    &generateAxis('Y');
 }   
 if ( defined $Z and $Z->{size} != 0 and $Z->{length} != 0 ) {			
    &generateAxis('Z');
 }   
 
 return ($X,$Y,$Z);
}

#---------------------------------------------------------------------------------------------------------------------------------------------
d156 1
a156 2
sub lattices {
 my ($X,$Y,$Z) = @@_;
d158 1
a158 16
  my $xy = (defined $X and defined $Y) ? &defineLattice('xy') : undef;		##---------------------------------------------------------		
  my $yx = (defined $Y and defined $X) ? &defineLattice('yx') : undef;		##							   
  my $xz = (defined $X and defined $Z) ? &defineLattice('xz') : undef;		## 	definition parameters of lattices		   
  my $zx = (defined $Z and defined $X) ? &defineLattice('zx') : undef;		## 	(example: xy-> on axis 'X',tendendy 'Y') 	   
  my $yz = (defined $Y and defined $Z) ? &defineLattice('yz') : undef;		##							   
  my $zy = (defined $Z and defined $Y) ? &defineLattice('zy') : undef;		##---------------------------------------------------------


  if (defined $xy ) {  &generateLattice('xy'); }				## -------------------------------------------------------
  if (defined $yx ) {  &generateLattice('yx'); }				## 
  if (defined $xz ) {  &generateLattice('xz'); }				## draw lattices on defined lattices
  if (defined $zx ) {  &generateLattice('zx'); }				##
  if (defined $yz ) {  &generateLattice('yz'); }				##
  if (defined $zy ) {  &generateLattice('zy'); }				##--------------------------------------------------------
  
  return ($xy,$yx,$xz,$zx,$yz,$zy);
d164 1
a164 1
my $axis = shift;
d166 27
a192 30
my @@translation = @@{$$axis->{translation}};
my @@rotation = @@{$$axis->{rotation}};
my @@color = @@{$$axis->{color}};
my $length =  $$axis->{length};

 if (! defined $$axis->{crowfoot} ) {				##
    $length = $$axis->{length}+$$axis->{indent};		## length of axis is enlarge (length + indent)
    foreach  (@@translation){  					##
             if ($_ != 0){  					##
                $_ = $length/2; 				##
             }
    }
 }
 $Run_graph3D::vrml->transform_begin("t=@@translation","r=@@rotation");						## draw axis
 &vrmlMethods($$axis->{format},$$axis->{size},$length,$$axis->{transparency},@@{$$axis->{color}});	## 
 $Run_graph3D::vrml->transform_end;											##
 
 if ( defined $$axis->{crowfoot} ) {
  my @@translation = @@{$$axis->{crowfoot}{translation}};
  my @@rotation = @@{$$axis->{crowfoot}{rotation}};
     $Run_graph3D::vrml->transform_begin("t=@@translation","r=@@rotation");						## draw crowfoot
     &vrmlMethods(											##
                  $$axis->{crowfoot}{format},$$axis->{crowfoot}{size},$$axis->{crowfoot}{length},	##
                  $$axis->{crowfoot}{transparency},@@{$$axis->{crowfoot}{color}}				##
     		  );											##
     $Run_graph3D::vrml->transform_end;										##
 }
 if ( defined $$axis->{label} ) {
    &generateLabel($$axis->{label});
 }
d194 1
a194 1
 return 1;
d200 73
a272 42
my $lattice = shift;
my ($axis,$tendency) = uc($lattice) =~ /(.)(.)/ ;			## draw on $axis (X ->step), tendency drawing (Y->length)
my @@index = (0);
my @@rotation = @@{$$lattice->{rotation}};
my @@translation = @@{$$lattice->{translation}};

 for (my $i=0;$i < @@{$$lattice->{steps}};$i++ ) {
    my ($j); 
    if ( $lattice eq 'xz' ) { $j = 0; }
    if ( $lattice eq 'yx' ) { $j = 1; }
    if ( $lattice eq 'zx' ) { $j = 2; }
    my $align = $$lattice->{steps}[$i]{label}{translation}[$j];
    my $trans = 0;my $title = 0;
    while ( $trans <= $$axis->{length} ) {
       my $sign = 0;
       $trans = $trans + $$lattice->{steps}[$i]{step};
       $title = $title + $Style::Style->{lattice}{lc($axis)}[$i]{step};
       foreach (@@index) {
          if ($trans == $_) { $sign = 1; }
       } 
       if ( $trans <= $$axis->{length} and $sign == 0) {
          push (@@index,$trans);
          if ( $axis eq 'X' ) { $translation[0] = $trans; $$lattice->{steps}[$i]{label}{string} = $Style::Map->{$axis}{values}[$title] }
          elsif ( $axis eq 'Y' ) { $translation[1] = $trans; $$lattice->{steps}[$i]{label}{string} = $Style::Map->{$axis}{values}[$title] }
          elsif ( $axis eq 'Z' ) { $translation[2] = $trans; $$lattice->{steps}[$i]{label}{string} = $Style::Map->{$axis}{values}[$title] }  

          if ( $$lattice->{steps}[$i]{size} != 0 ) {
	     $Run_graph3D::vrml->transform_begin("t=@@translation","r=@@rotation");						
             &vrmlMethods( $$lattice->{steps}[$i]{format},$$lattice->{steps}[$i]{size},$$lattice->{steps}[$i]{length},
                           $$lattice->{steps}[$i]{transparency},@@{$$lattice->{steps}[$i]{color}} 
	     	         );			
             $Run_graph3D::vrml->transform_end;
	     if ( defined $$lattice->{steps}[$i]{label} ) {
	        if (defined $align) {
	           $$lattice->{steps}[$i]{label}{translation}[$j] = $align + $trans;
	           &generateLabel($$lattice->{steps}[$i]{label});
	        }
	     }
	  }   
       }
    }
 }  											
d274 1
a274 2

return 1;
d280 2
a281 31
my $p_label = shift;

my @@translation = @@{$p_label->{translation}};
my @@rotation = @@{$p_label->{rotation}};
my $height = $p_label->{fheight};
my $width = length($p_label->{string})*$p_label->{fheight};
;
my $file   = &Texture::Textures($p_label->{string},$p_label->{font},$p_label->{fontsize},$Run_graph3D::texture_dir,@@{$p_label->{color}});
my (@@coordIndex);

if ( $p_label->{coord} == 0) {
   @@coordIndex = (0,1,2,3,-1);
}
if ( $p_label->{coord} == 90) {
   @@coordIndex = (2,1,0,3,-1);
}
if ( $p_label->{coord} == 180) {
   @@coordIndex = (2,3,0,1,-1);
}

if ( $p_label->{coord} == 270) {
   @@coordIndex = (1,0,3,2,-1);
}
if ( $p_label->{switch} == 1 ) {
   my $temp = $height;
   $height = $width;
   $width = $temp;
}

## solid TRUE - vsechny plochy jednostranne
## ccw TRUE - profil je zadan proti smeru hodinovych rucicek
d283 76
a358 24
  $Run_graph3D::vrml->transform_begin("t=@@translation","r=@@rotation");
  $Run_graph3D::vrml->insert("Shape {
		geometry IndexedFaceSet {
			solid FALSE
			coord Coordinate  { point [ 0 0 0,
						    $width 0 0,
						    $width $height 0,
					    	    0 $height 0        ] }
			coordIndex [ @@coordIndex ]
			texCoord TextureCoordinate {
			   point [0 0,
				  1 0,
				  1 1,
				  0 1        ]
			}
			texCoordIndex [ 0 1 2 3 -1]
			}
			appearance Appearance {
				texture ImageTexture{url \"$Run_graph3D::http_texdir/$file.png\" 	
							repeatS FALSE
							repeatT FALSE}
			} 
	     }\n");
  $Run_graph3D::vrml->transform_end;	     
d360 1
a360 1
return 1;
d366 26
d393 1
a393 17
for ( my $i=1;$i <= $Style::Data;$i++ ) {
    my $obj = &defineObject($Style::Data[$i]);

 if (defined $obj) {
 my @@translation = @@{$obj->{translation}};
 my @@rotation = @@{$obj->{rotation}};	

   $Run_graph3D::vrml->transform_begin("t=@@translation","r=@@rotation");				## t = translation, r = rotation
   &vrmlMethods (											##
                  $obj->{shape},$obj->{bottom},$obj->{height},$obj->{transparency},@@{$obj->{color}}	##
     		);											##
   $Run_graph3D::vrml->transform_end;
 }

}

return 1;
d399 1
a399 1
my ($format,$bottom,$height,$transparency,@@color) = @@_;
d401 37
a437 37
  if ($format eq 'cylinder'){
     my $radius = $bottom/2;
     $Run_graph3D::vrml->cylinder("$radius $height","d=@@color;tr=$transparency,");	## cylinder('radius height', 'appearance') ->d = diffuse color
  }
  if ($format eq 'box') {
     my $width =  my $depth = $bottom;
     $Run_graph3D::vrml->box("$width $height $depth","d=@@color;tr=$transparency,");
  }
  if ($format eq 'sphere') {
     my $radius = $bottom/2;
     $Run_graph3D::vrml->sphere("$radius","d=@@color;tr=$transparency,");
  }
  if ($format eq 'cone') {
     my $bottomRadius = $bottom/2;
     $Run_graph3D::vrml->cone("$bottomRadius $height","d=@@color;tr=$transparency,");
  }
  if ($format eq 'pyramid') {
     my $width =  my $depth = $bottom;
     $Run_graph3D::vrml->pyramid("$width $height $depth","d=@@color;tr=$transparency,");
  }
  if ($format eq 'line') {
     my $from = -$height/2;
     my $to = $height/2;
     $Run_graph3D::vrml->line("0 $from 0", "0 $to 0", 0,"d=@@color;tr=$transparency,");
  }
  if ($format eq 'quadrilateral') {
     my $tg30 = 0.577350269;
     my $a = $bottom/2;
     my $b = $a * $tg30; 
     my $c = (sqrt(($bottom*$bottom) - ($a*$a))) - $b;
     my $d = $height/2;
     $Run_graph3D::vrml->indexedfaceset("-$a -$d $b, $a -$d  $b, 0  -$d -$c, 0   $d   0",	## coord
       			   "2 1 0 -1, 0 1 3 -1, 1 2 3 -1, 2 0 3 -1,",		## coordIndex
       			   "d=@@color;tr=$transparency,"				## appearance
			   );
  }
  if ($format eq 'NULL' or $format eq '') {  }
d439 1
a439 1
 return 1;
@

