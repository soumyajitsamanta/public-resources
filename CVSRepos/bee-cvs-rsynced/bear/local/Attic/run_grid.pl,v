head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2003.10.31.12.47.57;	author jiri_schmid;	state dead;
branches;
next	1.1;

1.1
date	2003.10.16.14.08.53;	author jiri_schmid;	state Exp;
branches;
next	;


desc
@@


1.2
log
@mod perl rocks!
@
text
@#-----------------------------------------------------
#  Rendering of the Report in Grid format
#-----------------------------------------------------
# $Id: run_grid.pl,v 1.1 2003/10/16 14:08:53 jiri_schmid Exp $

use strict;
our($file,$use_enc,$use_lang,$skinPath,@@export,@@sort,$RLang);

#---------------------------------------------------
sub exportToHTML() {
my $hlp;

	my $ID = shift;
	my $css = shift;
	my $header = shift;
	my $data = shift;	# ptr to data hash
	$header = $header ? $header : 'none';


	print header(-charset=>$use_enc);

	open(RT,">$cacheReport/$file") || &ErrorDie(" ERROR: can't write into report-disk-cache.");
	binmode(RT,":utf8");
	
	print RT <<END;
<?xml version="1.0" encoding="$use_enc"?>
<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$Languages->{$use_lang}->{lang}" xml:lang="$Languages->{$use_lang}->{lang}">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=$use_enc" />
<title>Report Result</title>
<style>\@@import url("./CSS/$css.css");</style>
<style>\@@import url("${skinPath}menu.css");</style>
<script type="text/javascript" src="js/right_menu.js"></script>
</head>
<body onload="init_menu()">
<input type='hidden' value='$ID' id='ID' name='id' />
<input type='hidden' value='$use_lang' id='LANG' name='lang' />
<div class="Menu" id="userMenu" style="display:block; position:absolute; top:0px; left:0px; visibility:hidden; z-index:5;"  onmouseover='hideSubmenus()'></div>
<div class="Menu" id="userSubMenu" style="display:block; position:absolute; top:0px; left:0px; visibility:hidden; z-index:6;"></div>
END
	print RT &descriptionTable('out', $data) if $header eq 'outerTable';
	print RT "<table>";
	my($row,$col);
	my(@@colBorder,@@rowBorder);
	@@colBorder = initBorder('col', $data);
	@@rowBorder = initBorder('row', $data);
	my $groupCols = (exists $$data->{row}[0]) ? ($#{$$data->{row}[0]} > 0) ? @@{$$data->{row}[0]} : 1 : 1;
	my $groupRows = (exists $$data->{col}[0]) ? ($#{$$data->{col}[0]} > 0) ? @@{$$data->{col}[0]} : 1 : 1;
	my $headerCell = (exists $$data->{row}[0] && exists $$data->{col}[0]) ? 1 : 0; #run printing col header
	$headerCell++ if $header =~ /innerCol|innerTable|innerRow/; #run printing col header when description of some header is needed
	$headerCell++ if $header =~ /outerTable|none/ && exists $$data->{col}[0]; #run printing col header when col data are presented and no header desc is needed
	if ($headerCell) {
	for ($row = 0;$row < $groupRows; $row++) {
		print RT "<tr>";
		if ($header eq 'none' && $row == 0 && exists $$data->{row}[0]) {
			print RT printHeaderCell('&nbsp',"ch r",$groupCols,$groupRows);	
		} elsif ($header eq 'innerCol') {
			print RT printHeaderCell($$data->{colHeader}->{$row}{name},"ch r",$groupCols,undef,"style='text-align:right !important;'");	
		} elsif ($row == 0) {
			if  ($header eq 'innerTable') {
				print RT printHeaderCell(&descriptionTable('in', $data),"ch r",$groupCols,$groupRows);
			} elsif ($header eq 'innerRow') {
				my $cssH = "d";
				for (0..$#{$$data->{row}[0]}) {
					$cssH = "r" if $_ == $#{$$data->{row}[0]};
					print RT printHeaderCell($$data->{rowHeader}->{$_}{name},"ch $cssH",undef,$groupRows,"style='vertical-align:bottom'");
				}
			} elsif ($header eq 'outerTable' && exists $$data->{row}[0]) {
				print RT printHeaderCell('&nbsp',"ch r",$groupCols,$groupRows);
			};
		};
		my $cssR;
		$col = 0;
		while ($col < @@{$$data->{col}}) {
			my $count = 1;
			my $colIndex = $col;
			my $colspan = 0;
			while ($count) {
				if ($colBorder[$col]) {
					$count = 0;
				} else {
					if ($col < @@{$$data->{col}}-1) {
						if ($$data->{col}[$col][$row] ne $$data->{col}[$col+1][$row]) { $colBorder[$col] = 2; $count = 0;}
					};
				}
				$colspan++;
				$col++;
			}
			$cssR = ($colBorder[$col-1] == 1) ? 'r' : 'd';	#border style fo col header
			print RT printHeaderCell("$$data->{col}[$colIndex][$row]|$$data->{colHeader}->{$row}{id}","ch $cssR",$colspan,undef,"id='c.$colIndex.$row'");
		}
		print RT "</tr>";
	}
	};
	my $cssHlp = 'e';
	my $cnt = 0;						#row area color
	my $lastCol = (exists $$data->{row}[0]) ? $#{$$data->{row}[0]} : -1; 
	for ($row = 0; $row < @@{$$data->{row}}; $row++) {
		print RT "<TR>";
		my $cssB = '';					#border style
		$cnt++;
		my $cssC;
		if ($rowBorder[$row] == 1){
			$cssB = 't';
			$cssHlp = ($cssHlp eq 'e') ? 'o' : 'e';		#set row area color
		};
		for ($col = 0; $col < @@{$$data->{row}[0]}; $col++) {
			$cssC = (($cnt%2) == 1 && $lastCol == $col) ? $cssHlp."o" : $cssHlp."e";	#each row color depending on row area color
			if (!$rowBorder[$row]) {
				if ($$data->{row}[$row-1][$col] ne $$data->{row}[$row][$col]) { $rowBorder[$row] = $col+1; }
			};
			my $cssR = ($col == @@{$$data->{row}[0]}-1) ? 'tr' : 't';	#border style for last col in row header
			if ($rowBorder[$row] && $col+1 >= $rowBorder[$row]) {
				my $count = 1;
				my $rowspan = 1;
				my $rowIndex = $row+1;
				while ($count) {
					if ($rowBorder[$rowIndex] || $rowIndex >= @@{$$data->{row}}) {
						$count = 0;
					} else {
						if (!$rowBorder[$rowIndex] && $$data->{row}[$rowIndex][$col] ne $$data->{row}[$rowIndex-1][$col]) { $rowBorder[$rowIndex] = $col+1; last;}
						$rowspan++;
						$rowIndex++;
					}
				}
				$hlp = printHeaderCell("$$data->{row}[$row][$col]|$$data->{rowHeader}->{$col}{id}","$cssC $cssB$cssR",undef,$rowspan,"id='r.$col.$row'") if ($col == 1 && $row == 0);
				print RT printHeaderCell("$$data->{row}[$row][$col]|$$data->{rowHeader}->{$col}{id}","$cssC $cssB$cssR",undef,$rowspan,"id='r.$col.$row'"); 
				};
		};
		for ($col = 0; $col < @@{$$data->{col}}; $col++) {
			my $cssR = ($colBorder[$col] == 1) ? 'tr' : 'td';		#border style for cells
			print RT printCell($$data->{c}{$row}{$col},"$cssC $cssB$cssR");
		}
		print RT "</TR>"
	}

	print RT "</table>";

	my @@objectLinks;
	my @@links;
	my $links;
	foreach my $ID (keys %{$$data->{links}}) {
		undef @@links;
		foreach (keys %{$$data->{links}{$ID}{current}}) {
			push(@@links,$_,$$data->{links}{$ID}{current}{$_});
		}
		$links = join("|",@@links);
		push (@@objectLinks,"'current$ID':'$links'");
		undef @@links;
		foreach (keys %{$$data->{links}{$ID}{down}}) {
			push(@@links,$_,$$data->{links}{$ID}{down}{$_});
		}
		$links = join("|",@@links);
		push (@@objectLinks,"'down$ID':'$links'");
		undef @@links;
		foreach (keys %{$$data->{links}{$ID}{up}}) {
			push(@@links,$_,$$data->{links}{$ID}{up}{$_});
		}
		$links = join("|",@@links);
		push (@@objectLinks,"'up$ID':'$links'");
	}

	$links = join("|",@@export);
	push (@@objectLinks,"'export':'$links'");
	$links = join("|",@@sort);
	push (@@objectLinks,"'sort':'$links'");
	foreach my $type ('rowHeader','colHeader') {
		my $ok = 0;
		undef @@links;
		do {
			if (exists $$data->{$type}{$ok}) {
				push (@@links, "$ok|$$data->{$type}{$ok}{name}");
				my $hlp = $ok;
				$hlp += 0.5;
				$ok++;
				push (@@links, "$hlp|MID");
			} else {
				undef $ok;
			}
		} while ($ok);
		$links = join("|",@@links);
		if ($type eq 'rowHeader') {
			push (@@objectLinks,"'pivotY':'$links'")
		} else {
			push (@@objectLinks,"'pivotX':'$links'")
		}
	}
	undef @@links;
	foreach (keys %{$RLang}) {
		push (@@links,"'$_':'$RLang->{$_}'");
	}
	$links = join(",",@@links);
	my $objectLinks = join(",",@@objectLinks);
	print RT "<script type='text/javascript'>var objectLinks = {$objectLinks}; var lang = {$links};</script>";

# === PrepareSQL Dump ===
#use Data::Dumper;
#my $sql = Dumper(SOAP->PrepareSQL($ID));
#$sql =~ s/([{}])/<b>$1<\/b>/g;
#print RT '<hr><h2>PrepareSQL:</h2><pre>'.$sql.'</pre>';
#print RT '<hr><h2>Data:</h2><pre>'.Dumper($$data).'</pre>';
# === PrepareSQL Dump ===

	print RT "</body></html>";
	close(RT);
}

#---------------------------------------------------
sub initBorder {
	my $what = shift;
	my $data = shift;
	my @@rtrn;

	if ($what eq 'col') {
		my $cnt = (ref($$data->{col})) ? @@{$$data->{col}} : 1;
		for (my $i = 0; $i < $cnt-1; $i++) {
			if ($$data->{col}[$i][0] eq $$data->{col}[$i+1][0]) { push(@@rtrn,undef) }
			else { push(@@rtrn,1) }; 	# return something like nnn1nnn1nn..../ indicates the right solid border is necessary
		}
		push(@@rtrn,1);
	} elsif ($what eq 'row') {
		push(@@rtrn,1);
		my $cnt = (ref($$data->{row})) ? @@{$$data->{row}} : 0;
		for (my $i = 1; $i < $cnt; $i++) {
			if ($$data->{row}[$i][0] eq $$data->{row}[$i-1][0]) { push(@@rtrn,undef) }
			else { push(@@rtrn,1) };		# returns something like 1nnn1nnn1nn..../ indicates the top sollid border is necessary
		}
	}
	return @@rtrn
}

#---------------------------------------------------
sub printHeaderCell (){
	my($content,$css,$cols,$rows,$add) = @@_;
	my @@content = split(/\|/,$content);
	my $menu = " oncontextmenu=\"return showMenu(this,'$content[1]')\"" if defined $content[1];
	$menu .= " onclick='MA(this)'";
	$css = " class='$css'" if $css;
	my $printCols = ($cols > 1) ? " colspan='$cols'" : "";
	my $printRows = ($rows > 1) ? " rowspan='$rows'" : "";
	return "<th $add$css$printCols$printRows$menu>$content[0]</th>"
}
#---------------------------------------------------
sub printGroupedCell() {
	my($content,$css,$cols,$rows,$add) = @@_;
	$css = " class='$css'" if $css;
	my $printCols = ($cols > 1) ? " colspan='$cols'" : "";
	my $printRows = ($rows > 1) ? " rowspan='$rows'" : "";
	return "<td $add$css$printCols$printRows>$content</td>"
}
#---------------------------------------------------
sub printCell() {
	my($content,$css,$add) = @@_;
	$css = " class='$css'" if $css;
	return "<td $add$css>$content</td>"
}

#---------------------------------------------------
sub descriptionTable {
	my $type = shift;
	my $data = shift;
	my $table = "<table style='border:0; width:100%;'>" if $type eq 'in';
	$table = "<table>" if $type eq 'out';
	my $lastY = (exists $$data->{row}[0]) ? ($#{$$data->{row}[0]} > 0) ? $#{$$data->{row}[0]} : 0 : 0;
	my $lastX = (exists $$data->{col}[0]) ? ($#{$$data->{col}[0]} > 0) ? $#{$$data->{col}[0]} : 0 : 0;
	for my $x (0..$lastX) {
		$table .= "<tr>";
		for my $y (0..$lastY) {
			if ($y == $lastY && $x == $lastX) {
				$table .= &printHeaderCell($$data->{colHeader}->{$x}{name}."<br>".$$data->{rowHeader}->{$y}{name},"ee",undef,undef,"style='border-style:dotted; border-width:1px;'")
			}
			elsif ($y == $lastY) {
				$table .= &printHeaderCell($$data->{colHeader}->{$x}{name},"ee",undef,undef,"style='border-style:dotted; border-width:1px; vertical-align:bottom;'")
			} elsif ($x == $lastX) {
				$table .= &printHeaderCell($$data->{rowHeader}->{$y}{name},"ee",undef,undef,"style='border-style:dotted; border-width:1px; vertical-align:bottom'")
			} else {
				$table .= &printHeaderCell('&nbsp',"ee")
			}
		}
		$table .= "</tr>";
	}
	$table .= "</table>";
	return $table
}

#---------------------------------------------------
1
@


1.1
log
@mod-perl implementation stage 1, rebuilding global vars in .pl to global pointers
@
text
@d4 1
a4 1
# $Id: run_grid.pl,v 1.29 2003/10/13 14:43:16 jiri_schmid Exp $
@

