head	1.7;
access;
symbols
	start:1.1.1.1 vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.09.12.09.12.29;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.12.23.26.35;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.05.15.39.40;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.29.14.47.16;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.29.12.58.33;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.26.07.52.42;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.01.34.02;	author michald;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.24.01.34.02;	author michald;	state Exp;
branches;
next	;


desc
@@


1.7
log
@user@@pass url
@
text
@# $Id: conf.pm,v 1.6 2003/03/12 23:26:35 numberone Exp $

package conf;

use Data::Dumper;
use strict;

use url;
use XML::Simple;

our $conf;

# working
sub deny {
	my($pkg,$key) = @@_;
	my $deny = $conf->{deny}->{key};
	return 0 unless $deny;

	foreach(@@$deny) {
		return 1 if($key eq $_);
	}

	return 0;
}

sub hosts { keys %{$conf->{host}} }


sub port { $conf->{global}->{port} or 2332 }

# deprecated
# return keys of registered dads
sub dads { @@{$conf->{dadlist}->{key}} }


# return list of all databases and filesystems
# fix: there may be multiple records in <auth><source><item> 
# for one database or filesystem (diff. user/pass or subdir settings),
# so we must unique it. this code works fine for dbi://, not for dir://
sub sources { 
	my($pkg,$grep) = @@_;
	my $list = $conf->{source}->{item};

	my %uniq;
	foreach(keys %$list) {
		next unless($_ =~ /$grep/);

		my $hash = new url($_);
		undef $hash->{user};
		undef $hash->{pass};
		undef $hash->{table};
		undef $hash->{fields};

		my $url = url::construct($hash);

		$uniq{$url}++;
	}

	return keys %uniq;
}

sub new {
	my($pkg,$file) = @@_;
	my(@@auth,@@dad,@@source,@@query,@@passwd,$acl);

	# read global configuration
	$conf = XMLin($file,
				forcearray => [qw/item key read write exe lib install/],
				keyattr	   => [qw/user url name/]);

# global -> port
# deny -> key -> @@
# dadlist -> key -> @@
# authlist -> key -> @@
# query -> item -> $url -> content -> $sql
# source -> item -> $url -> password -> $pwd
# acl -> lib -> $user -> path -> $path  # should be array
# acl -> install -> $user -> path -> $path
# acl -> read -> [ {} ]

}


# use: my($conf,$auth,$dad,$source,$query,$acl) = 
# 			new conf("./auth.conf",{default=>'config settings hash'})
#
#      $acl->user($user)            - allowed user? returns 1/0
#      $acl->capable($dad,$url)     - is dad capable access url?
#      $acl->read($user,$dad,$url)  - can $user read  $url? return 1/0
#      $acl->write($user,$dad,$url) - can $user write $url? return 1/0

sub oldnew {
	my($pkg,$conffile,$conf) = @@_;
	my $list = 'conf';

	my(@@auth,@@dad,@@source,@@query,@@passwd,$acl);

	open(CONF,$conffile) or die "$conf\: $!\n";
	while(<CONF>) {
		chomp;
		next if(/^\#/ or /^\s*$/);
		if(/^\=\=\s+(.+)/) {
			$list = $1;
			if($list eq 'acl') {
				$acl = read_acl();
				last;
			}
			next;
		}
		die unless $list;

		my @@line = split(/[\s\t]+/,$_);
		if($list eq 'conf') {
			if(/\s+/) { $conf->{$`} = $'; chomp($conf->{$`}) }
				 else { $conf->{$_} = 1 }
		} elsif($list eq 'auth') {
			die "auth: host port key" unless(@@line == 3);
			push @@auth,{host=>$line[0],port=>$line[1],key=>$line[2]};
		} elsif($list eq 'dad') {
			die "dad: host port key" unless(@@line == 3);
			push @@dad,{host=>$line[0],port=>$line[1],key=>$line[2]};
		} elsif($list eq 'source') {
			push @@source,$_;
		} elsif($list eq 'query') {
			die "query: dbiurl system-command" unless(/\s+/);
			my $url = url::split($`);
			push @@query,{dbi=>$url,query=>$'};
		} elsif($list eq 'password') {
			die "password: dbiurl login password" unless(/\s+/);
			my $url = url::split($`);
			push @@passwd,{dbi=>$url,credit=>$'};
		}
	}
	close(CONF);

	return ($conf,\@@auth,\@@dad,\@@source,\@@query,\@@passwd,$acl);
}


# ---------------------------------------------
#  Access Control List

my %handler = ( # what to do on specified config's  keyword
	user  => \&adduser,

	read  => sub { shift->addsource('read', @@_) },
	write => sub { shift->addsource('write',@@_) },

	list => \&addlist,
);

sub read_acl {

	my $acl = bless {
		user  => [], # allowed/denied users
		read  => {}, # source->users
		write => {},
		list  => {}, # list-name -> string's array
	}, __PACKAGE__;

	my $next = '';
	while($next or not eof CONF) {
		my $line = $next;
		while(1) {
			$next = <CONF>; 
			last unless defined $next;
			chomp($next);
			next if($next =~ /^\#/);
			last if($next !~ /^\s+(.*)/);
			$line .= $1;
		}
		next if($line eq '');

		my($key,@@words) = split(/\s+/,$line);
		die "unknown key \`$key\'" unless(exists $handler{$key});

		&{$handler{$key}}($acl,@@words);
	}

	return $acl;
}


sub user {
	my($acl,$user) = @@_;
	my $ret = scanlist($user,\&solveuser,@@{$acl->{user}});
	return defined $ret ? $ret : 0; # deny if unknown
}


sub solveuser {
	my($user,$word) = @@_;
	die "user=$user ??" unless($user =~ /^(.*)\@@(.+)/);

	my($bob,$bobhost) = ($1,$2);
	my($acl,$aclhost);
	if($word =~ /\@@/) { $acl = $`; $aclhost = $' }
				 else { $acl = $word; $aclhost = '' }

	return 0 unless($acl eq ''     or $acl eq $bob);
	return 0 unless($aclhost eq '' or $aclhost eq $bobhost);
	return 1;
}


# returns undef/0/1
sub scanlist {
	my $subject = shift;
	my $authfx = shift;
	foreach(@@_) {
		#print "cmp $subject vs $_\n";
		if(ref eq 'ARRAY') {  # call recursively
			my $ret = scanlist($subject,$authfx,@@$_);
			return $ret if defined $ret;
		}
		if(/^\+(.*)/) { return 1 if(&$authfx($subject,$1)) }
		if(/^\-(.*)/) { return 0 if(&$authfx($subject,$1)) }
	}
	return undef;
}


sub importlist {
	my $acl = shift;
	foreach(@@_) {
		if($_ =~ /^\\(.+)/) {
			die "unknown list \`$1\'" unless exists $acl->{list}->{$1};
			$_ = $acl->{list}->{$1};
		}
	}
}


sub addlist {
	my $acl  = shift;
	my $name = shift;
	die if($name !~ /^[\w\-]+$/);
	die "list \`$name\' already exists" if exists $acl->{list}->{$name};
	$acl->importlist(@@_);
	$acl->{list}->{$name} = \@@_;
}


sub adduser {
	my $acl = shift;
	$acl->importlist(@@_);
	push @@{$acl->{user}}, @@_;
}


sub addsource { 
	my($acl,$access,$source) = splice @@_,0,3;
	$acl->importlist(@@_);
	push @@{$acl->{$access}->{$source}}, @@_;
}


sub capable {
	my($acl,$dad,$url) = @@_;

	if($url->{proto} eq 'dir') {
#		if($dad->{host} eq $url->{host} and 
#		   slave::eqdadports($dad->{port},$url->{port})) {
				# todo: ma to v nejakem podstromu?
				return 1;
#		}
	} elsif($url->{proto} eq 'dbi') {
		# todo: has dad $proto-$subproto DBD?
		return 1;
	} else {
		return 0;
	}

	return 0; 
}


sub read { # fix: k cemu je nam tady $dad ??
	my($acl,$user,$dad,$url) = @@_;
#	print "$user wants read url: ",Dumper($url);

	# todo: tak uz to konecne dopis, martine!!
	return undef;

	my $allow = 1; my $deny = 0;
	foreach(keys %{$acl->{read}}) {
		# if match
		#    if allow $_->list $allow = 1
		#    if deny  $_->llist $deny = 1
		print "$_\n";
	}
	# projed vsechny zdroje vyjmenovane v acl
	# jestli source->0

#	my $ret = scanlist([$user,$dad,$url],\&solveaccess,@@{$acl->{read}});
#	return defined $ret ? $ret : 0; # deny if unknown
	return 1;
}


1;


@


1.6
log
@added xml configuration file - new syntax
acl still not working
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.5 2003/02/05 15:39:40 numberone Exp $
d50 1
@


1.5
log
@SSL to INET - for testing...
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.4 2002/09/29 14:47:16 numberone Exp $
d9 73
d91 1
a91 1
sub new {
d282 1
a282 1
	return 1;
@


1.4
log
@table query seems to work
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.3 2002/09/29 12:58:33 numberone Exp $
d119 1
a119 1
	die unless($user =~ /^(.+)\@@(.+)/);
@


1.3
log
@tablequery
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.2 2002/09/26 07:52:42 numberone Exp $
d22 1
a22 1
	my(@@auth,@@dad,@@source,@@query,$acl);
d54 4
d62 1
a62 1
	return ($conf,\@@auth,\@@dad,\@@source,\@@query,$acl);
@


1.2
log
@version merging with my cvs
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.1.1.1 2002/09/24 01:34:02 michald Exp $
d8 3
a10 1
# use: my($conf,$auth,$dad,$source,$acl) = 
d22 1
a22 1
	my(@@auth,@@dad,@@source,$acl);
d50 4
d58 1
a58 1
	return ($conf,\@@auth,\@@dad,\@@source,$acl);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $Id: conf.pm,v 1.9 2002/08/28 21:31:14 martin Exp $
d218 1
@


1.1.1.1
log
@Initial public release of BEE Project.
@
text
@@
