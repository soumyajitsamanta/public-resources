head	1.7;
access;
symbols
	start:1.1.1.1 vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.06.03.13.15.39;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.12.23.26.35;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.17.23.34.48;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.29.14.47.16;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.29.12.58.33;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.26.07.52.42;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.01.34.03;	author michald;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.24.01.34.03;	author michald;	state Exp;
branches;
next	;


desc
@@


1.7
log
@bee-0.9.1 -- version merge
@
text
@# $Id: slave.pm,v 1.6 2003/03/12 23:26:35 numberone Exp $

package slave;

use lib '../lib';
use Msg;
use url;

use Data::Dumper;
use strict;


sub new {
	my($pkg,$msg) = @@_;
	my $user = $msg->auth;

	if(conf->deny($user)) {
		# fix: audit
		print "$user ignoring connection\n";
		undef $msg; # close
		return undef;
	}

	print "$user connected\n";
	# fix: audit

	return bless {
		msg  => $msg,
		user => $user,
		peer => $msg->peer,
		auth => $msg->auth,
	}, $pkg;
}

sub peek { shift->{msg}->peek }

sub close {
	my $self = shift;
	$self->{closed} = 1;

	print $self->{user}." closed\n";
}

# =================================================================

our $slave; # global for xmlrpc

my $methods = {
	dads    => sub { audit("dads",undef);    
					 my @@dads = conf->dads;
					 return \@@dads; },
	sources => sub { audit("sources",undef); 
					 my @@sources = conf->sources;
					 return \@@sources; },
	read    => \&rpc_read,
	write   => \&rpc_write,
	tablequery => \&rpc_tablequery,

	hosts	=> sub { audit("hosts",undef);
					 my @@hosts = conf->hosts;
					 return \@@hosts; },
	
	key => sub { conf->deny(@@_) },
};


sub serve {
	$slave = shift; # set global
	$slave->{msg}->serve($methods);
	$slave = undef;
}

sub audit {
	my($fx,$reply,$return) = @@_;
	my $now = localtime(time);
	print $slave->{user}," $fx? ",(defined $reply ? $reply : "ALLOW"),"\n";
	return defined $return ? $return : $reply;
}



sub credit {
	my($url) = @@_;
	foreach(@@$::passwd) {
		my $p = $_->{dbi};
		if( halfeq($url->{proto},   $p->{proto})    and
			halfeq($url->{subproto},$p->{subproto}) and
			halfeq($url->{host},$p->{host}) and
			halfeq($url->{port},$p->{port}) and
			halfeq($url->{db},  $p->{db}) 	and
			halfeq($url->{user},$p->{user})) {
				return $_->{credit};
		}
	}
	return undef;
}


sub rpc_read {
	my($user,$full) = @@_;
	my $dad = $slave->{auth};

	return "honey";

	# fix: ??? - co toto je??
	$user = $slave->{user} unless $user;

	my $audit = "read(\`$user\',\`$dad\',\`$full\')";

	# 1) allowed user?
	return audit($audit,"user denied by acl",'') if(!$main::acl->user($user));

	my $url = url::split($full);
	my($source,$table,@@fields) = url::source($full);

	return audit($audit,"wrong params",'') if(!$dad or !$full);
	$dad = finddad($dad);
	return audit($audit,"unknown dad $dad",'') unless $dad;

	# 2) is $dad _capable_ of connecting $source?
	return audit($audit,"dad not capable",'') 
		if(!$main::acl->capable($dad,$url));

	# 3) is user allowed to read $source:table:fields ?
	return audit($audit,"reading denied by acl",'') 
		if(!$main::acl->read($user,$dad,$url));

	my $credit = credit($url);
	return audit($audit,undef,$credit ? $credit : 1); # ok
}

sub rpc_write {
	# todo! generalize rpc_read
	return 'write:heslo';
}

sub rpc_tablequery {
	my $url = shift;
	my $dbi = url::split($url);
	# match to config entry
	my $query = '';
	foreach(@@$::query) {
		next if($dbi->{proto} ne $_->{dbi}->{proto});
		next if(defined $dbi->{subproto} and defined $_->{dbi}->{subproto}
				and ($dbi->{subproto} ne $_->{dbi}->{subproto}));
		next if(defined $dbi->{host} and defined $_->{dbi}->{port}
				and ($dbi->{host} ne $_->{dbi}->{host}));
		next if(defined $dbi->{port} and defined $_->{dbi}->{port}
				and ($dbi->{port} ne $_->{dbi}->{port}));
		$query = $_->{query};
	}
	return $query;
}

1;


@


1.6
log
@added xml configuration file - new syntax
acl still not working
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.5 2003/02/17 23:34:48 numberone Exp $
d61 3
a63 1
					 return \@@hosts; }
d75 1
a96 1

@


1.5
log
@Msg - some changes forced by moving to libnet
certs: clear 'auth' key semantics, README for generating CA keys
switch to new Net-1.2: libnet + ssl layer
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.4 2002/09/29 14:47:16 numberone Exp $
a11 1
our $slave; # global for xmlrpc
d17 1
a17 1
	unless($main::acl->user($user)) {
d20 1
a20 1
		$msg->close;
d23 1
d31 1
d44 3
a46 5
sub audit {
	my($fx,$reply,$return) = @@_;
	print $slave->{user}," $fx? ",(defined $reply ? $reply : "ALLOW"),"\n";
	return defined $return ? $return : $reply;
}
d49 6
a54 2
	dads    => sub { audit("dads",undef);    $main::dads    },
	sources => sub { audit("sources",undef); $main::sources },
d58 4
d71 4
a74 3
sub eqdadports {
	my($d,$u) = @@_;
	return ((!$u and (int $d == 2333)) or (int $u == int $d));
a76 8
sub finddad {
	my($host,$port) = @@_;
	($host,$port) = ($`,$') if($host =~ /\:/);
	foreach(@@$main::dads) {
		return $_ if(($host eq $_->{host}) and eqdadports($_->{port},$port));
	}
	return undef;
}
a77 6
sub halfeq {
	my($a,$b) = @@_;
	return 1 unless defined $a;
	return 1 unless defined $b;
	return ($a eq $b);
}
d98 6
a103 3
	my($user,$dad,$full) = @@_;
	
	# fix: ???
a104 1
	$dad  = $slave->{peer} unless $dad;
@


1.4
log
@table query seems to work
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.3 2002/09/29 12:58:33 numberone Exp $
d16 1
a16 1
	my $user = $msg->user."\@@".$msg->host;
@


1.3
log
@tablequery
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.2 2002/09/26 07:52:42 numberone Exp $
d78 24
d130 2
a131 1
	return audit($audit,undef,"jmeno:heslo"); # ok
a143 1
	print Dumper($::query);
@


1.2
log
@version merging with my cvs
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.1.1.1 2002/09/24 01:34:03 michald Exp $
d30 1
d44 1
a44 1
	my($fx,$reply) = @@_;
d46 1
a46 1
	return $reply;
d53 2
d66 1
a66 1
	return (!$u and $d eq '2333') or ($u eq $d);
d73 1
a73 1
		return $_ if($host eq $_->{host} and eqdadports($_->{port},$port));
d81 2
d84 2
d89 1
a89 1
	return audit($audit,"user denied by acl") if(!$main::acl->user($user));
d94 1
a94 1
	return audit($audit,"wrong params") if(!$dad or !$full);
d96 1
a96 1
	return audit($audit,"unknown dad $dad") unless $dad;
d99 2
a100 1
	return audit($audit,"dad not capable") if(!$main::acl->capable($dad,$url));
d103 1
a103 1
	return audit($audit,"reading denied by acl") 
d106 25
a130 1
	return audit($audit,undef); # ok
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $Id: slave.pm,v 1.6 2002/08/24 19:14:33 martin Exp $
d102 1
@


1.1.1.1
log
@Initial public release of BEE Project.
@
text
@@
