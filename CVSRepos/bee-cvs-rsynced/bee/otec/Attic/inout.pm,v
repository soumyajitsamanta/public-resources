head	1.7;
access;
symbols
	start:1.1.1.1 vendor:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2003.02.07.21.17.32;	author numberone;	state dead;
branches;
next	1.6;

1.6
date	2002.12.16.02.18.33;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.29.13.46.47;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.29.12.58.33;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.28.18.02.47;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.26.07.52.42;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.01.40.59;	author michald;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.24.01.40.59;	author michald;	state Exp;
branches;
next	;


desc
@@


1.7
log
@removing old 'otec'
@
text
@# $Id: inout.pm,v 1.6 2002/12/16 02:18:33 numberone Exp $

# some types (dbi, table) are same for both input and output
package inout;

use lib '.';
use common;

use lib '../lib';
use url;

use Data::Dumper;
use strict;

use DBI;

sub url2class {
	my($url,$type,$inout) = @@_;

	my $proto = $url->{proto};
	$proto = 'file' if($proto eq 'dir'); # huh :-)

	return "$inout\::$proto" if($proto eq 'signal' or $proto eq 'scalar');
	return "input::array" if($inout eq 'input' and $proto eq 'array');

	return "$inout\::table::$proto"  if($type eq 'table');
	if($type eq 'stream') {
		if($proto eq 'dbi') {
			return $inout eq 'input' ? "input::stream::select" :
									   "output::stream::insert";
		}
		return "$inout\::stream::$proto" 
			if($proto eq 'file' or $proto eq 'bee');
		return "output::stream::display" 
			if($proto eq 'display' and $inout eq 'output');
	}
	return "$inout\::dbi"            if($proto eq 'dbi' and not $url->{table});
	die "url2class: url=",Dumper($url)."type=$type";
}


sub new {
	my($name,$type,$data_p,$arg) = @@_;
	my $url = url::split($arg->{url});
	die unless($url);

	# map url & name to type descendant
	# (dbi://host/db/table:f1:f2 & 'input') -> input::stream::dbi
	# (dbi://host/db/table & 'input')       -> input::table::dbi
	# (dbi://host/db & 'input')             -> input::dbi

	my $new = url2class($url,$type,$name);
	die unless($new);

	my $obj;
    {	no strict "refs";
		$obj = new $new($url,$arg,$data_p); # create input/output object
	}
	my $ret = '';
	($obj,$ret) = @@$obj if(ref $obj eq 'ARRAY');

	$$data_p = $obj;
	return defined $ret ? $ret : '';
}



# ----------------------------------------------
# input/output::table::file - open, create/append, put, fetch, delete

package inout::file;

use Data::Dumper;
use FileHandle;

sub new {
	my($pkg,$url,$arg) = @@_;

	die unless($url->{db} and $url->{table});
	die if(@@{$url->{fields}});

	# todo: format

	# fix: check special chars came in filename !!! (|,>>,..)

	return bless { 
		name	  => $url->{db}.$url->{table},
		handle    => undef, # not opened

		# when reading, separator is regex, when writing, it's string!
		separator => $arg->{separator} ?
					 $arg->{separator} : "\t",
	}, $pkg;
}

sub open {
	my($self,$mode) = @@_;

	my $fh = new FileHandle;

	my $open = $self->{name} or die;
	if($mode == 0) {
		$open = "<$open";
	} elsif($mode == 1) {
		truncate $open,0;
		$open = ">$open";
	} elsif($mode == 2) {
		$open = ">>$open";
	} else {
		die
	}

	open($fh,$open) or die "$open\: $!";

	$self->{handle} = $fh;

	return 1;
}


sub create {
	my($self,$create) = @@_;
	my $filename = $self->{name} or die; # fix: unnamed as temporary?

	my($perm,$uid,$gid) = split(/\:/,$create);

	# todo: handle with care, do not unlink, set rights, check errors
	truncate $filename,0 if -e $filename;
	CORE::open(X,$filename) or die "$filename\: $!"; close(X); # creat() ???

	chmod oct("0".(int($perm))), $filename if $perm ne '';

	# todo: chown
}

sub put {
    my $self = shift;
	die unless($self->{handle});
    my $fh = $self->{handle};

    print $fh join($self->{separator},@@_),"\n";
}

sub fetch {
	my $self = shift;
	die unless($self->{handle});
	my $line = readline($self->{handle});
	return () unless defined $line;
	chomp($line);        # use LIMIT version ?
	return split /$self->{separator}/, $line;
}

# should this be callable from script?
sub close {
	my $self = shift;
	close $self->{handle};
	$self->{handle} = undef;	
}

sub delete {
	my $self = shift;
	$self->close() if($self->{handle});
	unlink $self->{name};
	$self->{name}   = undef;	
}


# ----------------------------------------------
# dbi streaming ('LOAD/SAVE FILE' thru pipe, auto COMMIT after xMB)
# for in/out::table::dbi, 
# 	  input::stream::select, 
# 	  output::stream::insert

package inout::table;

use FileHandle;
use DBI;

sub new {
	my($pkg,$url,$arg) = @@_;

	my $db = common::database($url,$arg->{auth});

	# @@colmuns ?

	die unless($url->{table} or $arg->{view});
	die unless($url->{fields});

	return bless { 
		dbi	   => $db,
		view   => $arg->{view},
		table  => $url->{table},
		fields => $url->{fields},
		sth	   => undef, # statement
	}, $pkg;
}

sub create {
	my($self,$create) = @@_;
	my $table = "`".$self->{table}."`"; #$self->{dbi}->quote($self->{table});

	if($create) {
		$self->{dbi}->do("DROP TABLE IF EXISTS $table");
		$self->{dbi}->do($create);
	} else {
		$self->{dbi}->do("DELETE FROM $table");
	}
}


sub open {
	my($self,$mode) = @@_;
	die unless defined $mode;
	my $table = "`".$self->{table}."`"; #$self->{dbi}->quote($self->{table});

	$self->{dbi}->do("DELETE FROM $table") if($mode == 1);

	my $cmd;
	if($mode == 0) {
		if($self->{view}) { 
			$cmd = $self->{view} 
		} else {
			$cmd = "SELECT ".(join(",",map $self->{dbi}->quote($_), 
									@@{$self->{fields}}))." FROM $table";
		}
	} else {
		$cmd = "INSERT INTO $table VALUES (".
					("?, " x (@@{$self->{fields}}-1))."?)";
	}

	$self->{sth} = $self->{dbi}->prepare($cmd) or die;
	$self->{sth}->execute() unless($mode); # start select
}

sub put   { shift->{sth}->execute(@@_) }

sub fetch { shift->{sth}->fetchrow_array }


1;


@


1.6
log
@allow spaces in metadata. README, init.sql initial revision
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.5 2002/09/29 13:46:47 numberone Exp $
@


1.5
log
@common::database lib
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.4 2002/09/29 12:58:33 numberone Exp $
d200 1
d203 1
a203 1
		$self->{dbi}->do("DROP TABLE IF EXISTS ".$self->{table});
d206 1
a206 1
		$self->{dbi}->do("DELETE FROM ".$self->{table});
d214 1
d216 1
a216 1
	$self->{dbi}->do("DELETE FROM ".$self->{table}) if($mode == 1);
d223 2
a224 2
			$cmd = "SELECT ".(join(",",@@{$self->{fields}})).
					" FROM ".$self->{table};
d227 1
a227 1
		$cmd = "INSERT INTO ".$self->{table}." VALUES (".
@


1.4
log
@tablequery
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.3 2002/09/28 18:02:47 numberone Exp $
d6 3
a65 17
# connect to database, todo: password thru auth
sub database {
	my($url,$auth) = @@_;
	die unless($url->{db});

	# FIX: from auth!!!
	my($dsn,$driver,$user,$password) = ('dbi','mysql','bee','honey');
	$driver = $url->{subproto} if($url->{subproto});
	$user   = $url->{user} if($url->{user});

	my $db = DBI->connect("$dsn\:$driver\:".$url->{db},$user,$password);

	die $DBI::errstr unless $db;
	return $db;
}


d182 1
a182 1
	my $db = inout::database($url,$arg->{auth});
@


1.3
log
@argument order fix in bee-rpc_input
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.2 2002/09/26 07:52:42 numberone Exp $
d65 1
a65 1
	my $url = shift;
d196 1
a196 1
	my $db = inout::database($url);
@


1.2
log
@version merging with my cvs
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.1.1.1 2002/09/24 01:40:59 michald Exp $
d40 1
a40 2
    my($name,$type,$data_p) = splice(@@_,0,3);
    my $arg = { @@_ };
d54 1
a54 1
		$obj = new $new($url,{@@_},$data_p); # create input/output object
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $Id: inout.pm,v 1.4 2002/08/25 18:12:22 martin Exp $
d254 1
@


1.1.1.1
log
@Initial public release of BEE Project.
@
text
@@
