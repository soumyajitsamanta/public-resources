head	1.6;
access;
symbols
	start:1.1.1.1 vendor:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2003.02.07.21.17.37;	author numberone;	state dead;
branches;
next	1.5;

1.5
date	2002.09.29.13.46.47;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.29.12.58.33;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.27.13.54.52;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.26.07.52.42;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.01.40.59;	author michald;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.24.01.40.59;	author michald;	state Exp;
branches;
next	;


desc
@@


1.6
log
@removing old 'otec'
@
text
@# $Id: output.pm,v 1.5 2002/09/29 13:46:47 numberone Exp $

package output;

use inout;

use lib '.';
use common;

use lib '../lib';
use Net;

use Data::Dumper;
use strict;

sub new {
	my $pkg = shift;
	die "$pkg unsupported now\n";
}

sub init {
	my($type,$output) = @@_;

	# output::scalar is special
	for(my $i=0;$i<@@$type;$i++) {
		$output->[$i] = \$output->[$i] if($type->[$i] eq 'scalar');
	}

}


sub close {
	my($type,$output) = @@_;

	for(my $i=0;$i<@@$type;$i++) {
		if(ref $output->[$i] eq 'output::stream::file') {
			undef $output->[$i]->{handle};
			next;
		}
		next if($type->[$i] eq 'scalar');

		undef $output->[$i];
	}
}


# ===============================================================

package output::signal;
#package output::stream::display;
package output::table; # same as input::table


# ===============================================================

package output::scalar;

use Data::Dumper;

# this is called when we want to attach
# to the result == get result value!
sub new { 
	my($pkg,$url,$arg,$data_p) = @@_;
	return [undef,$$data_p];
#	my $result = shift;
#	return [undef,$$result];
}


# ===============================================================

# fix: merge with input::dbi !
package output::dbi;

use inout;

sub new {
	my($pkg,$url,$arg) = @@_;
    my $db = common::database($url,$arg->{auth});
    return [[$db,@@{$arg->{arg}}],''];
}


# ===============================================================

package output::stream::display;

use Data::Dumper;

sub new {
	my($pkg,$url,$arg) = @@_;
	die if($url->{table} or not $url->{fields});
	die if(ref $url->{fields} ne 'ARRAY');

	bless {msg=>$bee::otec_server, fields=>$url->{fields}},$pkg;
}

sub put { 
	my($output) = shift;
	foreach(@@_) {
		s/\\/\\\\/g;
		s/\n/\\n/g;
		s/\t/\\t/g;
	}
	my $line = join("\t",@@_);
	$output->{msg}->send("display $line");
}

# ===============================================================

package output::stream::bee;

sub new {
	my($pkg,$url,$arg) = @@_;
	my $listen = $arg->{listen} or die;

	die "to vzdavam\n" if(exists $listen->{unix});

	my $net = Net->connect("INET",$listen->{host},$listen->{port});
	return undef unless defined $net;

	return bless {
		net   => $net,
		stats => 0,
	}, __PACKAGE__;
}


# should be rewritten to optimized C
# field format:
#          'short' == '<5>short'  # length(short) < 192
# 'very long text' == '<254><32-bit length>very long text'
#            undef == '<255>'
# [ todo: int, date, float, ... types support (codes 192-253) ]

sub put {
	my $output = shift;

	my $line = "";
	foreach(@@_) {
		if(not defined $_) {
			$line .= pack("C",255);
			next;
		} elsif(length($_) < 192) {
			$line .= pack("C",length($_));
		} else {
			$line .= pack("CN",254,length($_));
		}
		$line .= $_;
	}
	$output->{net}->write($line);
}



# ===============================================================

package output::stream::file;

use inout;

sub new {
	my($pkg,$url,$arg) = @@_;

	my $table = new inout::file($url,$arg);
	$table->create($arg->{create});
	$table->open(1); # truncate & write

	# rebless: allow only put
	return bless $table,$pkg;
}

sub put { inout::file::put(@@_) }



# ===============================================================

package output::stream::insert;

use inout;

sub new {
	my($pkg,$url,$arg) = @@_;

	my $dbi = new inout::table($url,$arg);

	$dbi->create($arg->{create}) if(exists $arg->{create});
	$dbi->open(1);

	# rebless: allow only put
	return bless $dbi,$pkg;
}

sub put { inout::table::put(@@_) }

1;

@


1.5
log
@common::database lib
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.4 2002/09/29 12:58:33 numberone Exp $
@


1.4
log
@tablequery
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.3 2002/09/27 13:54:52 numberone Exp $
d7 3
d79 1
a79 1
    my $db = inout::database($url,$arg->{auth});
@


1.3
log
@tablequery, bee->dad msg
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.2 2002/09/26 07:52:42 numberone Exp $
d76 1
a76 1
    my $db = inout::database($url);
@


1.2
log
@version merging with my cvs
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.1.1.1 2002/09/24 01:40:59 michald Exp $
d92 1
a92 1
	bless {msg=>$bee::otec, fields=>$url->{fields}},$pkg;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.5 2002/08/26 20:06:17 martin Exp $
d195 1
@


1.1.1.1
log
@Initial public release of BEE Project.
@
text
@@
