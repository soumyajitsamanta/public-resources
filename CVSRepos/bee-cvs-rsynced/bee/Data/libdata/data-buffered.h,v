head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2004.05.12.14.33.40;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.30.14.12.16;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
-unbuffered.{xs,c,h}
  -- uses 1 syscall per row for sending, 2 syscalls p.r. for receiving

-buffered.{xs,c,h}
  -- sends data in 4096b chunks, low number of send()/recv() calls
  -- generaly doesn't work because of buffer-locking in some scenarios

benchmarks (put($i,'a' x ($i % 64))):

         unbuff     buffered
path     1M @@ 43s   -failed-
bench    1M @@ 17s   1M @@ 9s
@
text
@/*
 * C<Data> is library for transfering streams of rows between processes
 * or network. 
 *
 * Uses TCP/IP or UNIX sockets, will use blowfish and gzip, I hope :-)
 *
 * Copyright (c) 2003 Martin Sarfy <sarfy@@instrat.cz> */

#ifndef HEADER_DATA_H_INCLUDED
#define HEADER_DATA_H_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif

#ifndef null
#define null 0L
#endif

/* length byte codes: */
#define LEN_RESERVED 0
// 1-127 -- length
#define LEN_MAXLEN	 127
// next 4 bytes with length, network order
#define LEN_32BIT	 128
// reserved 0
#define LEN_RSVD0	 129
// 130..139 => 0..9 numbers
#define LEN_0		 130
#define LEN_9		 139
// 140..149 => 00..09 STRINGS !
#define LEN_00		 140
#define LEN_09		 149
// 140..239 => 00..99 numbers
#define LEN_10		 150
#define LEN_99		 239
// reserved range: 240-252
#define LEN_EMPTY	 253
#define LEN_UNDEF 	 254
// row separator
#define LEN_ENDOFROW 255

#ifndef byte
typedef unsigned char byte;
#endif

struct DataStruct {
	int	sock;

	int	 serversock; // used as send/recv flag too
	void *addr;
	int  addr_len;

	char* xinu; // unix. but when I type name 'unix', gcc says:
				// error: parse error before numeric constant :-)
	int port;   // TCP listen port or 0 if UNIX socket

	void* send_buff;
	int   send_size;
	int   send_pool;
	int   send_len;

	void* recv_buff;
	void* recv_end;
	int   recv_pool;
	void* recv_row;
	void* recv_ptr;

	// blowfish key
	// bzip table
	// peer name ?

	struct DataStruct * next;
};

typedef struct DataStruct * Data;

void  data_init(char* arg);
/* if unix_prefix != NULL, create unix-socket
 * if port == 0, find any empty port number (actualy, kernel do this)
 * todo: bzip, blowfish */
Data  data_listen(char* unix_prefix,int port); 
int   data_accept(Data server);
/* if port == 0, connect to unix-socket named host_unix
 * todo: bzip, blowfish  */
Data  data_connect(const char *host_unix,int port);

int   data_port(Data data); /* accessors */
char* data_unix(Data data);

int  data_recv(Data data,byte** p_buff,int *p_len);
byte* data_extract(Data data,byte *ptr,void **string,int *string_len);
void data_move(Data data,byte* ptr);

//void  data_send(Data data,const char *buffer,int len);
void data_send_init(Data data,int cols);
void data_send_append(Data data,char *col,int len);
int  data_send_flush(Data data);

void data_close(Data data);

#ifdef __cplusplus
}
#endif


#endif


@


1.1
log
@
new libData solving cycles in bee communication graph (i hope).
@
text
@d2 2
a3 1
 * C<Net> is nonblocking, autoflushing communication endpoint. 
d5 1
a5 3
 * C<Net::INET> is connection over TCP/IP network, C<Net::UNIX> is for
 * unix socket based communication and C<Net::SSL> is TCP/IP using
 * OpenSSL layer.
d44 3
a49 1
	int port;
d51 18
a68 2
	int	serversock;
	void *sin;
d74 1
a74 8
	void *buffer;
	int	 pool;
	int	 len;
	int	 offset; // pro Data.xs -- cast bufferu jsme uz mozna vratili

	void *send_buff;
	int	 send_pool;
	int  send_len;
d79 16
a94 7
Data data_listen(int port); /* bzip, blowfish */
int  data_accept(Data server);
int  data_port(Data data);;
Data data_connect(const char *host,int port); /* bzip, blowfish */
int  data_recv(Data data);
int  data_is_row(Data data);
int	 data_extract(Data data,void **buff,int *len);
d99 1
a99 1
void data_send_flush(Data data);
d110 1
@

