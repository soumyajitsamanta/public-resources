head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2004.08.04.15.12.58;	author numberone;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.15.10.11.11;	author numberone;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.14.06.48.36;	author numberone;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.13.12.51.29;	author numberone;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.13.12.31.55;	author numberone;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.13.07.56.09;	author numberone;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.12.14.33.40;	author numberone;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.11.18.08.46;	author numberone;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.10.13.14.58;	author numberone;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.08.10.49.53;	author numberone;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.30.14.12.16;	author numberone;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.06.15.33.08;	author numberone;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.30.10.32.37;	author numberone;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.30.09.51.36;	author numberone;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.30.09.05.31;	author numberone;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.29.12.26.14;	author numberone;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.29.07.11.08;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.27.15.08.04;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.15.08.20.07;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.11.06.58.06;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.10.07.45.13;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.09.09.43.20;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.08.17.55.32;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.07.11.06.24;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.24
log
@
Development moved to cobra server,

only working releases will be uploaded to the public
@
text
@#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "data.h"

// htonl functions
#ifdef WIN32
#include<winsock.h>
#else
#include<netinet/in.h>
#include<netdb.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<sys/un.h>
#include<arpa/inet.h>
#include<signal.h>
#include<unistd.h>
#include<fcntl.h>
#include<errno.h>
#endif

int unix_counter = 0; // unix filename suffix
static int debug = 0;

Data list = NULL;

extern int h_errno;

#define PERROR(fx) { perror(fx); exit(1); }

#define QUIET 
//#define DEBUG 
#define DEBUG(fmt,arg...) { if(debug) printf("[%d] " fmt, getpid(), ## arg); }
#define PRINT printf

#ifdef WIN32
typedef unsigned int uint32_t;
#endif
                                                                                
static void NETERROR(char *fx,int status) {
#ifdef WIN32
    fprintf(stderr,"%s: %d\n",fx,WSAGetLastError());
#else
    herror(fx);
#endif
    if(status) exit(status);
}
                                                                                

#define BUFF_INIT 4096
#define BUFF_PAGE 4096

static void  buff_init(void **buff,int *pool,int *len) {
    *len = 0;
    if(*buff) return;
    *buff = malloc(*pool = BUFF_INIT);
}   
static void *buff_extend(void **buff,int *pool,int *len,int size) {
    int want = *len + size;
    if(want > *pool) {
        *pool += (want > BUFF_PAGE) ?
                    BUFF_PAGE * (1 + (int)(want/BUFF_PAGE)) : BUFF_PAGE;
        *buff = realloc(*buff,*pool);
    }
    return ((char*)*buff) + *len; // start of free area
}   
static void *buff_insert(void **buff,int *pool,int *len,int size) {
    void *ptr = buff_extend(buff,pool,len,size);
    *len += size;
    return ptr;
}   
static void buff_clear(void **buff,int *pool,int *len) {
    *len = 0;
}   
static void buff_free(void **buff,int *pool,int *len) {
    if(*buff) free(*buff); 
    *len = *pool = 0;
}   


void set_block(int sock,int block) {
#ifdef WIN32
    u_long arg = !block;
    if(ioctlsocket(sock,FIONBIO,&arg)) NETERROR("ioctlsocket()",1);
#else
    int  flags;
    flags = fcntl(sock,F_GETFL);
    if(flags == -1) NETERROR("fcntp()",1);
    flags = block ? (flags & (~O_NONBLOCK)) : (flags | O_NONBLOCK);
    flags = fcntl(sock,F_SETFL,flags);
    if(flags == -1) NETERROR("fcntl()",1);
#endif
}

void data_init(char* arg) {
}

/* if unix_prefix != NULL, create unix-socket
 * if port == 0, find any empty port number (actualy, kernel do this)
 * todo: bzip, blowfish */
Data data_listen(char* unix_prefix,int port) {
	Data server;
#ifdef WIN32
    SOCKADDR_IN *sin,*sin2,*sun,*addr;
	unsigned int dontblock = 1;
	int xinu = 0; // UNIX sockets not used on Win32
#else
    struct sockaddr_in *sin,*sin2;
	struct sockaddr_un *sun;
	struct sockaddr *addr;
	int xinu = unix_prefix ? 1 : 0;
#endif
    int  sock, addr_len, sin2_len;
	char* name = NULL;

	sock = socket(xinu ? AF_UNIX : AF_INET,SOCK_STREAM,0);
	if(sock == -1) NETERROR("socket",11); /* ??? */

	if(xinu) {
		addr_len = sizeof(struct sockaddr_un);
		sun = (void*)malloc(addr_len);
		addr = (void*)sun;

		sun->sun_family = AF_UNIX; // there is hardcoded 108 in my sys/un.h
		snprintf(sun->sun_path,100,"%s-%d",unix_prefix,++unix_counter);
		name = strdup(sun->sun_path);
		unlink(name); // try to delete file first

	} else {
		addr_len = sin2_len = sizeof(struct sockaddr_in);
		sin = (void*)malloc(addr_len);
		addr = (void*)sin;

		sin->sin_family = AF_INET;
		sin->sin_addr.s_addr = INADDR_ANY;
		sin->sin_port = htons((short)port);

		sin2 = (void*)malloc(sin2_len); // for getsockname()
	}

    if(bind(sock,addr,addr_len)) NETERROR("bind()",1);

	if(!xinu && !port) {
        if(getsockname(sock, sin2, &sin2_len) < 0) 
			NETERROR("getsockname",1);
        port = ntohs(sin2->sin_port); 
	}
	
    if(listen(sock,128) == -1) NETERROR("listen()",1);

	server = calloc(1,sizeof(*server));
	server->sock 		= 0;
	server->addr 		= addr;
	server->addr_len 	= addr_len;
	server->serversock 	= sock;
	server->xinu 		= name;
	server->port 		= port;

	return server;
}


int data_accept(Data data,int tout) {
    int sock;
    int addr_len = data->addr_len;

	if(data->sock) return 2; /* already connected */

	// doing accept on server socket?
	if(!data->serversock) exit(14);
    if(!data->addr) exit(5); 

	if(tout >= 0) set_block(data->sock,0); // non-blocking

	// accept, store client address to Data struct
	sock = accept(data->serversock,data->addr,&addr_len);

	if(tout >= 0) set_block(sock,1); // turn of inherited flag

	if(sock == -1) {
#ifdef WIN32
        if(WSAGetLastError() == WSAEWOULDBLOCK) return 0;
#else
        if(errno == EAGAIN) return 0;
#endif
		else NETERROR("accept",12);
    }

#ifdef WIN32
	closesocket(data->serversock);
#else
	close(data->serversock);
#endif
	data->serversock = 0;

	data->sock = sock;

	// add to list. data_listen didn't do that
	data->next = list;
	list = data;

	return 1;
}


/* if port == 0, connect to unix-socket named host_unix
 * todo: bzip, blowfish  */
Data data_connect(const char *host_unix,int port) {
#ifdef WIN32
    LPHOSTENT hp;
    SOCKADDR_IN sin,sun,*addr;
	int xinu = 0; // UNIX sockets not used on Win32
#else
    struct hostent *hp;
    struct sockaddr_in sin;
	struct sockaddr_un sun;
	struct sockaddr *addr;
	int xinu = port ? 0 : 1;
#endif
    int addr_len,sock;
	Data data;

    sock = socket(xinu ? AF_UNIX : AF_INET,SOCK_STREAM,0);
    if(sock == -1) NETERROR("socket",13);

	if(xinu) {
		addr = (void*)&sun; addr_len = sizeof(sun);
		sun.sun_family = AF_UNIX;
		strncpy(sun.sun_path,host_unix,100); // sys/un.h: [108]
	} else {
		addr = (void*)&sin; addr_len = sizeof(sin);

	    if(!(hp = gethostbyname(host_unix))) NETERROR("gethostbyname",1);
    	sin.sin_family = AF_INET;
	    sin.sin_addr = **((struct in_addr **)hp->h_addr_list);
		sin.sin_port = htons((short)port);
	}

    if(connect(sock,addr,addr_len)) {
        fprintf(stderr,"connect('%s',%d)\n",host_unix,port);
        NETERROR("connect()",1);
    }

/* unlink(2)
 *  If the name referred to a socket, fifo or device the name for it is removed
 *  but processes which have the object open may continue to use it. 
 */

#ifndef WIN32
	if(xinu) unlink(sun.sun_path); 
#endif

	data = calloc(1,sizeof(*data));
	data->sock = sock;
	data->xinu = xinu ? strdup(host_unix) : NULL;

	data->next = list;
	list = data;

	return data;
}


static int recv_count,send_count;

void data_send_init(Data data,int cols) {
	DEBUG("data_send_init\n");

	if(!data->send_buff)
		buff_init(&data->send_buff,&data->send_pool,&data->send_len);
}

void data_send_string(Data data,void *a,size_t len) {
    unsigned char *buff;
    unsigned char code;
	int n = 0;

    if(len <= 0) {
		if(len < 0) exit(18);
		code = a ? LEN_STR_0 : LEN_UNDEF;
    }
	if((len > 0) && len <= (LEN_STR_MAX - LEN_STR_0)) {
		code = LEN_STR_0 + len;
		memcpy(buff, a, len);
	}
	if(len > (LEN_STR_MAX - LEN_STR_0)) {
		code = LEN_STR32;
		n = 4;
	}
	buff = buff_insert(&data->send_buff,&data->send_pool,
                       &data->send_len, 1 + n + len );
	*buff++ = code;
	if(n) {
		*(uint32_t*)buff = htonl(len);
		buff += sizeof(uint32_t);
	}
	if(len) {
		memcpy(buff, a, len);
	}
}

void data_send_int(Data data,int i) {
    unsigned char *buff;
    unsigned char code;
	int n = 0;

	if(i >= 0 && i <= (LEN_NO_MAX - LEN_NO_0)) {
		code = LEN_NO_0 + i;
	} else {
		if(i > -32766 && i < 32766) {
			code = LEN_INT16;
			n = 2;
		} else {
			code = LEN_INT32;
			n = 4;
		}
	}
	
	buff = buff_insert(&data->send_buff, &data->send_pool,
					   &data->send_len, 1 + n );
	*buff++ = code;
	if(n) {
		if(n == 2) {
			*(int16_t*)buff = htons(i);
			buff += sizeof(int16_t);
		} else {
			*(int32_t*)buff = htonl(i);
			buff += sizeof(int32_t);
		}
	}
}


// cekej, dokud nebudes moct cist/psat z (recv/send)_data
// mezitim flushuj send buffery, ktere jdou sendnout.
static void sending_waitfor(Data recv_data) {
	fd_set rset,wset;
	int count,maxfd = 0;
	size_t len;
	Data data;

/*	while(1) {
 *		FD_SET = (recv_data,each send_*)
 *		select(FD_SET);
 *	    if(muzes cist z recv_data) return;
 *	    foreach(muzes poslat)
 *	        send(MSG_DONTWAIT)
 *	}
 */

	while(1) {
		FD_ZERO(&rset);
		FD_ZERO(&wset);
		count = 0;

		if(recv_data) {
			FD_SET(maxfd = recv_data->sock, &rset);
			count++;
		}

		for(data=list; data; data=data->next) {
			if(data->send_len) {
				if(maxfd < data->sock) maxfd = data->sock;
				FD_SET(data->sock, &wset);
				count++;
			}
		}

		if(!count) return;

		select(maxfd + 1,&rset,&wset,NULL,NULL);
		if(recv_data && FD_ISSET(recv_data->sock,&rset)) return;

		for(data=list; data; data=data->next)
			if(FD_ISSET(data->sock,&wset)) {
				len = send(data->sock,data->send_buff,
						   data->send_len, MSG_DONTWAIT );
				if(len < 0) NETERROR("send",109);
				data->send_len -= len;
			}
	}
}



// recv/send(): if(bloknes) data_flush(wait=0)
//              recv/send()
static void send_buffer(Data data,int wait) {
    int len;
	// ak by send mal bloknut,
	// prebehni list
	
	len = send(data->sock,data->send_buff,data->send_len,0);
	while(data->send_len > 0) {
		len = send(data->sock,data->send_buff,data->send_len,0);
		if(len < 0) NETERROR("send",109);
		data->send_len -= len;
		if(len != data->send_len) {
			printf("send(len=%d,ret=%d)\n",data->send_len,len);
		}
	}
	if(data->send_len) exit(93);
}


int data_send_flush(Data data) {
	unsigned char *buff;

	buff = buff_insert(&data->send_buff,&data->send_pool,
					   &data->send_len, 1 );
	*buff++ = LEN_ENDOFROW;

		// flush send-buffers u can flush
		// until this data send-buffer is empty
	if(data->send_len >= BUFF_PAGE)
		while(data->send_len) sending_waitfor(NULL);
}


void data_close(Data data) {
	Data *ptr = &list;
	int len = data->send_len;

	// flush everything
	while(data->send_len) sending_waitfor(NULL);

	DEBUG("data_close() flushed %d bytes\n",len);

	while(*ptr) {
		if(*ptr == data) {
			*ptr = data->next;
			break;
		}
		ptr = &((*ptr)->next);
	}
	
#ifdef WIN32
	closesocket(data->sock);
#else
	close(data->sock);
#endif
	if(data->addr) free(data->addr);
	if(data->xinu) free(data->xinu);
	free(data);
}


int data_recv(Data data) {
	uint32_t len32;
	int columns, len, eof = 0;
	void *buff,*ptr;

	if(!data->recv_buff) {
		data->recv_buff = malloc(data->recv_pool = BUFF_PAGE);
		data->recv_row = data->recv_end = data->recv_buff;
	}

repeat:

	// regular end-of-stream?
	if((data->recv_end == data->recv_row) && eof) return 0;

	// do we have whole line in buffer?
	ptr = data->recv_ptr = data->recv_row;
	columns = 0;
	while(ptr < data->recv_end) {
		int code;

		code = *(unsigned char*)ptr++;

		// gcc should ignore these nops:
		if(code >= LEN_NO_0 && code <= LEN_NO_MAX) ;
		if(code == LEN_INT16) ;
		if(code == LEN_INT32) ;
		if(code == LEN_UNDEF) ;

		if(code >= LEN_STR_0 && code <= LEN_STR_MAX) 
				ptr += code - LEN_STR_0;

		if(code == LEN_STR32) {
			ptr += ntohl(*(uint32_t*)ptr);
			ptr += sizeof(uint32_t);
        }

		if(code == LEN_ENDOFROW) {
			data->recv_row = ptr;
			return columns;
		}

        columns++;
	}

	// realloc buffer if necessary
	len = (data->recv_buff + data->recv_pool) - data->recv_end;
	if(len < BUFF_PAGE) {
		DEBUG("data_recv() realloc(size=%d)\n",data->recv_pool + BUFF_PAGE);
		buff = realloc(data->recv_buff,data->recv_pool += BUFF_PAGE);
		data->recv_end  = buff + (data->recv_end - data->recv_buff);
		data->recv_row  = buff + (data->recv_row - data->recv_buff);
		data->recv_buff = buff;
	}

	// block until data will be available
	// meantime flush send-buffers, if u can
	sending_waitfor(data);

	// issue read(len>BUFF_PAGE) syscall
	len = recv(data->sock,data->recv_end,
			   (data->recv_buff + data->recv_pool) - data->recv_end, 0);

	if(len < 0) NETERROR("recv",95);
	if(!len) {
		// kdyz podruhe nula, je to taky chyba
		if(eof++) { printf("unexcepted EOF\n"); exit(94); }
	}
	data->recv_end += len;

	// again, do we have whole line in buffer?
	goto repeat;
}

static const char *numbers = "00010203040506070809";

int data_extract(Data data,int *p_n,void **p_a) {
	int code;

	if(!p_n || !p_a) exit(129);
	*p_a = NULL;

	code = *(unsigned char*)data->recv_ptr++;

	if(code >= LEN_NO_0 && code <= LEN_NO_MAX) {
		*p_n = code - LEN_NO_0;
		return 0; // number
	}
	if(code >= LEN_STR_0 && code <= LEN_STR_MAX) {
		*p_n = code - LEN_STR_0;
		*p_a = data->recv_ptr;
		data->recv_ptr += (*p_n);
		return 1; // string
	}
	if(code == LEN_INT16) {
		int16_t n16 = *(int16_t*)data->recv_ptr;
		*p_n = ntohs(n16);
		data->recv_ptr += sizeof(int16_t);
		return 0; // number
	}
	if(code == LEN_INT32) {
		int32_t n32 = *(int32_t*)data->recv_ptr;
		*p_n = ntohl(n32);
		data->recv_ptr += sizeof(int32_t);
		return 0; // number
	}
	if(code == LEN_STR32) {
		int32_t s32 = *(int32_t*)data->recv_ptr;
		data->recv_ptr += sizeof(int32_t);
		*p_n = ntohl(s32);
		*p_a = data->recv_ptr;
		data->recv_ptr += *p_n;
		return 1; // string
	}
	if(code == LEN_UNDEF) {
		*p_n = -1;
		return 1; // string
	}
	printf("data_extract() unknown code %d\n",code);
	exit(91);
}

void data_move(Data data) {
	int offset,size = -1;

	// muzeme uvolnit az do recv_row
	offset = data->recv_row - data->recv_buff;
	if(offset >= BUFF_PAGE) {
		size = data->recv_end - data->recv_row; // often will be n==0
		if(size) {
			memmove(data->recv_row - offset, data->recv_row, size);
			data->recv_row -= offset; // == recv_buff
			data->recv_end -= offset;
		}
	}
}


int data_port(Data data) {
	return data->port;
}

char* data_unix(Data data) {
	return data->xinu;
}

@


1.23
log
@
new Prepare API

This breaks compatibility with old .bee code, because every stream
input/output must be initialized first, bee has to call ->prepare()
method on stream objects in .bee code before calling ->put or ->get.

Or, instead of ->prepare(), bee can call general ->prepare_sql($cmd),
or, in the future, methods like ->prepare_select($table,$cols,$where,..),
->prepare_update(...), ->prepare_delete(...)

Next new method, execute(), is same as put() for UPDATE or DELETE.
But note that in order to do SELECT, we need to call DBI's execute().
Method prepare() with no arguments call's execute() for as.

So, correct is:

$input->prepare()
$input->fetch, fetch, fetch, ..

$input->prepare_sql("SELECT ...") or die "no SQL stream"
$input->exeucte() # !
$input->fetch, fetch, fetch, ..

$input->prepare_sql("UPDATE ...") or die "no SQL stream"
$input->execute(..), execute, excute (or put())

All stream .bee input/output variables have following methods:

prepare()         -- prepare and execute DBI statement
prepare_sql($cmd) -- prepare DBI statement
execute()         -- execute DBI statement
put()             -- execute DBI statement or write to stream
fetch()           -- fetch from DBI statement or read to stream
table()           -- returns table name, from URL
fields()          -- returns list of fields, from URL
@
text
@a151 2
	set_block(sock,0); // non-blocking listenning socket

d164 1
a164 1
int data_accept(Data data) {
d174 2
d179 2
a189 1

a196 2
	set_block(sock,1);

d339 1
a339 1
	int maxfd = 0;
d355 6
a360 1
		if(recv_data) FD_SET(maxfd = recv_data->sock, &rset);
d363 5
a367 2
			if(maxfd < data->sock) maxfd = data->sock;
			FD_SET(data->sock, &wset);
d370 2
d429 1
a429 1
	
@


1.22
log
@
libData select(2) version

  sending_waitfor(Data recv_data) function:

	wait until data are available for receiving,
	meantime flush send-buffers if u can

  + buffered recv/send
  + buffers locking avoided
  - no Win32 port now

  seems as final architecture for libData,
  except shared-memory models
@
text
@a96 1
	printf("data_init() called\n");
@


1.21
log
@
libData

  protocol enhancement. do not send 32bit SIZE header,
  but terminate using 1 byte ENDOFROW code.
@
text
@a50 6
// one global buffer for receiving
// max. row size limit
#define BUFFSIZE (128*1024)
static byte buff[BUFFSIZE];
static int  buff_len = 0;

d337 62
a400 1
    int len;
d406 4
a409 11
//    if(data->send_len >= BUFF_PAGE) {

	if(!(++data->io_sent & DATA_CHUNKS_MASK)) {
	
		while(data->send_len > 0) {
			len = send(data->sock,data->send_buff,data->send_len,0);
			if(len < 0) NETERROR("send",109);
			data->send_len -= len;
		}
		if(data->send_len) exit(93);
    }
d415 1
a415 1
	int len = -1;
d417 2
a418 5
	while(data->send_len > 0) {
		len = send(data->sock,data->send_buff,data->send_len,0);
		if(len < 0) NETERROR("send",97);
		data->send_len -= len;
	}
a439 7
static ssize_t recv2(int fd,void *buf,size_t count,int flags) {
	ssize_t ret;
	DEBUG("recv(%d,%p,%d,0)",fd,buf,count);
	ret = recv(fd,buf,count,flags);
	DEBUG(" = %d\n",ret);
	return ret;
}
a484 43
/*
	// do we have whole line in buffer?
	if(data->recv_end >= data->recv_row + sizeof(uint32_t)) {
		len32 = ntohl(*(uint32_t*)data->recv_row);
		DEBUG("data_recv(len32=%d,row=%p,end=%p)\n",
			   len32,data->recv_row,data->recv_end);

		if(data->recv_end >= data->recv_row + len32) {
			data->recv_ptr = data->recv_row + sizeof(uint32_t);
			data->recv_row += len32;

		    // ok, we have whole line in buffer, count columns
		    columns = 0;

			// count columns in recv_ptr..recv_row 
			ptr = data->recv_ptr;
			while(ptr < data->recv_row) {
				int code;

				code = *(unsigned char*)ptr++;

				// gcc should ignore these nops:
				if(code >= LEN_NO_0 && code <= LEN_NO_MAX) ;
				if(code == LEN_INT16) ;
				if(code == LEN_INT32) ;
				if(code == LEN_UNDEF) ;

				if(code >= LEN_STR_0 && code <= LEN_STR_MAX) 
						ptr += code - LEN_STR_0;

				if(code == LEN_STR32) {
					ptr += ntohl(*(uint32_t*)ptr);
					ptr += sizeof(uint32_t);
		        }
		        columns++;
			}
			if(ptr != data->recv_row) exit(95);

			// return columns
			return columns;
		}
	}
*/
d496 4
d501 1
a501 1
	len = recv2(data->sock,data->recv_end,
@


1.20
log
@
libData:

  better bandwidth utilization:

  0-199 ints: 1 byte
  short ints: 1 + 2
  32bit ints: 1 + 4
  strings with length n < 40: 1 + n
  strings n >= 40: 1 + 4 + n
@
text
@d276 1
a276 1
	void *buff;
a277 1
	DEBUG("data_send_init\n");
a279 4

	buff = buff_insert(&data->send_buff,&data->send_pool,
					   &data->send_len,sizeof(uint32_t));
	data->send_size = buff - data->send_buff;
d344 1
d346 4
a349 2
	uint32_t len32 = (data->send_len - data->send_size);
	*(uint32_t*)(data->send_buff + data->send_size) = htonl(len32);
d356 2
a357 2
	        len = send(data->sock,data->send_buff,data->send_len,0);
			if(len < 0) { perror("send"); exit(109); }
d369 1
a369 1
	if(data->send_len) {
d371 2
a372 4
		if(len != data->send_len) {
			if(len < 0) NETERROR("send",97);
			NETERROR("send",96); // todo: repeat?
		}
d374 1
d419 30
d464 1
a464 1
				int code; // (code >= LEN_NO_0) confuses gcc
d489 1
d519 1
a519 1
	int code; // (code >= LEN_NO_0) confuses gcc
@


1.19
log
@
working bufferred (!) version of libData.

handle data as chunks of 256 rows, sends them using one send(),
reads with one recv(). this solves locking problem, while is
still efficient enough.

path-17x100k @@ 18s

todo: send(n) may return <n, we should repeat { send }
@
text
@d287 4
a290 4
void data_send_append(Data data,char *col,int len) {
    unsigned char code = LEN_RESERVED;
    unsigned char *buff = NULL;
    int buff_len = 0;
d293 2
a294 28
        if(len < 0) exit(18);
        code = col ? LEN_EMPTY : LEN_UNDEF;
    }
    if(len == 1 && isdigit(col[0])) {
        code = LEN_0 + (col[0] - '0');
    }
    if(len == 2 && isdigit(col[0]) && isdigit(col[1])) {
        code = LEN_00 + 10*(col[0] - '0') + (col[1] - '0');
    }
    if(code) {
        buff = buff_insert(&data->send_buff,&data->send_pool,
                          &data->send_len,buff_len = 1);
        *buff = code;
    }
    if(!code) {
        if(len <= LEN_MAXLEN) {
            buff = buff_insert(&data->send_buff, &data->send_pool,
                               &data->send_len, buff_len = 1 + len );
            *buff = code = len;
            memcpy(buff + 1, col, len);
        } else {
            uint32_t len32 = htonl(len);
            buff = buff_insert(&data->send_buff, &data->send_pool,
                               &data->send_len, buff_len = 1 + 4 + len );
            *buff = code = LEN_32BIT;
            memcpy(buff + 1, &len32, 4);
            memcpy(buff + 5, col, len);
        }
d296 49
d357 6
a362 5
        len = send(data->sock,data->send_buff,data->send_len,0);
		if(len < 0) { perror("send"); exit(109); }
		if(len != data->send_len)
			printf("send(send_len=%d) returned %d\n",data->send_len,len);
        data->send_len -= len;
d406 1
a406 1
int data_recv(Data data,byte** p_buff,int *p_len) {
d437 15
a451 4
				byte code = *(byte*)ptr++;
				if(code > 0 && code <= LEN_MAXLEN) ptr += code;
				if(code == LEN_32BIT) {
					uint32_t *p_len32 = (uint32_t*)ptr;
a452 1
					ptr += ntohl(*p_len32);
d490 37
a526 33
byte* data_extract(Data data,byte *ptr,void **string,int *len) {
	uint32_t *p_len32;
	byte code = *(byte*)data->recv_ptr++;

	if(!string || !len) exit(129);
	*string = NULL;
	*len = 0;

	if(code >= 1 && code <= LEN_MAXLEN) {
		*string = data->recv_ptr;
		*len    = code;
		data->recv_ptr += (*len);
	}
	if(code == LEN_32BIT) {
		p_len32 = (uint32_t*)data->recv_ptr;
		data->recv_ptr += sizeof(uint32_t);
		*string = data->recv_ptr;
		*len  = ntohl(*p_len32);
		DEBUG("data_extract(LEN_32BIT,len=%d)\n",*len);
		data->recv_ptr += (*len);
	}
	if(code >= LEN_0 && code <= LEN_9) {
		*string = NULL; *len = code - LEN_0;
	}
	if(code >= LEN_00 && code <= LEN_09) {
		*string = (void*)(numbers + 2*(code - LEN_00));
		*len = 2;
	}
	if(code >= LEN_10 && code <= LEN_99) {
		*len = 10 + code - LEN_10;
	}
	if(code == LEN_EMPTY) {
		*string = (void*)numbers; *len = 0;
d529 2
a530 1
		*len = -1;
d532 2
a533 2

	return data->recv_ptr;
d536 1
a536 1
void data_move(Data data,byte *ptr) {
a547 44
//		printf("data_move(offset=%d,size=%d)\n",offset,size);
	}
}

/*
int data_recv(Data data,byte** p_buff,int *p_len) {
	unsigned int i,ret,len=-123,columns=0;
	uint32_t len32,*p_len32;
	byte *ptr;

	ret = recv(data->sock,&len32,sizeof(uint32_t),0);
	if(ret != sizeof(uint32_t)) {
		if(!ret) return 0; // EOF

		if(ret < 0) NETERROR("recv",112);
		exit(123); // hm, recv(len=4) returned <4 ??
	}
	len = ntohl(len32);
	len -= sizeof(uint32_t);

	ptr = buff;
	buff_len = len; // kolik zbyva
	while(buff_len > 0) {
		ret = recv(data->sock,ptr,buff_len,0);
		if(!ret) { fprintf(stderr,"data_recv(): unexcepted EOF\n"); exit(112); }
		if(ret < 0) NETERROR("recv",113);

		ptr += ret;
		buff_len -= ret;
	}
	
	// ok, we have whole line in buffer, count columns
	columns = 0;

	ptr = buff;
	while(ptr < buff + len) {
		byte code = *ptr++;
		if(code > 0 && code <= LEN_MAXLEN) ptr += code;
		if(code == LEN_32BIT) {
			uint32_t *p_len32 = (uint32_t*)ptr;
			ptr += sizeof(uint32_t);
			ptr += ntohl(*p_len32);
		}
		columns++;
a548 7

//	printf("data_recv(len=%d,columns=%d)\n   ",len,columns);
//	for(i=0;i<len;i++) printf("%02x ",buff[i]); printf("\n");

	if(p_buff) *p_buff = buff;
	if(p_len)  *p_len  = len;
	return columns;
a551 8
byte* data_extract(Data data,byte *ptr,void **string,int *len) {
}

void data_move(Data data,byte *ptr) {
	DEBUG("data_move\n");
}
*/

@


1.18
log
@
-unbuffered.{xs,c,h}
  -- uses 1 syscall per row for sending, 2 syscalls p.r. for receiving

-buffered.{xs,c,h}
  -- sends data in 4096b chunks, low number of send()/recv() calls
  -- generaly doesn't work because of buffer-locking in some scenarios

benchmarks (put($i,'a' x ($i % 64))):

         unbuff     buffered
path     1M @@ 43s   -failed-
bench    1M @@ 17s   1M @@ 9s
@
text
@d26 2
d34 1
a34 1
#define DEBUG(fmt,arg...) { if(debug) printf(fmt,## arg); }
a36 1

d51 1
a51 1
// one global buffer for both sending and receiving
d57 29
d103 1
d207 4
d266 3
d276 2
d279 6
a284 2
	if(buff_len) exit(123);
	buff_len = sizeof(uint32_t); // buff[0..3] == int32(buff_len)
d288 34
a321 32
	byte code = LEN_RESERVED;

	// large enough?
	if(buff_len + 5 > BUFFSIZE) exit(118);

	if(len <= 0) {
		if(len < 0) exit(119);
		code = col ? LEN_EMPTY : LEN_UNDEF;
	}
	if(len == 1 && isdigit(col[0])) {
		code = LEN_0 + (col[0] - '0');
	}
	if(len == 2 && isdigit(col[0]) && isdigit(col[1])) {
		code = LEN_00 + 10*(col[0] - '0') + (col[1] - '0');
	}
	if(code) {
		buff[buff_len++] = code;
	} else {
		if(len <= LEN_MAXLEN) {
			buff[buff_len++] = (byte)len;
		} else {
			uint32_t len32 = htonl(len);
			buff[buff_len++] = LEN_32BIT;
			memcpy(buff + buff_len, &len32, sizeof(uint32_t));
			buff_len += sizeof(uint32_t);
		}
		if(buff_len + len > BUFFSIZE) exit(119);
		memcpy(buff + buff_len, col, len);
		buff_len += len;
		DEBUG("data_send_append(len=%d,buff_len=%d)\n",len,buff_len);
	}
	DEBUG("data_send_append(buff_len=%d)\n",buff_len);
d326 3
a328 2
	int i,len;
	uint32_t len32;
d330 1
a330 5
	// the only write()
	len32 = htonl(buff_len);
	memcpy(buff, &len32, sizeof(uint32_t));
	len = send(data->sock,buff,buff_len,0);
	DEBUG("%d\t%d\tdata_send(len=%d,ret=%d)\n",getpid(),send_count++,buff_len,len);
d332 8
a339 4
	if(len < 0) NETERROR("send",117);

	if(len != buff_len) exit(124); // maybe we must isssue multiple send(2)s
	buff_len = 0;
d344 19
d374 140
d520 6
a525 1
	if(ret != sizeof(uint32_t)) return ret < 0 ? -1 : 0;
d531 1
a531 1
	while(buff_len) {
a563 2
static const char *numbers = "00010203040506070809";

a564 38
	uint32_t *p_len32;
	byte code = *ptr++;

	if(!string || !len) exit(129);
	*string = NULL;
	*len = 0;

	if(code >= 1 && code <= LEN_MAXLEN) {
		*string = ptr;
		*len    = code;
		ptr += (*len);
	}
	if(code == LEN_32BIT) {
		p_len32 = (uint32_t*)ptr;
		ptr += sizeof(uint32_t);
		*string = ptr;
		*len  = ntohl(*p_len32);
		DEBUG("data_extract(LEN_32BIT,len=%d)\n",*len);
		ptr += (*len);
	}
	if(code >= LEN_0 && code <= LEN_9) {
		*string = NULL; *len = code - LEN_0;
	}
	if(code >= LEN_00 && code <= LEN_09) {
		*string = (void*)(numbers + 2*(code - LEN_00));
		*len = 2;
	}
	if(code >= LEN_10 && code <= LEN_99) {
		*len = 10 + code - LEN_10;
	}
	if(code == LEN_EMPTY) {
		*string = (void*)numbers; *len = 0;
	}
	if(code == LEN_UNDEF) {
		*len = -1;
	}

	return ptr;
d570 1
@


1.17
log
@
Support for UNIX sockets in Data library. Runs 2 times faster now :-)

inet: 1M @@ 95s

unix: 1M @@ 47s

Creates pipe in "/tmp/.bee-$$-".(i++), removes them after connection
success (pipe still work)
@
text
@d23 3
a34 2
int unix_counter = 0; // unix filename suffix
static int debug = 0;
d57 1
a145 1
	if(!data->serversock) exit(14);
d149 1
a169 1

d297 1
d303 2
@


1.16
log
@
8 hours of debugging, several bugs solved.

path-17x100k successed now.

calls one send() and min. 2 recv() per row

speed: 1000000 x put("") in 38s (70k rps)
       path-17x100k in 120s (833 rps)

needs modifications to work under windows
@
text
@d15 1
d32 1
d73 4
a76 1
Data data_listen(int port) {
d79 1
a79 1
    SOCKADDR_IN *sin,sa;
d81 1
d83 4
a86 1
    struct sockaddr_in *sin,sa;
d88 2
a89 1
    int  sock, n = sizeof(sa);
d91 1
a91 1
	sock = socket(AF_INET,SOCK_STREAM,0);
d94 9
a102 4
	sin = malloc(sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = INADDR_ANY;
	sin->sin_port = htons((short)port);
d104 13
a116 1
    if(bind(sock,(struct sockaddr*)sin,sizeof(*sin))) NETERROR("bind()",1);
d118 2
a119 2
	if(!port) {
        if(getsockname(sock,(struct sockaddr *)&sa, &n) < 0) 
d121 1
a121 1
        port = ntohs(sa.sin_port); 
d129 6
a134 4
	server->sock = 0;
	server->sin  = sin;
	server->serversock = sock;
	server->port = port;
d142 1
a142 9
#ifdef WIN32
    SOCKADDR_IN *sin;
    int sin_len = sizeof(SOCKADDR_IN);
    sin = (SOCKADDR_IN *)data->sin;
#else
    struct sockaddr_in *sin;
    int sin_len = sizeof(struct sockaddr_in);
    sin = (struct sockaddr_in *)data->sin;
#endif
d147 2
a148 1
    if(!sin) exit(5); // doing accept on non-server socket
d150 2
a151 1
	sock = accept(data->serversock,(void*)sin,&sin_len);
d179 3
a181 1
Data data_connect(const char *host,int port) {
d184 2
a185 1
    SOCKADDR_IN sin;
d187 1
a187 1
    struct  hostent *hp;
d189 3
d193 1
a194 1
    int sock;
d196 1
a196 1
    sock = socket(AF_INET,SOCK_STREAM,0);
d199 12
a210 5
    if(!(hp = gethostbyname(host))) NETERROR("gethostbyname",1);
                                                                                
    sin.sin_family = AF_INET;
    sin.sin_addr = **((struct in_addr **)hp->h_addr_list);
    sin.sin_port = htons((short)port);
d212 2
a213 2
    if(connect(sock,(struct sockaddr*)&sin,sizeof(sin))) {
        fprintf(stderr,"connect('%s',%d)\n",host,port);
d217 8
a224 1
//	set_block(sock,1);
d228 1
d233 1
d399 5
@


1.15
log
@
My last libData patch didn't solve bug, and was 5x slower..

reverting to previous version of libData.. :-(
@
text
@d22 2
a25 1
//#define DEBUG(format,args...)
d27 2
a28 1
#define DEBUG 
d31 2
d37 1
a37 1
static void NETERROR(char *fx) {
a39 1
    exit(1);
d41 1
a41 2
    perror(fx);
    exit(1);
d43 1
d47 5
a51 2
#define BUFF_INIT 4096
#define BUFF_PAGE 4096
a52 26
static void  buff_init(void **buff,int *pool,int *len) {
	*len = 0;
	if(*buff) return;
	*buff = malloc(*pool = BUFF_INIT);
}
static void *buff_extend(void **buff,int *pool,int *len,int size) {
	int want = *len + size;
	if(want > *pool) {
		*pool += (want > BUFF_PAGE) ? 
					BUFF_PAGE * (1 + (int)(want/BUFF_PAGE)) : BUFF_PAGE;
		*buff = realloc(*buff,*pool);
	}
	return ((char*)*buff) + *len; // start of free area
}
static void *buff_insert(void **buff,int *pool,int *len,int size) {
	void *ptr = buff_extend(buff,pool,len,size);
	*len += size;
	return ptr;
}
static void buff_clear(void **buff,int *pool,int *len) {
	*len = 0;
}
static void buff_free(void **buff,int *pool,int *len) {
	if(*buff) free(*buff);
	*len = *pool = 0;
}
d57 1
a57 1
    if(ioctlsocket(sock,FIONBIO,&arg)) NETERROR("ioctlsocket()");
d61 1
a61 1
    if(flags == -1) NETERROR("fcntp()");
d64 1
a64 1
    if(flags == -1) NETERROR("fcntl()");
d68 3
d82 1
a82 1
	if(sock == -1) exit(11); /* ??? */
d89 1
a89 1
    if(bind(sock,(struct sockaddr*)sin,sizeof(*sin))) NETERROR("bind()");
d92 2
a93 1
        if(getsockname(sock,(struct sockaddr *)&sa, &n) < 0) exit(1);
d97 1
a97 1
    if(listen(sock,128) == -1) NETERROR("listen()");
d106 1
d130 1
a130 1
    if(sock == -1) {
d136 1
a136 1
		else exit(12);
d139 1
a151 2
	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);
d168 1
a168 1
    if(sock == -1) exit(13);
d170 1
a170 8
    if(!(hp = gethostbyname(host))) {
#ifdef WIN32
        fprintf(stderr,"gethostbyname(): %d\n",WSAGetLastError());
#else
        herror("gethostbyname");
#endif
        exit(1);
    }
d178 1
a178 1
        NETERROR("connect()");
d181 1
a181 1
	set_block(sock,1);
a185 3
	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);

d189 1
a189 3
//void *send_buff = NULL;
//int   send_pool = 0; // size of malloced buffer
//int	  send_len  = 0; // real data length
d192 3
a194 2
	if(!data->send_buff) 
		buff_init(&data->send_buff,&data->send_pool,&data->send_len);
d198 4
a201 3
	unsigned char code = LEN_RESERVED;
	unsigned char *buff = NULL; 
	int buff_len = 0;
d204 1
a204 1
		if(len < 0) exit(18);
d214 2
a215 5
		buff = buff_insert(&data->send_buff,&data->send_pool,
						  &data->send_len,buff_len = 1);
		*buff = code;
	}
	if(!code) {
d217 1
a217 4
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + len );
			*buff = code = len;
			memcpy(buff + 1, col, len);
d220 3
a222 5
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + 4 + len );
			*buff = code = LEN_32BIT;
			memcpy(buff + 1, &len32, 4);
			memcpy(buff + 5, col, len);
d224 4
d229 1
d232 15
a246 21
static int write2(int fd,unsigned char *buff,int len) {
	printf("write(): writting %d bytes\n",len);
/*	for(i=0;i<len;i++) {
		printf("%3d ",buff[i]);
		if(i%20==19) printf("\n");
	}*/
	len = send(fd,buff,len,0);
//	len = write(fd,buff,len);
	printf("write(): ... wrote %d bytes\n",len);
	return len;
}

void data_send_flush(Data data) {
	int len;
	unsigned char *ptr = buff_insert(&data->send_buff,
									 &data->send_pool,&data->send_len,1);
	*ptr = LEN_ENDOFROW;
	if(data->send_len >= BUFF_PAGE) {
		len = write(data->sock,data->send_buff,data->send_len);
		data->send_len = 0;
	}
d249 1
a250 3
	if(data->send_len) write(data->sock,data->send_buff,data->send_len);
	buff_free(&data->send_buff,&data->send_pool,&data->send_len);
	buff_free(&data->buffer,&data->pool,&data->len);
d259 16
a274 2
int data_recv(Data data) {
	int len;
d276 6
a281 13
	buff_extend(&(void*)(data->buffer),&data->pool,&data->len,BUFF_PAGE);

	set_block(data->sock,1);
//	printf("read(): calling read(BUFF_PAGE=%d)\n",BUFF_PAGE);
//	len = read(data->sock,(char*)data->buffer + data->len,BUFF_PAGE);
	len = recv(data->sock,(char*)data->buffer + data->len,BUFF_PAGE,0);
//	printf("read():  ... returned %d\n",len);
	if(len == -1) return 1;
    if(len <= 0) return 0;

	data->len += len;
	return len;
}
d283 4
a286 13

int data_is_row(Data data) {
	unsigned char code, *ptr;
	uint32_t len32;
	int row, len, columns = 0;

	len = data->len - data->offset;
	if(len < 1) return -1;

	ptr = (char*)data->buffer + data->offset;

	while((len > 0) && ((code=(*ptr)) != LEN_ENDOFROW)) {
		if(code >= 1 && code <= LEN_MAXLEN) row = code;
d288 3
a290 2
			memcpy(&len32,ptr+1,4);
			row = 4 + ntohl(len32);
d292 2
a293 2
		if(code >= LEN_0 && code <= LEN_99) row = 0;
		if(code == LEN_EMPTY || code == LEN_UNDEF) row = 0;
d295 2
a296 1
		if(row == -1) exit(20); // unknown code
d298 3
a300 5
		len -= 1 + row;
		ptr += 1 + row;
		columns++;
	}
	return ((len > 0) && ((*ptr) == LEN_ENDOFROW)) ? columns : -1;
d303 1
d306 7
a312 4
int data_extract(Data data,void **buff,int *len) {
	uint32_t len32;
	unsigned char *ptr = (char*)data->buffer + data->offset;
	unsigned char code = *ptr;
d315 3
a317 3
		*buff = ptr + 1;
		*len = code;
		return 1 + code;
d320 6
a325 4
		memcpy(&len32,ptr+1,4);
		*len  = ntohl(len32);
		*buff = ptr + 1 + 4;	
		return 1 + 4 + (*len);
d328 1
a328 2
		*buff = NULL; *len = code - LEN_0;
		return 1;
d331 1
a331 1
		*buff = (void*)(numbers + 2*(code - LEN_00));
a332 1
		return 1;
d335 1
a335 2
		*buff = NULL; *len = 10 + code - LEN_10;
		return 1;
d338 1
a338 2
		*buff = (void*)numbers; *len = 0;
		return 1;
a340 1
		*buff = NULL;
a341 1
		return 1;
d344 5
a348 2
	printf("error: code=%d\n",code);
	exit(21);
a353 2


@


1.14
log
@
new libData solving cycles in bee communication graph (i hope).
@
text
@d44 2
a45 7
// max. row size
#define BUFFSIZE (128*1024)
// one global buffer for sending
static byte buff[BUFFSIZE];
static int  buff_len = 0;
//static byte *buff_ptr = buff; // for extracting
//static int  row_len;
d47 26
a121 1

d166 2
d204 1
a204 1
//	set_block(sock,1);
d209 3
d215 3
d220 2
a221 2
//	if(buff_len) exit(123);
	buff_len = sizeof(uint32_t); // buff[0..3] == int32(buff_len)
d225 3
a227 3
	byte code = LEN_RESERVED;

	// todo: check for 5 free bytes
d230 1
a230 1
		if(len < 0) exit(119);
d240 5
a244 2
		buff[buff_len++] = code;
	} else {
d246 4
a249 1
			buff[buff_len++] = (byte)len;
d252 5
a256 3
			buff[buff_len++] = LEN_32BIT;
			memcpy(buff + buff_len, &len32, sizeof(uint32_t));
			buff_len += sizeof(uint32_t);
a257 3
		// todo: check for 'len' free bytes
		memcpy(buff + buff_len, col, len);
		buff_len += len;
d261 21
a281 13

int data_send_flush(Data data) {
	int i,len;
	uint32_t len32;

	// the only write()
	len32 = htonl(buff_len);
	memcpy(buff, &len32, sizeof(uint32_t));
//	printf("data_send(len=%d)\n",buff_len);
	len = send(data->sock,buff,buff_len,0);

	if(len < 0) return -1;
	if(len != buff_len) exit(124);
a283 1

d285 3
d296 30
a325 21
int data_recv(Data data,byte** p_buff,int *p_len) {
	unsigned int i,ret,len=-123,columns=0;
	uint32_t len32,*p_len32;
	byte *ptr;

	// returns 4?
	ret = recv(data->sock,&len32,sizeof(uint32_t),0);
	if(ret != sizeof(uint32_t)) return ret < 0 ? -1 : 0;
	len = ntohl(len32) - sizeof(uint32_t);

	if(len > BUFFSIZE) exit(123);
	ret = recv(data->sock,buff,len,0);
	if(ret != len) return ret < 0 ? -1 : 0;

	// ok, we have whole line in buffer, count columns
	columns = 0;

	ptr = buff;
	while(ptr < buff + len) {
		byte code = *ptr++;
		if(code > 0 && code <= LEN_MAXLEN) ptr += code;
d327 2
a328 2
			uint32_t *p_len32 = (uint32_t*)ptr;
			ptr += ntohl(*p_len32);
d330 7
d339 1
a339 7

//	printf("data_recv(len=%d,columns=%d)\n   ",len,columns);
//	for(i=0;i<len;i++) printf("%02x ",buff[i]); printf("\n");

	if(p_buff) *p_buff = buff;
	if(p_len)  *p_len  = len;
	return columns;
a341 1

d344 4
a347 7
byte* data_extract(Data data,byte *ptr,void **string,int *len) {
	uint32_t *p_len32;
	byte code = *ptr++;

	if(!string || !len) exit(129);
	*string = NULL;
	*len = 0;
d350 3
a352 3
		*string = ptr;
		*len    = code;
		ptr += (*len);
d355 4
a358 5
		p_len32 = (uint32_t*)ptr;
		ptr += sizeof(uint32_t);
		*string = ptr;
		*len  = ntohl(*p_len32);
		ptr += (*len);
d361 2
a362 1
		*string = NULL; *len = code - LEN_0;
d365 1
a365 1
		*string = (void*)(numbers + 2*(code - LEN_00));
d367 1
d370 2
a371 1
		*len = 10 + code - LEN_10;
d374 2
a375 1
		*string = (void*)numbers; *len = 0;
d378 1
d380 1
d383 2
a384 4
	return ptr;
}

void data_move(Data data,byte *ptr) {
@


1.13
log
@debug strings removed from Data/libdata
@
text
@d44 7
a50 2
#define BUFF_INIT 4096
#define BUFF_PAGE 4096
a51 26
static void  buff_init(void **buff,int *pool,int *len) {
	*len = 0;
	if(*buff) return;
	*buff = malloc(*pool = BUFF_INIT);
}
static void *buff_extend(void **buff,int *pool,int *len,int size) {
	int want = *len + size;
	if(want > *pool) {
		*pool += (want > BUFF_PAGE) ? 
					BUFF_PAGE * (1 + (int)(want/BUFF_PAGE)) : BUFF_PAGE;
		*buff = realloc(*buff,*pool);
	}
	return ((char*)*buff) + *len; // start of free area
}
static void *buff_insert(void **buff,int *pool,int *len,int size) {
	void *ptr = buff_extend(buff,pool,len,size);
	*len += size;
	return ptr;
}
static void buff_clear(void **buff,int *pool,int *len) {
	*len = 0;
}
static void buff_free(void **buff,int *pool,int *len) {
	if(*buff) free(*buff);
	*len = *pool = 0;
}
d101 1
a145 2
	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);
d182 1
a182 1
	set_block(sock,1);
a186 3
	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);

a189 3
//void *send_buff = NULL;
//int   send_pool = 0; // size of malloced buffer
//int	  send_len  = 0; // real data length
d192 2
a193 2
	if(!data->send_buff) 
		buff_init(&data->send_buff,&data->send_pool,&data->send_len);
d197 3
a199 3
	unsigned char code = LEN_RESERVED;
	unsigned char *buff = NULL; 
	int buff_len = 0;
d202 1
a202 1
		if(len < 0) exit(18);
d212 2
a213 5
		buff = buff_insert(&data->send_buff,&data->send_pool,
						  &data->send_len,buff_len = 1);
		*buff = code;
	}
	if(!code) {
d215 1
a215 4
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + len );
			*buff = code = len;
			memcpy(buff + 1, col, len);
d218 3
a220 5
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + 4 + len );
			*buff = code = LEN_32BIT;
			memcpy(buff + 1, &len32, 4);
			memcpy(buff + 5, col, len);
d222 3
d228 13
a240 21
static int write2(int fd,unsigned char *buff,int len) {
	printf("write(): writting %d bytes\n",len);
/*	for(i=0;i<len;i++) {
		printf("%3d ",buff[i]);
		if(i%20==19) printf("\n");
	}*/
	len = send(fd,buff,len,0);
//	len = write(fd,buff,len);
	printf("write(): ... wrote %d bytes\n",len);
	return len;
}

void data_send_flush(Data data) {
	int len;
	unsigned char *ptr = buff_insert(&data->send_buff,
									 &data->send_pool,&data->send_len,1);
	*ptr = LEN_ENDOFROW;
	if(data->send_len >= BUFF_PAGE) {
		len = write(data->sock,data->send_buff,data->send_len);
		data->send_len = 0;
	}
d243 1
a244 3
	if(data->send_len) write(data->sock,data->send_buff,data->send_len);
	buff_free(&data->send_buff,&data->send_pool,&data->send_len);
	buff_free(&data->buffer,&data->pool,&data->len);
d253 21
a273 30
int data_recv(Data data) {
	int len;

	buff_extend(&(void*)(data->buffer),&data->pool,&data->len,BUFF_PAGE);

	set_block(data->sock,1);
//	printf("read(): calling read(BUFF_PAGE=%d)\n",BUFF_PAGE);
//	len = read(data->sock,(char*)data->buffer + data->len,BUFF_PAGE);
	len = recv(data->sock,(char*)data->buffer + data->len,BUFF_PAGE,0);
//	printf("read():  ... returned %d\n",len);
	if(len == -1) return 1;
    if(len <= 0) return 0;

	data->len += len;
	return len;
}


int data_is_row(Data data) {
	unsigned char code, *ptr;
	uint32_t len32;
	int row, len, columns = 0;

	len = data->len - data->offset;
	if(len < 1) return -1;

	ptr = (char*)data->buffer + data->offset;

	while((len > 0) && ((code=(*ptr)) != LEN_ENDOFROW)) {
		if(code >= 1 && code <= LEN_MAXLEN) row = code;
d275 2
a276 2
			memcpy(&len32,ptr+1,4);
			row = 4 + ntohl(len32);
d278 2
a279 2
		if(code >= LEN_0 && code <= LEN_99) row = 0;
		if(code == LEN_EMPTY || code == LEN_UNDEF) row = 0;
d281 2
a282 1
		if(row == -1) exit(20); // unknown code
d284 3
a286 5
		len -= 1 + row;
		ptr += 1 + row;
		columns++;
	}
	return ((len > 0) && ((*ptr) == LEN_ENDOFROW)) ? columns : -1;
d289 1
d292 7
a298 4
int data_extract(Data data,void **buff,int *len) {
	uint32_t len32;
	unsigned char *ptr = (char*)data->buffer + data->offset;
	unsigned char code = *ptr;
d301 3
a303 3
		*buff = ptr + 1;
		*len = code;
		return 1 + code;
d306 5
a310 4
		memcpy(&len32,ptr+1,4);
		*len  = ntohl(len32);
		*buff = ptr + 1 + 4;	
		return 1 + 4 + (*len);
d313 1
a313 2
		*buff = NULL; *len = code - LEN_0;
		return 1;
d316 1
a316 1
		*buff = (void*)(numbers + 2*(code - LEN_00));
a317 1
		return 1;
d320 1
a320 2
		*buff = NULL; *len = 10 + code - LEN_10;
		return 1;
d323 1
a323 2
		*buff = (void*)numbers; *len = 0;
		return 1;
a325 1
		*buff = NULL;
a326 1
		return 1;
d329 4
a332 2
	printf("error: code=%d\n",code);
	exit(21);
@


1.12
log
@Data works on windows.. maybe on unix too, not tested..
@
text
@a152 2

	printf("accept(): accepted connection on port %d\n",data->port);
a197 2

	printf("connect(): connecting to %s:%d\n",host,port);
d203 2
a204 2

	set_block(sock,1);
d273 1
a273 1
void data_send_flush(Data data) {
d278 2
a279 2
	if(data->send_len >= BUFF_PAGE) {
		len = write2(data->sock,data->send_buff,data->send_len);
d285 1
a285 2
	if(data->send_len) write2(data->sock,data->send_buff,data->send_len);
	printf("close(): closing connection\n");
d300 2
a301 2

	set_block(data->sock,1);
d303 3
a305 3
//	len = read(data->sock,(char*)data->buffer + data->len,BUFF_PAGE);
	len = recv(data->sock,(char*)data->buffer + data->len,BUFF_PAGE,0);
//	printf("read():  ... returned %d\n",len);
d307 1
a307 1
    if(len <= 0) return 0;
@


1.11
log
@set_block function
@
text
@a131 1
	unsigned int block = 0;
a135 1
	int block;
d153 2
d200 2
d207 2
d265 3
a267 4
/*static void write2(int fd,unsigned char *buff,int len) {
	int i;
	printf(">>> write(%d):\n",len);
	for(i=0;i<len;i++) {
d270 6
a275 4
	}
	write(fd,buff,len);
	printf("<<<\n");
}*/
d277 2
a278 1
void data_send_flush(Data data) {
d282 2
a283 2
	if(data->send_len >= BUFF_PAGE) {
		write(data->sock,data->send_buff,data->send_len);
d289 2
a290 1
	if(data->send_len) write(data->sock,data->send_buff,data->send_len);
d305 7
a311 2

	len = read(data->sock,(char*)data->buffer + data->len,BUFF_PAGE);
@


1.10
log
@ok, windows running, executes too processes, Data still doesn't work..
@
text
@d74 13
a86 1

d115 1
a115 8
#ifdef WIN32
	if(ioctlsocket(sock,FIONBIO,&dontblock)) NETERROR("ioctlsocket()");
#else
    if(fcntl(sock, F_SETFL, O_NDELAY) < 0) {
        perror("Can't set server data socket to non-blocking");
        exit(19);
    }
#endif
d132 1
d137 1
d163 2
@


1.9
log
@Data -- automatic port allocation
@
text
@d291 1
a291 1
	if(len < 0) exit(17);
@


1.8
log
@Data - read(2)/write(2) included from <unistd.h>
@
text
@d29 1
a29 1
#ifndef uint32_t
d79 1
a79 1
    SOCKADDR_IN *sin;
d82 1
a82 1
    struct sockaddr_in *sin;
d84 1
a84 1
    int  sock;
d96 5
d116 1
d369 4
@


1.7
log
@shit, i copied Data to Net subdir, this is fix
@
text
@d11 9
a19 9
#include <netinet/in.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
@


1.6
log
@data -- implementation
@
text
@d29 3
d59 1
a59 1
	return *buff + *len; // start of free area
d80 1
d98 3
d105 1
d143 3
d147 2
d246 1
a246 1
static void write2(int fd,unsigned char *buff,int len) {
d255 1
a255 1
}
d271 3
d275 1
d280 1
a280 2
	int i,len;
	unsigned char *buff;
d284 1
a284 1
	len = read(data->sock,data->buffer + data->len,BUFF_PAGE);
d300 1
a300 1
	ptr = data->buffer + data->offset;
d324 1
a324 1
	unsigned char *ptr = data->buffer + data->offset;
@


1.5
log
@merging Data to cvs
@
text
@d4 1
d12 8
a23 3
#define BUFF_SIZE_INITIAL	8192
#define BUFF_SIZE_INC		4096

d29 55
d85 69
a153 2
// base constructor
Data create_data(int sock) {
d155 22
d181 2
a182 3
	data->buff_len = BUFF_SIZE_INITIAL;
	data->buffer = malloc(data->buff_len);
	data->real_len = 0;
d184 59
a242 1
	DEBUG("creating DATA(sock=%d)\n",data->sock);
d244 8
a251 1
	return data;
d254 6
a259 2
Data data_listen(int port) {
	return NULL;
d262 11
a272 2
Data data_connect(const char *host,int port) {
	return NULL;
d275 27
a301 2
char *data_recv(Data data,int *len) {
	return NULL;
d304 43
a346 1
void data_send(Data data,const char *buffer,int len) {
@


1.4
log
@demo example -- apache
@
text
@a3 1
#include <ctype.h>
a10 8
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
d15 3
a22 55
                                                                                
static void NETERROR(char *fx) {
#ifdef WIN32
    fprintf(stderr,"%s: %d\n",fx,WSAGetLastError());
    exit(1);
#else
    perror(fx);
    exit(1);
#endif
}
                                                                                

#define BUFF_INIT 4096
#define BUFF_PAGE 4096

static void  buff_init(void **buff,int *pool,int *len) {
	*len = 0;
	if(*buff) return;
	*buff = malloc(*pool = BUFF_INIT);
}
static void *buff_extend(void **buff,int *pool,int *len,int size) {
	int want = *len + size;
	if(want > *pool) {
		*pool += (want > BUFF_PAGE) ? 
					BUFF_PAGE * (1 + (int)(want/BUFF_PAGE)) : BUFF_PAGE;
		*buff = realloc(*buff,*pool);
	}
	return *buff + *len; // start of free area
}
static void *buff_insert(void **buff,int *pool,int *len,int size) {
	void *ptr = buff_extend(buff,pool,len,size);
	*len += size;
	return ptr;
}
static void buff_clear(void **buff,int *pool,int *len) {
	*len = 0;
}
static void buff_free(void **buff,int *pool,int *len) {
	if(*buff) free(*buff);
	*len = *pool = 0;
}



Data data_listen(int port) {
	Data server;
#ifdef WIN32
    SOCKADDR_IN *sin;
#else
    struct sockaddr_in *sin;
#endif
    int  sock;

	sock = socket(AF_INET,SOCK_STREAM,0);
	if(sock == -1) exit(11); /* ??? */
d24 2
a25 71
	sin = malloc(sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = INADDR_ANY;
	sin->sin_port = htons((short)port);

    if(bind(sock,(struct sockaddr*)sin,sizeof(*sin))) 
		return NULL; // bind() address in use?
//		NETERROR("bind()");

    if(listen(sock,128) == -1) NETERROR("listen()");

    if(fcntl(sock, F_SETFL, O_NDELAY) < 0) {
        perror("Can't set server data socket to non-blocking");
        exit(19);
    }

	server = calloc(1,sizeof(*server));
	server->sock = 0;
	server->sin  = sin;
	server->serversock = sock;
	return server;
}


int data_accept(Data data) {
    int sock;
#ifdef WIN32
    SOCKADDR_IN *sin;
    int sin_len = sizeof(SOCKADDR_IN);
    sin = (SOCKADDR_IN *)data->sin;
#else
    struct sockaddr_in *sin;
    int sin_len = sizeof(struct sockaddr_in);
    sin = (struct sockaddr_in *)data->sin;
#endif

	if(!data->serversock) exit(14);
	if(data->sock) return 2; /* already connected */

    if(!sin) exit(5); // doing accept on non-server socket

	sock = accept(data->serversock,(void*)sin,&sin_len);

    if(sock == -1) {
#ifdef WIN32
        if(WSAGetLastError() == WSAEWOULDBLOCK) return 0;
#else
        if(errno == EAGAIN) return 0;
#endif
		else exit(12);
    }

	close(data->serversock);
	data->serversock = 0;

	data->sock = sock;

	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);
	return 1;
}


Data data_connect(const char *host,int port) {
#ifdef WIN32
    LPHOSTENT hp;
    SOCKADDR_IN sin;
#else
    struct  hostent *hp;
    struct sockaddr_in sin;
#endif
a26 22
    int sock;

    sock = socket(AF_INET,SOCK_STREAM,0);
    if(sock == -1) exit(13);

    if(!(hp = gethostbyname(host))) {
#ifdef WIN32
        fprintf(stderr,"gethostbyname(): %d\n",WSAGetLastError());
#else
        herror("gethostbyname");
#endif
        exit(1);
    }
                                                                                
    sin.sin_family = AF_INET;
    sin.sin_addr = **((struct in_addr **)hp->h_addr_list);
    sin.sin_port = htons((short)port);

    if(connect(sock,(struct sockaddr*)&sin,sizeof(sin))) {
        fprintf(stderr,"connect('%s',%d)\n",host,port);
        NETERROR("connect()");
    }
d31 5
a35 2
	// buffers..., init
	buff_init(&data->buffer,&data->pool,&data->len);
d40 2
a41 7
//void *send_buff = NULL;
//int   send_pool = 0; // size of malloced buffer
//int	  send_len  = 0; // real data length

void data_send_init(Data data,int cols) {
	if(!data->send_buff) 
		buff_init(&data->send_buff,&data->send_pool,&data->send_len);
d44 2
a45 64
void data_send_append(Data data,char *col,int len) {
	unsigned char code = LEN_RESERVED;
	unsigned char *buff = NULL; 
	int buff_len = 0;

	if(len <= 0) {
		if(len < 0) exit(18);
		code = col ? LEN_EMPTY : LEN_UNDEF;
	}
	if(len == 1 && isdigit(col[0])) {
		code = LEN_0 + (col[0] - '0');
	}
	if(len == 2 && isdigit(col[0]) && isdigit(col[1])) {
		code = LEN_00 + 10*(col[0] - '0') + (col[1] - '0');
	}
	if(code) {
		buff = buff_insert(&data->send_buff,&data->send_pool,
						  &data->send_len,buff_len = 1);
		*buff = code;
	}
	if(!code) {
		if(len <= LEN_MAXLEN) {
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + len );
			*buff = code = len;
			memcpy(buff + 1, col, len);
		} else {
			uint32_t len32 = htonl(len);
			buff = buff_insert(&data->send_buff, &data->send_pool,
							   &data->send_len, buff_len = 1 + 4 + len );
			*buff = code = LEN_32BIT;
			memcpy(buff + 1, &len32, 4);
			memcpy(buff + 5, col, len);
		}
	}
}

static void write2(int fd,unsigned char *buff,int len) {
	int i;
	printf(">>> write(%d):\n",len);
	for(i=0;i<len;i++) {
		printf("%3d ",buff[i]);
		if(i%20==19) printf("\n");
	}
	write(fd,buff,len);
	printf("<<<\n");
}

void data_send_flush(Data data) {
	unsigned char *ptr = buff_insert(&data->send_buff,
									 &data->send_pool,&data->send_len,1);
	*ptr = LEN_ENDOFROW;
	if(data->send_len >= BUFF_PAGE) {
		write(data->sock,data->send_buff,data->send_len);
		data->send_len = 0;
	}
}

void data_close(Data data) {
	if(data->send_len) write(data->sock,data->send_buff,data->send_len);
	buff_free(&data->send_buff,&data->send_pool,&data->send_len);
	buff_free(&data->buffer,&data->pool,&data->len);
	close(data->sock);
	free(data);
d48 2
a49 40
int data_recv(Data data) {
	int i,len;
	unsigned char *buff;

	buff_extend(&(void*)(data->buffer),&data->pool,&data->len,BUFF_PAGE);

	len = read(data->sock,data->buffer + data->len,BUFF_PAGE);
	if(len < 0) exit(17);

	data->len += len;
	return len;
}


int data_is_row(Data data) {
	unsigned char code, *ptr;
	uint32_t len32;
	int row, len, columns = 0;

	len = data->len - data->offset;
	if(len < 1) return -1;

	ptr = data->buffer + data->offset;

	while((len > 0) && ((code=(*ptr)) != LEN_ENDOFROW)) {
		if(code >= 1 && code <= LEN_MAXLEN) row = code;
		if(code == LEN_32BIT) {
			memcpy(&len32,ptr+1,4);
			row = 4 + ntohl(len32);
		}
		if(code >= LEN_0 && code <= LEN_99) row = 0;
		if(code == LEN_EMPTY || code == LEN_UNDEF) row = 0;

		if(row == -1) exit(20); // unknown code

		len -= 1 + row;
		ptr += 1 + row;
		columns++;
	}
	return ((len > 0) && ((*ptr) == LEN_ENDOFROW)) ? columns : -1;
d52 1
a52 43
static const char *numbers = "00010203040506070809";

int data_extract(Data data,void **buff,int *len) {
	uint32_t len32;
	unsigned char *ptr = data->buffer + data->offset;
	unsigned char code = *ptr;

	if(code >= 1 && code <= LEN_MAXLEN) {
		*buff = ptr + 1;
		*len = code;
		return 1 + code;
	}
	if(code == LEN_32BIT) {
		memcpy(&len32,ptr+1,4);
		*len  = ntohl(len32);
		*buff = ptr + 1 + 4;	
		return 1 + 4 + (*len);
	}
	if(code >= LEN_0 && code <= LEN_9) {
		*buff = NULL; *len = code - LEN_0;
		return 1;
	}
	if(code >= LEN_00 && code <= LEN_09) {
		*buff = (void*)(numbers + 2*(code - LEN_00));
		*len = 2;
		return 1;
	}
	if(code >= LEN_10 && code <= LEN_99) {
		*buff = NULL; *len = 10 + code - LEN_10;
		return 1;
	}
	if(code == LEN_EMPTY) {
		*buff = (void*)numbers; *len = 0;
		return 1;
	}
	if(code == LEN_UNDEF) {
		*buff = NULL;
		*len = -1;
		return 1;
	}

	printf("error: code=%d\n",code);
	exit(21);
@


1.3
log
@send/recv bugs in buffers, minimum syscalls
@
text
@d90 3
a92 1
    if(bind(sock,(struct sockaddr*)sin,sizeof(*sin))) NETERROR("bind()");
@


1.2
log
@send/recv, in C, optimized, LEN_ code, small integers
@
text
@d49 11
a59 1
static void *buff_alloc(void **buff,int *pool,int *len,int size) {
d61 1
a61 2
	if(*len > *pool) *buff = realloc(*buff,*pool += BUFF_PAGE);
	return *buff + *len - size; // start of free area
d135 3
d187 3
a189 3
void *send_buff = NULL;
int   send_pool = 0; // size of malloced buffer
int	  send_len  = 0; // real data length
d192 2
a193 1
	if(!send_buff) buff_init(&send_buff,&send_pool,&send_len);
d212 2
a213 1
		buff = buff_alloc(&send_buff,&send_pool,&send_len,buff_len = 1);
d218 2
a219 2
			buff = buff_alloc(&send_buff,&send_pool,&send_len,
							 buff_len = 1 + len );
d224 2
a225 2
			buff = buff_alloc(&send_buff,&send_pool,&send_len,
							 buff_len = 1 + 4 + len );
d233 11
d245 2
a246 1
	unsigned char *ptr = buff_alloc(&send_buff,&send_pool,&send_len,1);
d248 12
a259 2
	write(data->sock,send_buff,send_len);
	buff_clear(&send_buff,&send_pool,&send_len);
d266 4
a269 2
	if(data->pool - data->len < 4096)
		buff_alloc(&(void*)(data->buffer),&data->pool,&data->len,4096);
a270 2
	len = read(data->sock,data->buffer + data->len,4096);
	printf("read() %d\n",len);
a271 2

	if(len < 0) exit(17);
d345 1
@


1.1
log
@Data module added (empty)
@
text
@d4 1
d12 8
a23 3
#define BUFF_SIZE_INITIAL	8192
#define BUFF_SIZE_INC		4096

d29 87
d117 25
a141 2
// base constructor
Data create_data(int sock) {
d143 22
d169 5
a173 3
	data->buff_len = BUFF_SIZE_INITIAL;
	data->buffer = malloc(data->buff_len);
	data->real_len = 0;
d175 7
a181 1
	DEBUG("creating DATA(sock=%d)\n",data->sock);
d183 34
a216 1
	return data;
d219 5
a223 2
Data data_listen(int port) {
	return NULL;
d226 13
a238 2
Data data_connect(const char *host,int port) {
	return NULL;
d241 27
a267 2
char *data_recv(Data data,int *len) {
	return NULL;
d270 42
a311 1
void data_send(Data data,const char *buffer,int len) {
@

