head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2003.12.02.12.29.49;	author tuco80;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.10.15.15.55;	author tuco80;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.06.14.31.46;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated and revised
@
text
@
ARCHITECTURE
------------


Basically, BEE consists of two parts: client and server.

Client part is used for modelling and controlling ETL processes.
Using grafical user interface you can create the physical and 
logical models, adding all the necessary objects needed to represent
Then bothj.

For the Logical model you can add attributes, facts, relations 
between them, organize and group the attributes, change the
appearance of each group for easier distinction of each one, 
and modify their basic properties.  For the physical model, 
you can manage hosts, sources (DB), tables (and columns), Files, 
triggers (which are meant to  synchronize blocks of ETL processing 
but are useless at the moment), constants, relations and, again, 
edit most of their basic properties.

Last but not least, you can also define the ETL processes, by
defining bees, arity of their inputs and outputs, sources, and
the flow of data between them.  Note that when it comes to the 
arity of the inputs and outputs, you can make input arity higher
after it is defined, but not the other way around, so be careful when
liking things to it (i.e. that "automatic" increase of the arity
when you drag something to a "full" input).  As for outputs, you can
only have them with the arity they are created.

The whole environment of the GUI is represented by an XML file, which describes
not only the objects themselves, but also their appearance in the cases where
such is applicable. Most of the things described in this XML file can be
already edited or created in the GUI; there are, however, a few things that
you will have to edit directly in the XML if you want them changed, but these
are the least and we tried to make them be the least necessary ones, so that 
you can probaly live without those changes.  You can refer to beetl.dtd under 
the $BEEDIR/gui directory or a demo to see the sintax of such things, should 
you really need them changed.

Take in count that we are assuming that the user of this project is an
advanced one, and in most cases we are not making any consistency checks,
for example, you can create a DB source, with tables and columns, but
it is assumed that they actually exist, and if they don't then an ERROR
will occur (in the future, they will be created if possible, but such
functionality is not developed yet).

A rather important note on this subject is what you can link to bees.  The 
GUI itself will let you link just about anything to/from its in/outputs,
different fields (each dot in the same input for example, when its arity
is of two or more),take into account though, that not everything is allowed.  
You can only attach one data source to a same input (the arity is provided
so that you can specify wich rows you want from a table, and in what order
you want them), eventhough the GUI will let you link eight different rows, 
from eight different tables, in eight different hosts, to an input with
arity 8.  This is allowed by the GUI, because we plan that in the future 
such thing will be possible.

So what can be done that is supported??  Well, links (bee-bee) are used
as having arity one (the real arity is handled with the code inside the
two bees involved), files also have arity one, only one data source
(i.e. table) can be attached to a single in/output (although you CAN 
put a constant there, in whatever field you wish), you can leave empty
spaces, that's also fine.  If you have questions regarding what is
supported and what not, contact one of the authors.

A server daemon running on a particular host is used to access
data or use the CPU on that host. In production systems, you
will probably want to access data from several hosts, so
you'll have to run server daemon (dad), on all of these hosts.

Per-host server daemons -- dads -- handle creation and running of
transformation processes -- bees. The hosts, on which reside
data files or localy accessible database engines, are connected 
together and to client using the network and serves data download, 
upload or transformations.

The whole ETL process is modelled in XML task scheme file -- look at examples
in $bee/client/demo/ directory. This '.scheme' file describes on which dads
should run which scripts (transformations), what is connected to it's inputs 
(which data sources) and where to send script's outputs (database or another
bee).

Every ETL script is stored in a separate '.bee' file, linked from main .scheme
file. It consists of Perl code embeded in descriptive XML data.
You may look at examples again (e.g. pass.bee, find.bee).




@


1.2
log
@Updated docs
@
text
@d6 1
a6 1
Basicaly, BEE consists of two parts: client and server.
d9 3
a11 1
Using grafical user interface you can # TODO: describe client
d13 56
a68 2
Server daemon running on particular host is used to access
data or CPU usage on that host. In production systems, you
d72 1
a72 1
Per-host server daemons -- dads -- handles creation and running of
d86 3
a88 1
You may look at examples again (e.g. pass.bee, find.bee)...
@


1.1
log
@demo updates (display:// problem)
@
text
@d12 1
a12 1
data or CPU usage on that host. In production system, you
d14 1
a14 1
you have to run server daemon (dad), on all of these hosts.
d16 5
a20 5
Per-host server daemons -- dads -- handles creation and running
transformation processes -- bees. The hosts, on which resides
data files or localy accessible database engines, are connected together
and to client using network and serves data download, upload or data
transformations.
d22 1
a22 1
Whole ETL process is modelled in XML task scheme file -- look at examples
d24 1
a24 1
should run which script (transformation), what is connected to it's inputs 
d28 1
a28 1
Every ETL script is stored in separate '.bee' file, linked from main .scheme
@

