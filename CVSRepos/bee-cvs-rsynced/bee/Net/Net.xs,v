head	1.11;
access;
symbols;
locks; strict;
comment	@# @;


1.11
date	2003.10.30.09.38.31;	author numberone;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.29.18.49.18;	author numberone;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.29.11.47.22;	author numberone;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.29.11.09.57;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.29.10.52.23;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.29.08.27.16;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.29.06.59.08;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.27.15.25.17;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.27.14.54.18;	author numberone;	state dead;
branches;
next	1.2;

1.2
date	2003.08.22.12.54.25;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.03.13.15.39;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.11
log
@net->port instead of net->listen
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include<stdio.h>
#include "libnet/net.h"


MODULE = Net	PACKAGE = Net

bool
init(pkg,certfile,keyfile,password)
	char*	pkg
	char*	certfile
	char*	keyfile
	char*	password
CODE:
	RETVAL = net_init(certfile,keyfile,password);
OUTPUT:
	RETVAL

Net
server(pkg,sys_type,...)
	char*	pkg
	char*	sys_type
PREINIT:
	int	port;
CODE:
	if(!strcmp(sys_type,"INET")) {
		if(items < 2 || items > 3)
				 croak("Usage: Net->server('INET',[port])");
		port = (items == 2) ? 0 : SvIV(ST(2));
		RETVAL = net_server_inet(port);
	} else 
	if(!strcmp(sys_type,"UNIX")) {
		croak("named pipes not implemented");
	} else
	if(!strcmp(sys_type,"SSL")) {
		if(items < 2 || items > 3)
				 croak("Usage: Net->server('SSL',[port])");
		port = (items == 2) ? 0 : SvIV(ST(2));
		RETVAL = net_server_ssl(port);
	} else
	croak("unsupported sys_type: %s",sys_type);
OUTPUT:
	RETVAL

Net
accept(net,wait=1)
	Net net
	bool wait
CODE:
	RETVAL = net_accept(net,wait);
OUTPUT:
	RETVAL

Net
connect(pkg,sys_type,...)
	char*	pkg
	char*	sys_type
PREINIT:
	char*	host;
	int		port;
CODE:
	if(!strcmp(sys_type,"INET")) {
		if(items == 4) {
			host = SvPV(ST(2),PL_na);
			port = SvIV(ST(3));
		} else croak("Usage: Net->connect('INET',host,port)");
		RETVAL = net_connect_inet(host,port);
	} else
	if(!strcmp(sys_type,"UNIX")) {
		croak("named pipes not implemented");
	} else 
	if(!strcmp(sys_type,"SSL")) {
		if(items == 4) {
			host = SvPV(ST(2),PL_na);
			port = SvIV(ST(3));
		} else croak("Usage: Net->connect('SSL',host,port)");
		RETVAL = net_connect_ssl(host,port);
	} else
	croak("unsupported sys_type: %s",sys_type);
OUTPUT:
	RETVAL


void
socketpair(pkg)
	char*	pkg
PREINIT:
	Net		net[2];
	SV*		sv0;
	SV*		sv1;
PPCODE:
	if(!net_socketpair_unix(net)) XSRETURN_UNDEF;
	/* im not sure whether i'm doing this well */
	EXTEND(SP, 2);
	sv0 = sv_newmortal();
	sv_setref_pv(sv0,"Net",(void*)net[0]);
	PUSHs(sv0);
	sv1 = sv_newmortal();
	sv_setref_pv(sv1,"Net",(void*)net[1]);
	PUSHs(sv1);


Net
tie_fd(pkg,fd)
	char*	pkg
	int		fd
CODE:
	RETVAL = net_tie_fd(fd);
OUTPUT:
	RETVAL


int
peek(net)
	Net net
CODE:
	RETVAL = net_peek(net);
OUTPUT:
	RETVAL

int
write(net,chunk)
	Net	net
	SV*	chunk
PREINIT:
	void*	buffer;
	int		len;
CODE:
	buffer = (void*)SvPV(chunk,len);
	RETVAL = net_write(net,buffer,len);
OUTPUT:
	RETVAL

SV*
read(net)
	Net net
PREINIT:
	int	len;
	void* buffer;
CODE:
	buffer = (void*)net_read(net,&len);
	if(!buffer) {
		if(len < 0) { XSRETURN_UNDEF; }    /* error - undef */
			   else { RETVAL = newSV(0); } /* idle  - ""    */
	} else {
		RETVAL = newSVpv((char*)buffer,len);
		net_free(buffer);
	}
OUTPUT:
	RETVAL

int
select(pkg,...)
	char*	pkg;
PREINIT:
/*	Net 	*nets;
	int		item,count=0;
	int 	retval;*/
CODE:
/*	nets = malloc((items+1) * sizeof(Net));
	printf("select: items = %d, nets = %p\n",items,nets);
	for(count = item = 0; item < items; item++ ) {
		if(sv_derived_from(ST(item),"Net")) {
			IV tmp = SvIV((SV*)SvRV(ST(item)));
			if(tmp) nets[count++]= INT2PTR(Net,tmp);
		} 
//		else croak("Usage: Net->select(@@nets)");
	}
	nets[count] = NULL;
//	if(items == 2) micro = SvIV(ST(1));

	printf("select: calling net_select\n");
	retval = net_select(nets,100000000);
	printf("select(#%d) -> %d\n",count,retval);
	free(nets);
	RETVAL = retval; */
	RETVAL = net_select(NULL,1000000000);
OUTPUT:
	RETVAL

char*
peer(net)
	Net net
CODE:
	RETVAL = net_peer(net);
OUTPUT:
	RETVAL

char*
auth(net)
	Net net
CODE:
	RETVAL = net_auth(net);
OUTPUT:
	RETVAL

int
sock(net)
	Net net
CODE:
	RETVAL = net->sock;
OUTPUT:
	RETVAL

void
DESTROY(net)
	Net net
CODE:
	net_close(net);

int
port(net)
	Net net
CODE:
	RETVAL = net_port(net);
OUTPUT:
	RETVAL



@


1.10
log
@windoze fails..
@
text
@d219 1
a219 1
	RETVAL = net_listen(net);
@


1.9
log
@ssl port autoallocation
@
text
@a224 1

@


1.8
log
@working dynamic port allocation
working dynamic port allocation
@
text
@d40 3
a42 2
		if(items == 3) port = SvIV(ST(2));
				 else croak("Usage: Net->server('SSL',port)");
@


1.7
log
@automatic port allocation, net->listen returns port number
@
text
@d215 1
a215 1
listen(net)
@


1.6
log
@compile-time warnings removed
@
text
@d31 3
a33 2
		if(items == 3) port = SvIV(ST(2));
				 else croak("Usage: Net->server('INET',port)");
d213 8
@


1.5
log
@libNet -- no warnings..
@
text
@d179 1
a179 1
	net_select(NULL,1000000000);
@


1.4
log
@next update
@
text
@d158 1
a158 1
	Net 	*nets;
d160 1
a160 1
	int 	retval;
@


1.3
log
@Data under windows
@
text
@@


1.2
log
@net - select
@
text
@@


1.1
log
@bee-0.9.1 -- version merge
@
text
@d162 3
a164 2
	nets = malloc((items+1) * sizeof(Net));
	for(item=0;item<items;item++) {
d174 1
d178 2
a179 1
	RETVAL = retval;
@

