head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	2003.10.29.11.10.05;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.29.10.52.30;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.23.07.49.59;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.03.13.15.39;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.4
log
@working dynamic port allocation
working dynamic port allocation
@
text
@#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#ifdef WIN32
#include<winsock.h>
#else
#include <netdb.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#endif

#include "net.h"
#include "sys.h"


void NETERROR(char *fx) {
#ifdef WIN32
	fprintf(stderr,"%s: %d\n",fx,WSAGetLastError());
	exit(1);
#else
	perror(fx);
	exit(1);
#endif
}


// returns NULL on error
int tcp_accept(int lsock,void *sin_data,char *peer,int peer_size) {
	int sock;

#ifdef WIN32
	SOCKADDR_IN *sin;
	int sin_len = sizeof(SOCKADDR_IN);
	sin = (SOCKADDR_IN *)sin_data;
#else
	struct sockaddr_in *sin;
	int sin_len = sizeof(struct sockaddr_in);
	sin = (struct sockaddr_in *)sin_data;
#endif

	if(!sin) exit(5); // doing accept on non-server socket

	DEBUG("listening on port %d\n",ntohs(sin->sin_port));

	sock = accept(lsock,(void*)sin,&sin_len);

	if(sock == -1) {
#ifdef WIN32
		if(WSAGetLastError() == WSAEWOULDBLOCK) return 0;
#else
		if(errno == EAGAIN) return 0;
#endif
		   else NETERROR("accept()");
	}

	snprintf(peer,peer_size,"%s:%d",
			 inet_ntoa(sin->sin_addr),ntohs(sin->sin_port));
	return sock;
}



int tcp_listen(int *p_port,void **p_sin) {
#ifdef WIN32
	SOCKADDR_IN *sin,sa;
#else
	struct sockaddr_in *sin,sa;
#endif
	int  sock, yes=1, port, n = sizeof(sa);

	sock = socket(AF_INET,SOCK_STREAM,0);
	if(sock == -1) NETERROR("socket()");

	port = p_port ? *p_port : 0;
	sin = malloc(sizeof(*sin));
	sin->sin_family = AF_INET;
	sin->sin_addr.s_addr = htonl(INADDR_ANY);
	sin->sin_port = htons((short)port);

	if(bind(sock,(struct sockaddr*)sin,sizeof(*sin))) return -1;

	if(!port) {
		if(getsockname(sock,(struct sockaddr *)&sa, &n) < 0) exit(1);
		port = ntohs(sa.sin_port);
	}
	if(p_port) *p_port = port;

	// SOMAXCONN = 5 on m$
	if(listen(sock,SOMAXCONN)) NETERROR("listen()");

#ifndef WIN32
	if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)))
			NETERROR("setsockopt()");
#endif

	if(p_sin) *p_sin = sin;
	return sock;
}

int tcp_connect(const char *host,int port) {
#ifdef WIN32
	LPHOSTENT hp;
	SOCKADDR_IN sin;
#else
	struct	hostent *hp;
	struct sockaddr_in sin;
#endif
	int sock;

	sock = socket(AF_INET,SOCK_STREAM,0);
	if(sock == -1) NETERROR("socket()");

	if(!(hp = gethostbyname(host))) {
#ifdef WIN32
		fprintf(stderr,"gethostbyname(): %d\n",WSAGetLastError());
#else
		herror("gethostbyname");
#endif
		exit(1);
	}

	sin.sin_family = AF_INET;
	sin.sin_addr = **((struct in_addr **)hp->h_addr_list);
	sin.sin_port = htons((short)port);

	if(connect(sock,(struct sockaddr*)&sin,sizeof(sin))) {
		fprintf(stderr,"connect('%s',%d)\n",host,port);
		NETERROR("connect()");
	}

	DEBUG("connected to %s:%d\n",host,port);

	return sock;
}


// set non-blocking IO
void tcp_block(int sock,Bool block) {
#ifdef WIN32
    u_long arg = !block;
    if(ioctlsocket(sock,FIONBIO,&arg)) NETERROR("ioctlsocket()");
#else
	int  flags;
	flags = fcntl(sock,F_GETFL);
	if(flags == -1) NETERROR("fcntp()");
	flags = block ? (flags & (~O_NONBLOCK)) : (flags | O_NONBLOCK);
	flags = fcntl(sock,F_SETFL,flags);
	if(flags == -1) NETERROR("fcntl()");
#endif
}

@


1.3
log
@automatic port allocation, net->listen returns port number
@
text
@d74 1
a74 1
	SOCKADDR_IN *sin;
d76 1
a76 1
	struct sockaddr_in *sin;
d78 1
a78 1
	int  sock, yes=1, port;
d86 1
a86 1
	sin->sin_addr.s_addr = INADDR_ANY;
d91 4
a94 1
	port = ntohs(sin->sin_port);
@


1.2
log
@cleanup
compile-time warnings removed
@
text
@d72 1
a72 1
int tcp_listen(int port,void **p_sin) {
d78 1
a78 1
	int  sock, yes=1;
d83 1
d90 3
@


1.1
log
@bee-0.9.1 -- version merge
@
text
@d61 1
a61 1
#endif;
@

