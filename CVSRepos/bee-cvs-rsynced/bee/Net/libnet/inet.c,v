head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2003.10.30.09.38.42;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.30.09.05.55;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.29.10.52.30;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.29.06.59.08;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.22.12.54.25;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.03.13.15.39;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.6
log
@net->port instead of net->listen
@
text
@#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#ifdef WIN32
#include<winsock.h>
#else
#include <netdb.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#endif

#include "net.h"
#include "sys.h"


/*	inet_read, inet_write, inet_close and inet_block 	*
 *	are shared with NET::UNIX - unix.c!					*/


// read as many data as you can
// returns -1 on EOF (connection closed), 0 on idle, 1+ as datalength
// -2+ on serious error
int inet_read(Net net,void *buffer,int len) {
#ifdef WIN32
	tcp_block(net->sock,0);
	len = read(net->sock,buffer,len);
#else
	len = recv(net->sock,buffer,len,MSG_DONTWAIT);
#endif
	if(!len) return -1;
//	if(!len && (errno == EAGAIN)) return 0;
	if(len == -1) {
#ifdef WIN32
		if(WSAGetLastError() == WSAEWOULDBLOCK) return 0;
#else
		if(errno == EAGAIN) return 0;
#endif;
//		NETERROR("recv()");
		return -2;
	}
	if(!len) return -1;
	return len;
}


// SHOULD return 0 on error!
int inet_write(Net net,void *chunk,int len) {
	int err = send(net->sock,chunk,len,0);
	if(err == -1) return 0; //NETERROR("write()");
	return err; // length
}


// set non-blocking IO
void inet_block(Net net,Bool block) { 
	tcp_block(net->sock,block); 
}


void inet_close(Net net) {
	DEBUG("(inet|unix)_close: closing sock=%d\n",net->sock);
#ifdef WIN32
	closesocket(net->sock);
#else
	close(net->sock);
#endif
}


// returns NULL on error
Net inet_accept(Net net) {
	char peer[256];
	int sock;

	sock = tcp_accept(net->sock,net->data,peer,256);
	if(!sock) return NULL;
	DEBUG("connection from %s\n",peer);
	return create_net(NET_SYS_INET,sock,peer,NULL,NULL);
}


// constructor
Net net_server_inet(int port) {
	void *sin = NULL;
	char peer[10];
	int  sock;
	Net	 net;

	sock = tcp_listen(&port,&sin);
	if(sock == -1) return NULL;
	snprintf(peer,10,":%d",port);
	net = create_net(NET_SYS_INET,sock,peer,(char*)NULL,(void*)sin);
	net->port = port;
	return net;
}

// constructor
Net net_connect_inet(const char *host,int port) {
	char peer[256];
	int sock;

	sock = tcp_connect(host,port);
	snprintf(peer,256,"%s:%d",host,port);
	return create_net(NET_SYS_INET,sock,peer,NULL,NULL);
}


Bool inet_init() {
#ifdef WIN32
	WORD wVersionRequested = MAKEWORD(1,1);
	WSADATA wsaData;
	int nRet;

	// Initialize WinSock and check the version
	nRet = WSAStartup(wVersionRequested, &wsaData);
	if(wsaData.wVersion != wVersionRequested) {	
		fprintf(stderr,"winsock: wrong version\n");
		return false;
	}
#endif
	return true;
}


/* todo: WSACleanup() */

@


1.5
log
@ok, windows running, executes too processes, Data still doesn't work..
@
text
@d102 1
a102 1
	net->listen = port;
@


1.4
log
@automatic port allocation, net->listen returns port number
@
text
@d34 1
@


1.3
log
@libNet -- no warnings..
@
text
@d95 1
d97 1
a97 1
	sock = tcp_listen(port,&sin);
d100 3
a102 1
	return create_net(NET_SYS_INET,sock,peer,(char*)NULL,(void*)sin);
@


1.2
log
@net - select
@
text
@d33 3
d37 1
a37 1
/*	len = read(net->sock,buffer,len);*/
@


1.1
log
@bee-0.9.1 -- version merge
@
text
@d33 1
a33 1
	len = recv(net->sock,buffer,len,0);
d35 2
@

