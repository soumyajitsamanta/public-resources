head	1.9;
access;
symbols;
locks; strict;
comment	@# @;


1.9
date	2004.05.10.15.19.09;	author tuco80;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.10.13.15.45;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.30.09.05.55;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.29.18.49.24;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.29.12.25.27;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.29.11.50.24;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.05.11.29.34;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.11.06.53.58;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.12.23.37.08;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.9
log
@
return exit-status code correctly
@
text
@
package runtime;

use Data::Dumper;

#use lib ".";
#use lib "../lib";

use url;
use input;
use output;
use inout;

use Msg;
use Net;
use Data;


# =======================================================================

my $dad; # Msg from dad
my $out; # Msg to dad (display, status, quit, ..)
my $script; # xml

my @@intype;
my @@input  = ();
my @@outtype;
my @@output = ();

my $fly  = 0;
my $land = 0;

my $methods = {
    input  => \&rpc_input,
    output => \&rpc_output,
    letfly => sub { $fly = 1 },
	create => \&rpc_create,
};

sub rpc_create {
	$script = shift;

    @@intype  = map $_->{type}, @@{$script->{input}};
    @@outtype = map $_->{type}, @@{$script->{output}};

	return 1;
}

sub rpc_input {
    my($num,$arg) = @@_;
    return inout::new("input",$intype[$num],\$input[$num],$arg);
}

sub rpc_output {
    my($num,$arg) = @@_;
    return inout::new("output",$outtype[$num],\$output[$num],$arg);
}

	
sub init {
	my($inport,$outport,$name) = @@_;


	# is in Msg too and should not be anywhere
	# bee should have access to these keys!
	Net->init("./root.pem","./key.pem","bee");
	Data->init($name);

	$SIG{PIPE} = sub { print "SIGPIPE!!!\n" };

#	close(STDIN);
#	close(STDOUT);
#	close(STDERR);
#	open(STDIN,"/dev/null");
#	open(STDOUT,">>/dev/tty");
#	open(STDERR,">>/dev/tty");

	$dad = Msg->connect('SSL','localhost',$inport) or die;
	$out = Msg->connect('SSL','localhost',$outport) or die;

	while(1) {
		Msg->select();
		$dad->serve($methods) if($dad->peek);

		# here we have bug :-(
		# Msg->select is not waiting on Data sockets
		# Data->accept is called only after some comm on Msg
		input::listen();
		last if($fly);
	}

	 input::init(\@@intype, \@@input);
	output::init(\@@outtype,\@@output);

	foreach(my $i=0;$i<@@input;$i++) {
		my $name  = $script->{input}->[$i]->{name};
		*{"::$name"} = \$input[$i];
	}

	foreach(my $i=0;$i<@@output;$i++) {
		my $name  = $script->{output}->[$i]->{name};
		*{"::$name"} = \$output[$i];
	}

	$land = $fly = 0;
}

# called from *::display
sub out { $out }

sub END {

	# send 'successful quit' echo
	$out->send("landed $?");

	 input::close(\@@intype, \@@input);
	output::close(\@@outtype,\@@output);
}

init(@@::ARGV);

1;

@


1.8
log
@
path-17x100k benchmark

some dad cleanups
@
text
@d114 1
a114 2
	$out->send("landed 0");
#    $out->send("landed ".($land? '':(defined $result? $result : 0)));
@


1.7
log
@ok, windows running, executes too processes, Data still doesn't work..
@
text
@d16 1
a16 1
#use Data;
d61 2
a62 1
	my($inport,$outport) = @@_;
d67 3
d84 4
@


1.6
log
@windoze fails..
@
text
@d67 6
a72 6
	close(STDIN);
	close(STDOUT);
	close(STDERR);
	open(STDIN,"/dev/null");
	open(STDOUT,">>/dev/tty");
	open(STDERR,">>/dev/tty");
d74 2
a75 2
	$dad = Msg->connect('INET','localhost',$inport) or die;
	$out = Msg->connect('INET','localhost',$outport) or die;
@


1.5
log
@instead of creating pipes between dad and bee, we now
use tcp/ip connection.

it's because of windows, where it didn't work (maybe perl fault, i dunno)
@
text
@d63 4
@


1.4
log
@'dad/bee dir -- not empty so cvs co -P don\'t delete it
@
text
@d67 2
a68 2
#	open(STDOUT,">>/dev/tty");
#	open(STDERR,">>/dev/tty");
d70 2
a71 5
	$dad = Msg->connect('localhost',$inport) or die;
	$out = Msg->connect('localhost',$outport) or die;

#	$dad = Msg->tie_fd($infd) or die;
#	$out = Msg->tie_fd($outfd) or die;
@


1.3
log
@new dad code emerges in separate private location
@
text
@d61 1
a61 1
	my($infd,$outfd) = @@_;
d67 2
a68 2
	open(STDOUT,">>/dev/tty");
	open(STDERR,">>/dev/tty");
d70 5
a74 2
	$dad = Msg->tie_fd($infd) or die;
	$out = Msg->tie_fd($outfd) or die;
@


1.2
log
@merging old version to cvs
@
text
@d74 1
@


1.1
log
@runtime - library used after exec()
@
text
@a69 2
	print "hello from runtime\n";

@

