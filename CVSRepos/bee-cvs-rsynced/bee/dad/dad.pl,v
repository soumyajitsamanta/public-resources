head	1.23;
access;
symbols;
locks; strict;
comment	@# @;


1.23
date	2004.06.08.15.12.37;	author numberone;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.11.18.08.47;	author numberone;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.10.15.19.09;	author tuco80;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.10.13.15.45;	author numberone;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.08.10.28.12;	author numberone;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.21.08.16.01;	author numberone;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.13.11.59.05;	author numberone;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.10.14.40.04;	author numberone;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.30.10.32.45;	author numberone;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.30.09.05.55;	author numberone;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.29.11.50.24;	author numberone;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.29.08.17.38;	author numberone;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.23.15.22.32;	author numberone;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.23.09.04.41;	author numberone;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.12.09.12.42;	author numberone;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.05.11.29.34;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.22.12.55.25;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.08.17.55.33;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.07.11.06.25;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.03.13.16.14;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.12.23.35.13;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.17.23.38.14;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.05.17.20.26;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.23
log
@
Prepare API

every bee must call ->prepare() before ->put()/->fetch()

or they can call ->prepare_sql("SELECT/INSERT ...")

->put() is identical to new ->execute()
@
text
@#!/usr/bin/perl
# $Id: dad.pl,v 1.22 2004/05/11 18:08:47 numberone Exp $

use lib '.';
use client;
use bee;
use auth;

use lib '../lib';
use Net;

use POSIX ":sys_wait_h";

use Data::Dumper;
use strict;

# authority not used now
our $auth = undef;
#our $auth = new auth('localhost') or die;

# dad daemon
my $port = shift || 2333;
my $msg_server = Msg->server('SSL',$port) or die;

my @@client = (); # every client holds list of his bees

our %death; # dead bee status codes, global

sub sig_int {
	# cleanup childs
	foreach my $client (@@client) {
		kill 2, map $_->{id}, @@{$client->{bee}};
	}
}

$SIG{INT}  = \&sig_int;

# FIX daemonize: 
#   on unix: fork and exit; close close close
#   on moft: srvany.exe ?

print "listenning on ".$msg_server->port."\n";

# FIX: while(Net->peek)  or Net->select
# Net->select(@@list) - returns undef or index in @@list
# 		indicating network activity on list[index] socket
while(1) {
	my $client;

	Msg->select(); # TODO

	push @@client,new client($client)
		if($client = $msg_server->accept(0));

	foreach $client (@@client) {
		my $peek = $client->peek;

		if($peek <  0) { $client->close; }
		if($peek >  0) { $client->serve(); }
		if($peek == 0) {
			foreach (@@{$client->{bee}}) {
				$client->watch($_);
			}
		}
	}

	@@client = grep { not $_->{closed} } @@client;

	# my $pid = wait; # Win32 don't have WNOHANG :-(
	while((my $pid = waitpid(-1,WNOHANG)) > 0) {
		$death{$pid} = $?;
		print "bee $pid died ($?)\n";
	}
}

@


1.22
log
@
Support for UNIX sockets in Data library. Runs 2 times faster now :-)

inet: 1M @@ 95s

unix: 1M @@ 47s

Creates pipe in "/tmp/.bee-$$-".(i++), removes them after connection
success (pipe still work)
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.21 2004/05/10 15:19:09 tuco80 Exp $
d12 2
a28 8
sub reaper {
	$SIG{CHLD} = \&reaper; # bsd
	my $pid = wait;
	$SIG{CHLD} = \&reaper; # sysV!
	$death{$pid} = $?;
#	print "dad: pid $pid died ($?)\n"; # FIX: pid -1 died??
}

a35 1
$SIG{CHLD} = \&reaper;
d69 5
a73 4
#	while((my $pid = waitpid(-1,0)) > 0) {
#		print "bee $pid died\n";
#	}

@


1.21
log
@
return exit-status code correctly
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.20 2004/05/10 13:15:45 numberone Exp $
d32 1
a32 1
	print "dad: pid $pid died ($?)\n";
@


1.20
log
@
path-17x100k benchmark

some dad cleanups
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.19 2004/05/08 10:28:12 numberone Exp $
a30 1
	print "dad: pid $pid died\n";
d32 1
@


1.19
log
@
elegant client speedup -- do not sleep if there was message last cycle
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.18 2004/04/21 08:16:01 numberone Exp $
d28 1
d31 1
@


1.18
log
@
bee exit status code propagation

task.pl returns 0 on success, or error code of first died bee
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.17 2004/04/13 11:59:05 numberone Exp $
d33 7
d41 1
@


1.17
log
@
Do not destroy table on insert, unless there is create=".." arg in .xml
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.16 2003/11/10 14:40:04 numberone Exp $
d25 10
@


1.16
log
@ok, once again, use lib 'sarfy' removed
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.15 2003/10/30 10:32:45 numberone Exp $
d20 1
a20 1
my $port = shift;# || 2333;
@


1.15
log
@Data works on windows.. maybe on unix too, not tested..
@
text
@d2 1
a2 3
# $Id: dad.pl,v 1.14 2003/10/30 09:05:55 numberone Exp $

use lib '/home/sarfy/perl';
@


1.14
log
@ok, windows running, executes too processes, Data still doesn't work..
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.13 2003/10/29 11:50:24 numberone Exp $
d58 3
a60 3
	while((my $pid = waitpid(-1,WNOHANG)) > 0) {
		print "bee $pid died\n";
	}
@


1.13
log
@'dad/bee dir -- not empty so cvs co -P don\'t delete it
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.12 2003/10/29 08:17:38 numberone Exp $
d58 3
a60 3
#	while((my $pid = waitpid(-1,WNOHANG)) > 0) {
#		print "bee $pid died\n";
#	}
@


1.12
log
@removed -w because of XML::Simple
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.11 2003/10/23 15:22:32 numberone Exp $
d22 1
a22 1
my $port = shift || 2333;
d31 1
a31 1
print "listenning on $port\n";
@


1.11
log
@typo, not perl -v, but perl -w! :-)
@
text
@d1 2
a2 2
#!/usr/bin/perl -w
# $Id: dad.pl,v 1.10 2003/10/23 09:04:41 numberone Exp $
@


1.10
log
@dad: added -w to #!/usr/bin/perl -w
@
text
@d1 2
a2 2
#!/usr/bin/perl -v
# $Id: dad.pl,v 1.9 2003/09/12 09:12:42 numberone Exp $
@


1.9
log
@user@@pass url
@
text
@d1 2
a2 2
#!/usr/bin/perl
# $Id: dad.pl,v 1.8 2003/09/05 11:29:34 numberone Exp $
@


1.8
log
@new dad code emerges in separate private location
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.7 2003/08/22 12:55:25 numberone Exp $
d19 1
a19 1
# our $auth = new auth('localhost') or die;
@


1.7
log
@fix
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.6 2003/07/08 17:55:33 numberone Exp $
d17 3
a19 1
our $auth = new auth('localhost') or die;
@


1.6
log
@send/recv, in C, optimized, LEN_ code, small integers
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.5 2003/07/07 11:06:25 numberone Exp $
a60 2


@


1.5
log
@Data module added (empty)
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.4 2003/06/03 13:16:14 numberone Exp $
d36 2
@


1.4
log
@0.9.1 -- version merge
@
text
@d2 3
a4 1
# $Id: dad.pl,v 1.3 2003/03/12 23:35:13 numberone Exp $
@


1.3
log
@bee/ directory - where to store temporary script files
dad now use processes (fork and exec) to run bee instead
of forking and `eval`-uating.
perl -e "use DBI; fork;" sigfaults on Microsoft Windows
so this fixes this problem
@
text
@d2 1
a2 1
# $Id: dad.pl,v 1.2 2003/02/17 23:38:14 numberone Exp $
d19 1
a19 1
my $msg_server = Msg->server('SSL',$port);
@


1.2
log
@demo certificate + some keys
certs/newkey.sh - script for automated key generation
@
text
@d1 2
a2 2
#!/usr/bin/perl -w
# $Id: dad.pl,v 1.1 2003/02/05 17:20:26 numberone Exp $
@


1.1
log
@otec deleted
@
text
@d2 1
a2 1
# $Id$
d15 1
a15 1
our $auth = new auth(['localhost'],'','') or die;
d19 1
a19 1
my $msg_server = Msg->server('INET',$port);
@

