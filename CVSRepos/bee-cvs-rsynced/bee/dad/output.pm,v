head	1.9;
access;
symbols;
locks; strict;
comment	@# @;


1.9
date	2004.06.08.15.12.37;	author numberone;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.13.11.59.05;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.06.15.33.12;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.06.14.31.45;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.08.17.55.33;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.03.13.16.14;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.12.23.35.13;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.17.23.43.47;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.05.17.20.29;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.9
log
@
Prepare API

every bee must call ->prepare() before ->put()/->fetch()

or they can call ->prepare_sql("SELECT/INSERT ...")

->put() is identical to new ->execute()
@
text
@# $Id: output.pm,v 1.8 2004/04/13 11:59:05 numberone Exp $

package output;

use inout;

use lib '.';
use common;

use lib '../lib';
use Net;

use Data::Dumper;
use strict;

sub new {
	my $pkg = shift;
	die "$pkg unsupported now\n";
}

sub init {
	my($type,$output) = @@_;

	# output::scalar is special
	for(my $i=0;$i<@@$type;$i++) {
		$output->[$i] = \$output->[$i] if($type->[$i] eq 'scalar');
	}

}


sub close {
	my($type,$output) = @@_;

	for(my $i=0;$i<@@$type;$i++) {
		if(ref $output->[$i] eq 'output::stream::file') {
			undef $output->[$i]->{handle};
			next;
		}
		next if($type->[$i] eq 'scalar');

		undef $output->[$i];
	}
}


# ===============================================================

package output::signal;
#package output::stream::display;
package output::table; # same as input::table


# ===============================================================

package output::scalar;

use inout;
our @@ISA = qw(inout);

use Data::Dumper;

# this is called when we want to attach
# to the result == get result value!
sub new { 
	my($pkg,$url,$arg,$data_p) = @@_;
	return [undef,$$data_p];
#	my $result = shift;
#	return [undef,$$result];
}


# ===============================================================

# fix: merge with input::dbi !
package output::dbi;

use inout;
our @@ISA = qw(inout);

sub new {
	my($pkg,$url,$arg) = @@_;
    my $db = common::database($url,$arg->{auth});
    return [[$db,@@{$arg->{arg}}],''];
}


# ===============================================================

package output::stream::display;

use inout;
our @@ISA = qw(inout);

use Data::Dumper;

sub new {
	my($pkg,$url,$arg) = @@_;

	die if($url->{table} or not $url->{fields});
	die if(ref $url->{fields} ne 'ARRAY');

	bless { msg => runtime::out(), fields => $url->{fields} }, $pkg;
}

sub put { 
	my($output) = shift;
	foreach(@@_) {
		s/\\/\\\\/g;
		s/\n/\\n/g;
		s/\t/\\t/g;
	}
	my $line = join("\t",@@_);
	$output->{msg}->send("display $line");
}

# ===============================================================

package output::stream::bee;

use inout;
our @@ISA = qw(inout);

use Data;

sub new {
	my($pkg,$url,$arg) = @@_;
	my $listen = $arg->{listen} or die;

	die "to vzdavam\n" if(exists $listen->{unix});

	my $data = Data->connect($listen->{host},$listen->{port});
	return undef unless defined $data;

	return bless {
		data  => $data,
		stats => 0,
	}, __PACKAGE__;
}


sub put { shift->{data}->send(@@_); }


# ===============================================================

package output::stream::file;

#use inout::file;
our @@ISA = qw(inout::file);

sub put { inout::file::put(@@_) }

sub prepare { 
	my($table) = (@@_);
	if($table->{create}) {
		$table->create($table->{create});
		return $table->open(2); # truncate & write
	} else {
		return $table->open(1); # write
	}
}


# ===============================================================

package output::stream::insert;

#use inout::table;
our @@ISA = qw(inout::table);

sub put { inout::table::put(@@_) }

sub prepare { 
	my($self) = (@@_);
	if($self->{create}) {
		$self->create($self->{create});
		$self->open(2); # truncate & write
	} else {
		$self->open(1); # write
	}
}

1;


@


1.8
log
@
Do not destroy table on insert, unless there is create=".." arg in .xml
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.7 2003/11/06 15:33:12 numberone Exp $
d58 3
d79 1
d92 3
d121 3
d149 2
a150 1
use inout;
d152 1
a152 2
sub new {
	my($pkg,$url,$arg) = @@_;
d154 5
a158 4
	my $table = new inout::file($url,$arg);
	if($arg->{create}) {
		$table->create($arg->{create});
		$table->open(2); # truncate & write
d160 1
a160 1
		$table->open(1); # write
a161 3

	# rebless: allow only put
	return bless $table,$pkg;
a163 3
sub put { inout::file::put(@@_) }


d169 2
a170 1
use inout;
d172 1
a172 4
sub new {
	my($pkg,$url,$arg) = @@_;

	my $dbi = new inout::table($url,$arg);
d174 5
a178 3
	if($arg->{create}) {
		$dbi->create($arg->{create});
		$dbi->open(2); # truncate & write
d180 1
a180 1
		$dbi->open(1); # write
a181 3

	# rebless: allow only put
	return bless $dbi,$pkg;
a183 2
sub put { inout::table::put(@@_) }

@


1.7
log
@debug strings removed from Data/libdata
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.6 2003/11/06 14:31:45 numberone Exp $
d145 6
a150 2
	$table->create($arg->{create});
	$table->open(1); # truncate & write
d171 6
a176 2
	$dbi->create($arg->{create}) if(exists $arg->{create});
	$dbi->open(1);
@


1.6
log
@demo updates (display:// problem)
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.5 2003/07/08 17:55:33 numberone Exp $
d92 1
a92 1
	print Dumper($url);
@


1.5
log
@send/recv, in C, optimized, LEN_ code, small integers
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.4 2003/06/03 13:16:14 numberone Exp $
d92 1
@


1.4
log
@0.9.1 -- version merge
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.3 2003/03/12 23:35:13 numberone Exp $
d113 2
d121 2
a122 2
	my $net = Net->connect("INET",$listen->{host},$listen->{port});
	return undef unless defined $net;
d125 1
a125 1
		net   => $net,
d131 1
a131 25
# should be rewritten to optimized C
# field format:
#          'short' == '<5>short'  # length(short) < 192
# 'very long text' == '<254><32-bit length>very long text'
#            undef == '<255>'
# [ todo: int, date, float, ... types support (codes 192-253) ]

sub put {
	my $output = shift;

	my $line = "";
	foreach(@@_) {
		if(not defined $_) {
			$line .= pack("C",255);
			next;
		} elsif(length($_) < 192) {
			$line .= pack("C",length($_));
		} else {
			$line .= pack("CN",254,length($_));
		}
        $line .= $_;
	}
	$output->{net}->write($line);
}

@


1.3
log
@bee/ directory - where to store temporary script files
dad now use processes (fork and exec) to run bee instead
of forking and `eval`-uating.
perl -e "use DBI; fork;" sigfaults on Microsoft Windows
so this fixes this problem
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.2 2003/02/17 23:43:47 numberone Exp $
d149 1
a149 1
		$line .= $_;
@


1.2
log
@typos2
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.1 2003/02/05 17:20:29 numberone Exp $
d95 1
a95 1
	bless {msg=>$bee::dad_server, fields=>$url->{fields}},$pkg;
@


1.1
log
@otec deleted
@
text
@d1 1
a1 1
# $Id: output.pm,v 1.5 2002/09/29 13:46:47 numberone Exp $
d198 1
@

