head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2004.06.15.10.11.40;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.11.06.53.57;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.2
log
@
new Prepare API

This breaks compatibility with old .bee code, because every stream
input/output must be initialized first, bee has to call ->prepare()
method on stream objects in .bee code before calling ->put or ->get.

Or, instead of ->prepare(), bee can call general ->prepare_sql($cmd),
or, in the future, methods like ->prepare_select($table,$cols,$where,..),
->prepare_update(...), ->prepare_delete(...)

Next new method, execute(), is same as put() for UPDATE or DELETE.
But note that in order to do SELECT, we need to call DBI's execute().
Method prepare() with no arguments call's execute() for as.

So, correct is:

$input->prepare()
$input->fetch, fetch, fetch, ..

$input->prepare_sql("SELECT ...") or die "no SQL stream"
$input->exeucte() # !
$input->fetch, fetch, fetch, ..

$input->prepare_sql("UPDATE ...") or die "no SQL stream"
$input->execute(..), execute, excute (or put())

All stream .bee input/output variables have following methods:

prepare()         -- prepare and execute DBI statement
prepare_sql($cmd) -- prepare DBI statement
execute()         -- execute DBI statement
put()             -- execute DBI statement or write to stream
fetch()           -- fetch from DBI statement or read to stream
table()           -- returns table name, from URL
fields()          -- returns list of fields, from URL
@
text
@<?xml version="1.0" encoding="ISO-8859-2"?>
<script lang="perl" name='domain'>

<input name="Names"  type='stream' arity="1" />
<input name="Lu_old" type='stream' arity="2" />

<output name="Out"    type='stream' arity="1"/>
<output name="Lu_new" type='stream' arity="2" />

<code>
<![CDATA[

$Lu_old->prepare();

my %lu_old,%lu_new;
my $max = 0;
print "DOMAIN: reading lu_domain\n";
while(my($id,$name) = $Lu_old->fetch) {
	$lu_old{$name} = $id;
	$max = $id if($id > $max);
}

$Names->prepare();
$Out->prepare();

print "DOMAIN: main loop\n";
while(my($name) = $Names->fetch) {
	if(exists $lu_old{$name}) {
		$Out->put($lu_old{$name});
	} else {
		$Out->put($lu_new{$name} = ++$max);
	}
}

$Lu_new->prepare();

print "DOMAIN: updating lu_domain (".(scalar keys %lu_new)." records)\n";
$Lu_new->put($lu_new{$_},$_) foreach keys %lu_new;

]]>
</code>

</script>

@


1.1
log
@merging old version to cvs
@
text
@d13 2
d23 3
d35 2
@

