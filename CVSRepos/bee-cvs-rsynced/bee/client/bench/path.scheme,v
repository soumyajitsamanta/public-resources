head	1.4;
access;
symbols;
locks; strict;
comment	@# @;


1.4
date	2004.06.08.15.11.59;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.11.18.08.47;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.10.13.15.44;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.08.10.26.56;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.4
log
@
Prepare API

every bee must call ->prepare() before ->put()/->fetch()

or they can call ->prepare_sql("SELECT/INSERT ...")

->put() is identical to new ->execute()
@
text
@<?xml version="1.0" encoding="ISO-8859-2"?>

<task>
<otec host='localhost' port='2333' >

    <bee name='gen2' script='gen2.bee' >
		<input input='1' url='scalar://'>1000000</input>
	</bee>

	<bee name='id1' script='id.bee' />

    <bee name='eat2' script='eat2.bee' />

</otec>

<links>
gen2/1 eat2/1
gen2/2 id1/1
id1/1  eat2/2
</links>

</task>


@


1.3
log
@
Support for UNIX sockets in Data library. Runs 2 times faster now :-)

inet: 1M @@ 95s

unix: 1M @@ 47s

Creates pipe in "/tmp/.bee-$$-".(i++), removes them after connection
success (pipe still work)
@
text
@d7 1
a7 1
		<input input='1' url='scalar://'>10000</input>
d17 3
a19 3
gen2/1 id1/1
id1/1  eat2/1
gen2/2 eat2/2
@


1.2
log
@
path-17x100k benchmark

some dad cleanups
@
text
@d7 1
a7 1
		<input input='1' url='scalar://'>1000000</input>
@


1.1
log
@
demo with two paths of data flow, of different lengths
@
text
@d7 1
a7 1
		<input input='1' url='scalar://'>30</input>
a10 2
    <bee name='id2' script='id.bee' />
	<bee name='id3' script='id.bee' />
d16 5
a20 21
<link>
	<src  bee='gen2' output='1' />
	<dest bee='eat2' input ='1' />
</link>

<link>
	<src  bee='gen2' output='2' />
	<dest bee='id1'  input ='1' />
</link>
<link>
	<src  bee='id1'  output='1' />
	<dest bee='id2'  input ='1' />
</link>
<link>
	<src  bee='id2'  output='1' />
	<dest bee='id3'  input ='1' />
</link>
<link>
	<src  bee='id3'  output='1' />
	<dest bee='eat2' input ='2' />
</link>
@

