head	1.5;
access;
symbols;
locks; strict;
comment	@# @;


1.5
date	2004.06.15.10.11.40;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.08.15.11.59;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.11.18.08.47;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.10.13.15.44;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.08.10.26.56;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.5
log
@
new Prepare API

This breaks compatibility with old .bee code, because every stream
input/output must be initialized first, bee has to call ->prepare()
method on stream objects in .bee code before calling ->put or ->get.

Or, instead of ->prepare(), bee can call general ->prepare_sql($cmd),
or, in the future, methods like ->prepare_select($table,$cols,$where,..),
->prepare_update(...), ->prepare_delete(...)

Next new method, execute(), is same as put() for UPDATE or DELETE.
But note that in order to do SELECT, we need to call DBI's execute().
Method prepare() with no arguments call's execute() for as.

So, correct is:

$input->prepare()
$input->fetch, fetch, fetch, ..

$input->prepare_sql("SELECT ...") or die "no SQL stream"
$input->exeucte() # !
$input->fetch, fetch, fetch, ..

$input->prepare_sql("UPDATE ...") or die "no SQL stream"
$input->execute(..), execute, excute (or put())

All stream .bee input/output variables have following methods:

prepare()         -- prepare and execute DBI statement
prepare_sql($cmd) -- prepare DBI statement
execute()         -- execute DBI statement
put()             -- execute DBI statement or write to stream
fetch()           -- fetch from DBI statement or read to stream
table()           -- returns table name, from URL
fields()          -- returns list of fields, from URL
@
text
@<?xml version="1.0" encoding="ISO-8859-2"?>
<script lang="perl" name='eat2'>

<input name="in1" type='stream' arity='1' />
<input name="in2" type='stream' arity='1' />

<code>
<![CDATA[

print "eat2: hello, im $$\n";

in1->prepare();
in2->prepare();

my $i = 0;
#my(@@x,@@y);

while(1) {
	last unless($in1->fetch);
	$in2->fetch;
	$i++;
#	last unless((@@x) = $in1->fetch);
#	last unless((@@y) = $in2->fetch);

#	print "eat2: $i: [",join(", ",@@x),"], [",join(", ",@@y),"]\n" 
#		if((++$i & 16383) == 0);
}

print "eat2: $i rows readed\n";

]]>
</code>

</script>

@


1.4
log
@
Prepare API

every bee must call ->prepare() before ->put()/->fetch()

or they can call ->prepare_sql("SELECT/INSERT ...")

->put() is identical to new ->execute()
@
text
@d12 3
@


1.3
log
@
Support for UNIX sockets in Data library. Runs 2 times faster now :-)

inet: 1M @@ 95s

unix: 1M @@ 47s

Creates pipe in "/tmp/.bee-$$-".(i++), removes them after connection
success (pipe still work)
@
text
@d13 2
d16 5
a20 4
	last unless(my($x) = $in1->fetch);
	last unless(my($y) = $in2->fetch);

#	die if($x ne $y);
d22 2
a23 1
	print "eat2: $i \"$x\"\n" if((++$i % 10000) == 0);
@


1.2
log
@
path-17x100k benchmark

some dad cleanups
@
text
@d19 1
a19 1
#	print "eat2: $i \"$x\"\n" if((++$i % 1000) == 0);
d22 2
@


1.1
log
@
demo with two paths of data flow, of different lengths
@
text
@d2 1
a2 1
<script lang="perl" name='eat'>
d10 2
d17 1
a17 1
	die if($x ne $y);
d19 1
a19 1
    print "eat: $x\n" if(($x % 100) == 0);
@

