head	1.15;
access;
symbols
	start:1.1.1.1 vendor:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2004.06.08.12.31.35;	author numberone;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.08.10.28.12;	author numberone;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.04.12.53.31;	author tuco80;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.21.08.15.23;	author numberone;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.10.14.40.04;	author numberone;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.29.08.21.24;	author numberone;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.12.09.29.03;	author numberone;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.11.06.53.57;	author numberone;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.08.17.55.32;	author numberone;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.03.13.16.13;	author numberone;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.12.23.29.10;	author numberone;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.05.15.39.46;	author numberone;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.13.09.48.23;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.26.07.52.42;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.01.34.04;	author michald;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.24.01.34.04;	author michald;	state Exp;
branches;
next	;


desc
@@


1.15
log
@
Both syntax is valid

./task.pl path scheme
./task.pl path/scheme
@
text
@#!/usr/bin/perl -w
# $Id: task.pl,v 1.14 2004/05/08 10:28:12 numberone Exp $

use lib '../lib';
use libBee;

use XML::Simple;
use Data::Dumper;
use File::Basename;

unless(@@ARGV) {
	print STDERR "usage: $0 path/task.scheme\n";
	exit 1;
}

my $taskfile = $ARGV[0];
$taskfile .= "/".$ARGV[1] if($ARGV[1]);

my($taskname,$BASE) = fileparse($taskfile,".scheme",".xml");

print "executing task $taskname\n";

my $task = XMLin($taskfile,
			 forcearray=>[qw/otec dad input output link bee arg/]);

#print Dumper($task);
#__END__

my $job = new libBee;
my %otec; # otec list
my %bee;  # bee list
my $id = 0;
my @@result;

foreach my $otec_hash (@@{$task->{dad}},@@{$task->{otec}}) {
	my $otec = $otec{"__".(++$id)} = $job->otec($otec_hash) or die;
	print "otec `__$id' ".$otec->{host}.":".$otec->{port}." connected\n";

	foreach my $name (keys %{$otec_hash->{bee}}) {
		my $bee = $otec_hash->{bee}->{$name};

		# read content of script - we will send whole scriptfile to dad
		my $scriptcode = "";
		open(SCRIPT,"$BASE/".$bee->{script}) or die $bee->{script}.": $!\n";
		$scriptcode .= $_ while(<SCRIPT>);
		close(SCRIPT);

		die "`$name': bee names must be unique" if(exists $bee{$name});
		$bee{$name} = $otec->bee($name,$scriptcode);

		for(my $i=0;$i<@@output;$i++) {
			push @@result,{bee=>$bee{$name},num=>$i+1}
					if($output[$i] eq 'scalar');
		}

		print "bee ".$bee{$name}->{id}." `$name' created\n";
		foreach my $input (@@{$bee->{input}}) {
			my $num = $input->{input} or die;
			print "input ".$bee{$name}->{name}."/$num (".$input->{url}.")\n";
			$bee{$name}->input($num,(%$input));
		}

		foreach my $output (@@{$bee->{output}}) {
			my $num = $output->{output} or die;
			print "output ".$bee{$name}->{name}."/$num (".$output->{url}.")\n";
			$bee{$name}->output($num,(%$output));
		}

	}
}

my @@links;
foreach my $link (@@{$task->{link}}) {
	my($out,$outnum) = ($bee{$link->{src}->{bee}}, $link->{src}->{output});
	my($in, $innum)  = ($bee{$link->{dest}->{bee}},$link->{dest}->{input});
	push @@links,[$in,$innum,$out,$outnum];
}

# special <links>
#         bee/1 bee/2
#         bee/3 bee/4
#         </links> 
# tag handling
foreach (split(/\n/,$task->{links} ? $task->{links} : "")) {
	my($bee2,$out,$bee1,$in) = /^\s*([^\/]+)\/(\d+)\s+([^\/]+)\/(\d+)\s*$/;
	next unless $out;
	push @@links,[$bee{$bee1},$in,$bee{$bee2},$out];
}

foreach my $link (@@links) {
	my($in,$innum,$out,$outnum) = @@$link;
	$job->link($out,$outnum,$in,$innum);
	print $out->{name}."/$outnum -> ".$in->{name}."/$innum linked\n";
}


foreach my $bee (values %bee) {
	$bee->letfly();
	print "\`".$bee->{name}."\' ";
}
print "launched\n";

my $time = time;

my @@flying = keys %bee;

my $fatal = 0;
my $exit = 0;
my $msg = 1;

do {
	print "waiting... (".join(" ",@@flying).") alive\n";
	sleep 1 unless $msg; # speedup

	for(my $i=0;$i<@@flying;$i++) {
		my $bee = $bee{$flying[$i]};
		$msg = $bee->{otec}->message($bee,'landed');
		if($msg) {
			my $n = $msg->{status};
			if($n) { 
				my $os = int($n%256);
				 $exit = int($n/256);
				$fatal = $bee->{name}; 

				printf "bee \'$fatal\' died (".
					   ($os ? "$exit\:$os" : "$exit").")\n";
			} else {
				print "\`".$bee->{name}."\' landed\n";
			}
			splice @@flying,$i,1;
			last;
		}
	}
} while(@@flying and not $fatal);

if($fatal) {
	print "fatal error occured in bee \'$fatal\'\n";
	exit($exit); # first died bee status, or 0
}

print "benchmark: ".(time-$time)." secs\n";

print "results:\n" if(@@result);

foreach my $bee (values %bee) {
	while(my $display = $bee->{otec}->message($bee,'display')) {
		print "display ",$display->{line}."\n";
	}
}

foreach(@@result) {
	print $_->{bee}->{name}."/".$_->{num}." = ".
		  $_->{bee}->output($_->{num},url=>'scalar://')."\n";
}

#$_->close() foreach(values %otec);

print "task $taskfile successfully finished\n\n";


@


1.14
log
@
elegant client speedup -- do not sleep if there was message last cycle
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.13 2004/05/04 12:53:31 tuco80 Exp $
d9 1
d11 2
a12 3

if($#ARGV != 1) {
	print STDERR "usage: $0 <base-dir> <task-xml>\n";
d16 6
a21 3
my $BASE = $ARGV[0];
my $taskfile = "$BASE/$ARGV[1]";
print "executing task $taskfile\n";
d136 5
d158 1
a158 4
print $fatal ? "fatal error occured in bee \'$fatal\'\n" :
			   "task $taskfile successfully finished\n";

exit($exit); # first died bee status, or 0
@


1.13
log
@Small sintax problem
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.12 2004/04/21 08:15:23 numberone Exp $
d82 1
a82 1
	my($bee2,$out,$bee1,$in) = /([^\/]+)\/(\d+)\s+([^\/]+)\/(\d+)/;
d106 1
d110 1
a110 1
	sleep 1;
d114 1
a114 1
		my $msg = $bee->{otec}->message($bee,'landed');
@


1.12
log
@
bee exit status code propagation

task.pl returns 0 on success, or error code of first died bee
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.11 2003/11/10 14:40:04 numberone Exp $
a53 1

d104 2
a105 1
my $fatal,$exit = 0;
@


1.11
log
@ok, once again, use lib 'sarfy' removed
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.10 2003/10/29 08:21:24 numberone Exp $
d105 2
d113 13
a125 2
		if($bee->{otec}->message($bee,'landed')) {
			print "\`".$bee->{name}."\' landed\n";
d130 1
a130 1
} while(@@flying);
d149 2
a150 1
print "task $taskfile successfully finished\n";
d152 1
@


1.10
log
@<links> feature
@
text
@d2 1
a2 3
# $Id: task.pl,v 1.9 2003/09/12 09:29:03 numberone Exp $

use lib '/home/sarfy/perl';
@


1.9
log
@otec->dad, cat.scheme -- user@@pass test
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.8 2003/08/11 06:53:57 numberone Exp $
d79 6
a84 1
foreach (split(/\n/,$task->{links})) {
@


1.8
log
@merging old version to cvs
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.7 2003/07/08 17:55:32 numberone Exp $
d23 1
a23 1
			 forcearray=>[qw/otec input output link bee arg/]);
d34 1
a34 1
foreach my $otec_hash (@@{$task->{otec}}) {
@


1.7
log
@send/recv, in C, optimized, LEN_ code, small integers
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.6 2003/06/03 13:16:13 numberone Exp $
a47 1
		print "creating bee:\n";
d72 1
a72 1

d76 8
a83 1
	die unless($in and $out);
d85 2
d103 1
a103 1
	print "waiting... (".int(@@flying)." alive)\n";
@


1.6
log
@0.9.1 -- version merge
@
text
@d2 3
a4 1
# $Id: task.pl,v 1.5 2003/03/12 23:29:10 numberone Exp $
@


1.5
log
@demo - new xml schema
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.4 2003/02/05 15:39:46 numberone Exp $
d88 1
d106 1
@


1.4
log
@SSL to INET - for testing...
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.3 2002/11/13 09:48:23 numberone Exp $
d39 5
a43 21
		my $scriptfile = "$BASE/".$bee->{script};
		my $script = XMLin($scriptfile,
				 forcearray=>[qw/input output field/]);

		my $code_p = undef;
		if(exists $script->{code}->{content}) {
			$code_p = \$script->{code}->{content};
		} else {
			die unless exists($script->{code}->{include});
			my $codefile = "$BASE/".$script->{code}->{include};
	
			my $code = '';
			open(CODE,$codefile) or die;
			 $code .= $_ while(<CODE>);
			close(CODE);

			$code_p = \$code;
		}

		my @@input  = map { $_->{type} } @@{$script->{input}};
		my @@output = map { $_->{type} } @@{$script->{output}};
d47 1
a47 1
		$bee{$name} = $otec->bee($name,\@@input,\@@output,$code_p);
a56 1
#			my $bee = $bee{$input->{bee}} or die;
a62 1
#			my $bee = $bee{$output->{bee}} or die;
@


1.3
log
@modified format of task xml definition - 'id' tags removed
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.2 2002/09/26 07:52:42 numberone Exp $
d21 1
a21 1
			 forcearray=>[qw/otec link bee arg/]);
d25 1
d62 1
@


1.2
log
@version merging with my cvs
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.1.1.1 2002/09/24 01:34:04 michald Exp $
d21 1
a21 1
			 forcearray=>[qw/otec bee name link input output arg/]);
d23 2
d27 2
d31 52
a82 33
foreach my $id (keys %{$task->{otec}}) {
	$otec{$id} = $job->otec($task->{otec}->{$id}) or die;
	print "otec `$id' ".$otec{$id}->{host}.
					":".$otec{$id}->{port}." connected\n";
}

foreach my $name (keys %{$task->{bee}}) {
	my $bee = $task->{bee}->{$name};
	die if(not $bee->{otec} or not $otec{$bee->{otec}});

	my $scriptfile = "$BASE/".$bee->{script};
	my $script = XMLin($scriptfile,
			 forcearray=>[qw/input output field/]);

	my $code_p = undef;
	if(exists $script->{code}->{content}) {
		$code_p = \$script->{code}->{content};
	} else {
		die unless exists($script->{code}->{include});
		my $codefile = "$BASE/".$script->{code}->{include};

		my $code = '';
		open(CODE,$codefile) or die;
		 $code .= $_ while(<CODE>);
		close(CODE);

		$code_p = \$code;
	}

	my @@input  = map { $_->{type} } @@{$script->{input}};
	my @@output = map { $_->{type} } @@{$script->{output}};

	$bee{$name} = $otec{$bee->{otec}}->bee($name,\@@input,\@@output,$code_p);
a83 3
	for(my $i=0;$i<@@output;$i++) {
		push @@result,{bee=>$bee{$name},num=>$i+1}
				if($output[$i] eq 'scalar');
a84 2

	print "bee ".$bee{$name}->{id}." `$name' created\n";
a86 14

foreach my $input (@@{$task->{input}}) {
	my $bee = $bee{$input->{bee}} or die;
	my $num = $input->{input} or die;
	print "input ".$bee->{name}."/$num (".$input->{url}.")\n";
	$bee->input($num,(%$input));
}

foreach my $output (@@{$task->{output}}) {
	my $bee = $bee{$output->{bee}} or die;
	my $num = $output->{output} or die;
	print "output ".$bee->{name}."/$num (".$output->{url}.")\n";
	$bee->output($num,(%$output));
}
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
# $Id: task.pl,v 1.5 2002/08/26 20:06:17 martin Exp $
d134 1
@


1.1.1.1
log
@Initial public release of BEE Project.
@
text
@@
