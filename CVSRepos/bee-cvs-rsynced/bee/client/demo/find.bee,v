head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2004.06.08.15.12.37;	author numberone;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.06.15.23.53;	author numberone;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.06.12.04.20;	author numberone;	state Exp;
branches;
next	;


desc
@@


1.3
log
@
Prepare API

every bee must call ->prepare() before ->put()/->fetch()

or they can call ->prepare_sql("SELECT/INSERT ...")

->put() is identical to new ->execute()
@
text
@<?xml version="1.0" encoding="ISO-8859-2"?>
<script lang="perl" name='find'>
<description>
cte z prvniho vstupu [login,uid,gcos,shell] a jestlize je
uid vetsi nez obsah druheho scalar vstupu $from, vyhleda
v tabulce urcene tretim %dbi vstupem zda shell daneho
uzivatele je znam, tj. je v tabulce %dbi uvedeno jeho plne
jmeno. jestli ne, posle [uid,shell] na prvni vystup @@invalid,
je-li znam, posle jeho gcos a nazev shellu na druhy 
vystup @@who.
</description>

<input name="user" type='stream' arity='4' />
<input name="from" type='scalar' />
<input name="dbi"  type='dbi' fields="db table bin name"/>

<output name="invalid" type='stream' fields='uid shell' />
<output name="who"     type='stream' fileds='gcos shell' />

<code>
<![CDATA[

$user->prepare();
$who->prepare();
$invalid->prepare();

my($db,$table,$bin,$name) = @@$dbi;

while(my @@entry = $user->fetch) {
	my($login,$uid,$gcos,$shell) = @@entry;

	next if($uid < $from);

	# lookup in $shellname of $shell in $db
	my $shellname = $db->selectrow_array(
		"SELECT $name FROM $table WHERE $bin=?",undef,$shell);

	if(defined $shellname) {
		$who->put($gcos ? $gcos : $login,$shellname);
	} else {
		$invalid->put($uid,$shell);
	}
}

]]>
</code>

</script>

@


1.2
log
@debug prints removed
@
text
@d23 3
@


1.1
log
@renaming .xml to .scheme and .bee
@
text
@d21 2
a22 1
use Data::Dumper;
d29 1
a29 4
#	print "find: $login\n";
	print Dumper("find: ",@@entry);

	next if($uid &lt; $from);
d42 1
@

