head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2008.05.17.15.40.41;	author fsaz;	state dead;
branches;
next	1.1;

1.1
date	2005.11.28.15.39.46;	author fsaz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@borrando viejos
@
text
@/*
 * Created on 14-mar-2005
 *
 * ScrollReports.java
 *
 */
package es.aeat.eett.infoRubik.reports;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.ResourceBundle;

import javax.swing.Action;
import javax.swing.JScrollPane;
import javax.swing.JTree;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.TreePath;

import org.apache.log4j.Logger;



/**
 * Esta clase proporciona un JScrollPane con el arbol de Reports
 *
 * @@author f00992
 */
public class ScrollReports extends JScrollPane {
    private static final ResourceBundle localizationResources =
        ResourceBundle.getBundle("es.aeat.eett.infoRubik.reports.locale.LocalizationBundle");
	private PopupReports popup;
	private JTree treeReports=null;


	/**
	 * @@throws Exception
	 */
	public ScrollReports() throws Exception {
		popup=new PopupReports();
		iniComponents();
	}
	private void iniComponents() throws Exception{
        treeReports= new JTree(Reports.loadReports()){
        	public boolean isPathEditable(TreePath path) {
        		if( path.getLastPathComponent() instanceof ReportMutableTreeNode){
        			ReportMutableTreeNode rmtn=(ReportMutableTreeNode) path.getLastPathComponent();
        			return !rmtn.isRoot() && rmtn.isEditable();
        		}
				return false;
        	}
        };
        TreeCellRenderImpl tcr=new TreeCellRenderImpl();
        treeReports.setCellRenderer(tcr);
        treeReports.addMouseListener(new PopupTrigger());
        //treeReports.setToggleClickCount(0);
        ReportTreeCellEditor rtce= new ReportTreeCellEditor(treeReports, tcr);
        treeReports.setCellEditor(rtce);
        treeReports.setEditable(true);
        treeReports.getModel().addTreeModelListener(new ReportTreeModelListener());
        //treeReports.addTreeSelectionListener()
		add(popup);
        setViewportView(treeReports);

	}
	
	/**
	 * @@return Returns the treeReports.
	 */
	public JTree getTreeReports() {
		return treeReports;
	}
    /**
     * @@return Returns the popup.
     */
    PopupReports getPopup() {
        return popup;
    }

}// Fin class ScrollReports
/**
 * Esta clase es la encargada de mostrar el PopupMenu del arbol
 * cuando el usuario cliquea en el boton derecho del raton.
 *
 * @@author f00992
 */
class PopupTrigger extends MouseAdapter {
    private static final ResourceBundle localizationResources =
        ResourceBundle.getBundle("es.aeat.eett.infoRubik.reports.locale.LocalizationBundle");
	private static final String IMPORT=localizationResources.getString("Import");
	private static final String NEW_REPORT=localizationResources.getString("NewReport");
	private static final String NEW_RAMA=localizationResources.getString("NewRama");
	private static final String NEW_LEAF=localizationResources.getString("NewLeaf");
	private static final String RENAME_NODE=localizationResources.getString("RenameNode");
	private static final String REMOVE=localizationResources.getString("Remove");
	private static final String SAVE_REPORT=localizationResources.getString("SaveReport");
	private static final String GENERATE=localizationResources.getString("generate");


	/**
	 * Crea una nueva instancia de la clase.
	 */
	PopupTrigger() {
	}
	public void mouseReleased(MouseEvent e){//win
        maybeShowPopup(e);
	}
    public void mousePressed(MouseEvent e) {//nix
        maybeShowPopup(e);
    }
    private void maybeShowPopup(MouseEvent e) {
        if(e.getSource() instanceof JTree){
            ScrollReports scroll=(ScrollReports) e.getComponent().getParent().getParent();
            if (e.isPopupTrigger() ) {
    			JTree tree=(JTree)e.getSource();
    			int x = e.getX();
    			int y = e.getY();
    			int row = tree.getRowForLocation(x, y);
    			TreePath  path = tree.getPathForRow(row);
    			if (path != null) {
    			    tree.setSelectionPath(path);
    			    configPopup(scroll.getPopup(), path);
                    scroll.getPopup().show( e.getComponent(),e.getX(), e.getY());
    			}
            }
        }
    }
    private void configPopup(PopupReports popup, TreePath  path){
    	ReportMutableTreeNode n=(ReportMutableTreeNode) path.getLastPathComponent();
    	if(n.isRoot()){
        	Object[] keys=popup.getActionMap().keys();
        	for(int i=0; i<keys.length; i++){
        		if(!NEW_REPORT.equals(keys[i])){
	        		Action a=popup.getActionMap().get(keys[i]);
	        		a.setEnabled(false);
        		}
        	}
    	}else{
	    	ReportMutableTreeNode nFiexedJobs=n.getJobsRootNode();
	    	boolean enabled=false;
	    	Action a=popup.getActionMap().get(NEW_RAMA);
	    	if(!n.isNodeAncestor(nFiexedJobs) ){
	    		if(n.isReportRootNode() ){
	    			enabled=n.getChildCount()<2;
	    		}else if (!n.isReportLeaf()){
	    			enabled=true;
	    		}
	    	}
	    	a.setEnabled(enabled);

	    	enabled=false;
	    	a=popup.getActionMap().get(NEW_LEAF);
	    	if(!n.isNodeAncestor(nFiexedJobs)&& n.getLevel() >1
	    			&& !n.isReportLeaf()){
	    		enabled=true;
	    	}
	    	a.setEnabled(enabled);

	    	a=popup.getActionMap().get(RENAME_NODE);
	    	a.setEnabled(!n.equals(nFiexedJobs));

	    	a=popup.getActionMap().get(GENERATE);
        	a.setEnabled(true);

	    	/*
	    	a=popup.getActionMap().get(SAVE_REPORT);
        	a.setEnabled(true);
        	*/
	    	a=popup.getActionMap().get(IMPORT);
	    	if(a!=null){
		    	a.setEnabled(!n.equals(nFiexedJobs));
		    	a.setEnabled(!n.isReportLeaf());
	    	}
			Object[] keys=popup.getActionMap().keys();
			/*
        	for(int i=0; i<keys.length; i++){
        		a=popup.getActionMap().get(keys[i]);
        		if(a instanceof ActionCreateIndex){
        			a.setEnabled(true);
        		}
        	}
        	*/

    	}
    	Action a=popup.getActionMap().get(REMOVE);
    	a.setEnabled(n.getLevel()>1 && !n.equals(n.getJobsRootNode()));

    }
    private boolean nodeContainsLeaf(ReportMutableTreeNode nParent){
    	if(nParent.isLeaf())
    		return !nParent.isEmpty();
    	for(int i=0; i<nParent.getChildCount(); i++){
    		ReportMutableTreeNode n=(ReportMutableTreeNode) nParent.getChildAt(i);
    		if(n.isLeaf() && !n.isEmpty()){
    			return true;
    		}
    	}
    	return false;
    }
}// Fin class MouseTrigger
/**
 * Esta clase escucha los cambios el arbol de Reports y cuando
 * este cambia salva el Report.<br>
 *
 * Si escucha 'treeStructureChanged' Lanza UnsupportedOperationException.
 *
 * @@author f00992
 */
class ReportTreeModelListener implements TreeModelListener{
	private Logger logger = Logger.getLogger(ReportTreeModelListener.class);

    public void treeNodesChanged(TreeModelEvent e) {
    	saveReportChanged(e);
    }
    public void treeNodesInserted(TreeModelEvent e) {
    	saveReportChanged(e);
    }
    public void treeNodesRemoved(TreeModelEvent e) {
    	saveReportRemoved(e);
    }
    public void treeStructureChanged(TreeModelEvent e) {
        throw new UnsupportedOperationException();
    }
    private void saveReportRemoved(TreeModelEvent e){
    	TreePath path=e.getTreePath();
    	ReportMutableTreeNode rn= (ReportMutableTreeNode) path.getLastPathComponent();
    	if(rn.getLevel()<1)
    		throw new UnsupportedOperationException();
        try {
			((Report)rn.getReportRootNode().getUserObject()).save();
		} catch (IOException e1) {
			logger.error(e1);
		}
    }
    private void saveReportChanged(TreeModelEvent e){
        Object[] os=e.getChildren();
        if(os!=null){
	        for(int i=0;i<os.length; i++){
	            if(os[i] instanceof ReportMutableTreeNode){
	                ReportMutableTreeNode rn= (ReportMutableTreeNode) os[i];
	                try {
						((Report)rn.getReportRootNode().getUserObject()).save();
					} catch (IOException e1) {
						logger.error(e1);
					}
	            }
	        }
        }else{
			throw new UnsupportedOperationException();
        }
    }
}// Fin class ReportTreeModelListener
@


1.1
log
@*** empty log message ***
@
text
@@

