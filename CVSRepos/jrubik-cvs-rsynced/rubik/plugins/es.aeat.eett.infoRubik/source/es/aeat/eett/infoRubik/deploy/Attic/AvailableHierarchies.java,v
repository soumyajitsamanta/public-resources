head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2008.05.17.15.37.10;	author fsaz;	state dead;
branches;
next	1.1;

1.1
date	2005.11.28.14.43.28;	author fsaz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@borrando
@
text
@/*
 * Created on 15-mar-2005
 *
 * AvailableHierarchies.java
 *
 */
package es.aeat.eett.infoRubik.deploy;


import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;

import org.java.plugin.PluginManager;
import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;

import swingUtil.Tamemasa.tree.CheckNode;

import com.tonbeller.jpivot.olap.model.Axis;
import com.tonbeller.jpivot.olap.model.Dimension;
import com.tonbeller.jpivot.olap.model.Hierarchy;
import com.tonbeller.jpivot.olap.model.Level;
import com.tonbeller.jpivot.olap.model.Member;
import com.tonbeller.jpivot.olap.model.OlapException;
import com.tonbeller.jpivot.olap.model.OlapModel;
import com.tonbeller.jpivot.olap.navi.ChangeSlicer;
import com.tonbeller.jpivot.olap.navi.MemberTree;
import com.tonbeller.jpivot.olap.query.MDXLevel;

import es.aeat.eett.infoRubik.JobFactoryInfo;
import es.aeat.eett.infoRubik.jobs.job_core.Job;
import es.aeat.eett.infoRubik.jobs.job_core.JobFactory;
import es.aeat.eett.rubik.core.RubikPlugin;
import es.aeat.eett.rubik.core.cell.RubikCell;
import es.aeat.eett.rubik.core.cell.RubikCellImpl;
import es.aeat.eett.rubik.core.util.JDomUtil;

/**
 * @@author f00992
 */
public class AvailableHierarchies {
    private static final ResourceBundle localizationResources =
        ResourceBundle.getBundle("es.aeat.eett.infoRubik.deploy.locale.LocalizationBundle");
    private static final String DISPONIBLES=localizationResources.getString("Disponibles");
    static final String FALSE_MEMBER_TOTAL=localizationResources.getString("falseMemberTotal");
    private static OlapModel olapModel=null;


	public AvailableHierarchies() throws Exception {
		if(olapModel==null){
	        PluginManager pm = PluginManager.lookup(AvailableHierarchies.class);
	        RubikPlugin rubikPlugin = ((RubikPlugin) pm.getPlugin(RubikPlugin
	        		.PLUGIN_ID));
	        olapModel=rubikPlugin.getOlapModel();			
		}
	}
	private List getListUsedHierarchys(List listNamesJobs, File folderJobs) throws Exception{		
		List list=new ArrayList();
		if(listNamesJobs!=null && folderJobs!=null){
			for(int k=0; k<listNamesJobs.size(); k++){
				String name =(String) listNamesJobs.get(k);
				File fJob =new File(folderJobs, name);
				Job job=null;
				Document doc=new JDomUtil().JDomChk(fJob,Job.KEY_JOB);
				Element eJob=doc.getRootElement();
				if(eJob!=null && eJob.getContentSize()>0){
					Attribute aExtensionID=eJob.getAttribute(Job.KEY_EXTENSION_ID);
					String extensionID=aExtensionID.getValue();
					JobFactory jobFactory=JobFactoryInfo.getById(extensionID)
						.getJobFactory();
					job =jobFactory.createJob(fJob);
				}
				if(job==null){
					continue;
				}
				job.run();
				Dimension[] dimensions=olapModel.getDimensions();
				for(int i=0; i<dimensions.length;i++){
					Hierarchy[] hierarchys=dimensions[i].getHierarchies();
					for(int j=0; j<hierarchys.length; j++){
						if(getIndexAxis(hierarchys[j])!=-1
						&& !list.contains(hierarchys[j].getLabel())){
							list.add(hierarchys[j].getLabel());
						}
					}				
				}
			}
		}
		return list;
	}
	CheckNode getTreeDisponibles(List listNamesJobs, File folderJobs) throws Exception{
		List listUsed=getListUsedHierarchys(listNamesJobs, folderJobs);
	    CheckNode nRoot= new CheckNode(DISPONIBLES, true);
		Dimension[] dimensions=olapModel.getDimensions();
		for(int i=0; i<dimensions.length;i++){
			Hierarchy[] hierarchys=dimensions[i].getHierarchies();
			for(int j=0; j<hierarchys.length; j++){
				RubikCell c=new RubikCellImpl(hierarchys[j].getLabel(), hierarchys[j]);
				CheckNode nodo= new CheckNode(c, true);
				loadTreeHierarchy(nodo);
				boolean isAllHierarchy=false;
				if(getIndexAxis(hierarchys[j])==-1 
					&&	!listUsed.contains(hierarchys[j].getLabel())){
				    CheckNode nHierarchy= new CheckNode(c, true);
					nRoot.add(nHierarchy);
					Level[] levels=hierarchys[j].getLevels();
					for(int l=0; l<levels.length; l++){
						MDXLevel mdxLevel=(MDXLevel) levels[l];
						if(mdxLevel.isAll()){
						    isAllHierarchy=true;
						}else{
						    c= new RubikCellImpl(levels[l].getLabel(), levels[l]);
						    CheckNode nLevel=new CheckNode(c, true);
						    loadTreeLevel(nLevel, nodo);
						    if(isAllHierarchy && canAddFalseTotal(nLevel)){
						        RubikCell cFalseTotal= new RubikCellImpl(FALSE_MEMBER_TOTAL);
						        CheckNode  nFalseTotal=new CheckNode(cFalseTotal, true);
						        nLevel.insert(nFalseTotal,0);
						    }
						    nHierarchy.add(nLevel);
						}
					}
				}
				nodo.removeAllChildren();
			}
		}
		return nRoot;
	}
	private boolean canAddFalseTotal( CheckNode nLevel){
	    boolean canAddFalseTotal=true;
	    for(int i=0; i<nLevel.getChildCount(); i++){
	        RubikCell c=(RubikCell) ((CheckNode)nLevel.getChildAt(i)).getUserObject();
	        if(FALSE_MEMBER_TOTAL.equals(c.getDisplayable().getLabel()))
	            return false;
	    }
	    return canAddFalseTotal;
	}
	void loadTreeLevel( CheckNode nParent, CheckNode nHierarchy ){
	    RubikCell c=(RubikCell) nParent.getUserObject();
	    Level level=null;
	    if(c.getDisplayable() instanceof Level){
	        level=(Level) c.getDisplayable();
	    }else{
	        Member m=(Member)c.getDisplayable();
	        level=m.getLevel();
	    }
	    for(int i=0;  i<nHierarchy.getChildCount(); i++){
	        CheckNode nHierarchyHijo= (CheckNode) nHierarchy.getChildAt(i);
	        RubikCell chh= (RubikCell) nHierarchyHijo.getUserObject();
	        if(chh.getDisplayable() instanceof Member ){
	            Member m=(Member) chh.getDisplayable();
	            CheckNode nHijo=null;
	            if(level.equals(m.getLevel())){
	                nHijo=new CheckNode(chh, true);
	                nParent.add(nHijo);
	            }
	            nHijo=(nHijo!=null)? nHijo:nParent;
	            loadTreeLevel(nHijo, nHierarchyHijo);
	        }
	    }
	}

	/**
	 * Carga  CheckNode raiz de Hierarchy
	 * @@param nParent
	 */
	void loadTreeHierarchy( CheckNode nParent){
	    RubikCell c=(RubikCell) nParent.getUserObject();
	    Hierarchy hierarchy=(Hierarchy) c.getDisplayable();
		MemberTree mmt=(MemberTree)olapModel.getExtension(MemberTree.ID);
		Dimension[] dimensions=olapModel.getDimensions();
		for(int i=0; i<dimensions.length;i++){
			Hierarchy[] hierarchys=dimensions[i]. getHierarchies();
			for (int j=0; j<hierarchys.length; j++){
				Member[] members=mmt.getRootMembers(hierarchys[j]);
				if(hierarchys[j].equals( hierarchy)){
					for(int k=0; k<members.length ; k++){
					    c= new RubikCellImpl(members[k].getLabel(), members[k]);
					    CheckNode nMember=new CheckNode(c, true);
						nParent.add(nMember);
						addNodesChildrens(mmt,members[k], nMember);
					}// Fin for
				}
			}
		}
	}
	/**
	 * @@param mmt
	 * @@param mParent
	 * @@param nodoParent
	 */
	private void addNodesChildrens(MemberTree mmt,Member mParent
			, CheckNode nodoParent){
		if (mmt.hasChildren(mParent)){
			Member[] mHijos =mmt.getChildren(mParent);
			for(int i=0; i<mHijos.length; i++){
			    RubikCell c= new RubikCellImpl(mHijos[i].getLabel(), mHijos[i]);
			    CheckNode nodoHijo = new CheckNode(c, true);
				nodoParent.add(nodoHijo);
				addNodesChildrens(mmt,mHijos[i],nodoHijo);
			}
		}
	}


	/**
	 * @@param hierarchy
	 * @@return El indice del eje en el que se encuentra la  hierarchy ( o alguno de sus miembros, caso del slicer,)
	 * 					-1, 0, 1, 2 (No esta en ninguno, col, row, slicer  ).
	 * @@throws OlapException
	 */
	private int getIndexAxis(Hierarchy hierarchy) throws OlapException{
		Axis[] axis;

		// Query Ejes
		axis = olapModel.getResult().getAxes();
		for (int i=0; i<axis.length; i++){
			Hierarchy[] hierarchys=axis[i]. getHierarchies();
			for(int j=0;j<hierarchys.length; j++){
				if (hierarchys[j].equals(hierarchy))
					return i;
			}
		}
		// Query slicer
		ChangeSlicer mcs=(ChangeSlicer)olapModel.getExtension(ChangeSlicer.ID);
		Member[] ms=mcs.getSlicer();
		for (int i=0; i<ms.length; i++){
			if (hierarchy.equals( ms[i].getLevel().getHierarchy()))
					return 2;
		}
		return -1;
	}

}
@


1.1
log
@*** empty log message ***
@
text
@@

