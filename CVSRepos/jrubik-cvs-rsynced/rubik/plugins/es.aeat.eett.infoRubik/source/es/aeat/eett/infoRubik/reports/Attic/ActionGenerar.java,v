head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2008.05.17.15.40.41;	author fsaz;	state dead;
branches;
next	1.1;

1.1
date	2005.11.28.15.39.46;	author fsaz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@borrando viejos
@
text
@/*
 * Created on 30-may-2005
 *
 * ActionGenerar.java
 */
package es.aeat.eett.infoRubik.reports;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.io.File;
import java.util.Enumeration;
import java.util.List;
import java.util.ResourceBundle;

import javax.swing.AbstractAction;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.tree.TreeNode;

import org.apache.log4j.Logger;
import org.java.plugin.PluginLifecycleException;
import org.java.plugin.PluginManager;
import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;

import es.aeat.eett.infoRubik.InfoRugikPlugin;
import es.aeat.eett.infoRubik.JobFactoryInfo;
import es.aeat.eett.infoRubik.deploy.Generator;
import es.aeat.eett.infoRubik.deploy.LeafIndex;
import es.aeat.eett.infoRubik.jobs.job_core.Job;
import es.aeat.eett.infoRubik.jobs.job_core.JobFactory;
import es.aeat.eett.infoRubik.layout.LeafReport;
import es.aeat.eett.rubik.core.util.JDomUtil;
import es.aeat.eett.workbench.core.PluginException;


/**
 * @@author f00992
 */
public class ActionGenerar extends AbstractAction {
    private static final ResourceBundle localizationResources =
        ResourceBundle.getBundle("es.aeat.eett.infoRubik.reports.locale.LocalizationBundle");
	private static final String GENERATE=localizationResources.getString("generate");
	private InfoRugikPlugin infoRugikPlugin;
	
	public ActionGenerar() {
		super(GENERATE);
	    try {
			PluginManager pm= PluginManager.lookup(ActionGenerar.class);
			infoRugikPlugin=(InfoRugikPlugin)pm
				.getPlugin(InfoRugikPlugin.PLUGIN_ID);
		} catch (PluginLifecycleException e) {
			infoRugikPlugin=null;
		}
	}
	/**
	 * @@see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
	 */
	public void actionPerformed(ActionEvent e) {
        javax.swing.JPopupMenu jp=(JPopupMenu)( (Component)e.getSource()).getParent();
        JTree tree=(JTree) jp.getInvoker();
        Object  lastPath =tree.getLastSelectedPathComponent();
		if (lastPath != null) {
	        ScrollReports scroll=(ScrollReports) tree.getParent().getParent();
		    ReportMutableTreeNode node=(ReportMutableTreeNode) lastPath;
		    try {
				   new ThreadGenera(node, infoRugikPlugin).start();                                 
			} catch (Exception e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}
	}
}// Fin class ActionGenerar

//class Genera implements Runnable{
class ThreadGenera extends Thread {
    private static final ResourceBundle localizationResources =
        ResourceBundle.getBundle("es.aeat.eett.infoRubik.reports.locale.LocalizationBundle");
	private static final String GENERATE=localizationResources.getString("Generate");
	private static final String TOTALMEMORY=localizationResources.getString("TotalMemory");
	private static final String USEDMEMORY=localizationResources.getString("UsedMemory");
	private static final String LAPSEDTIME=localizationResources.getString("LapsedTime");
	private static final String ERROR=localizationResources.getString("Error");

	private static final Logger logger = Logger.getLogger(ThreadGenera.class);
	private ReportMutableTreeNode nParent=null;
	private Report report=null;
	private Component showInfo=null;
	private long tini;
	private Runtime runtime = Runtime.getRuntime();


	public ThreadGenera(ReportMutableTreeNode node
			, InfoRugikPlugin infoRugikPlugin) throws Exception {
	    ReportMutableTreeNode nReport=node.getReportRootNode();
	    report=(Report) nReport.getUserObject();
	    if(node==nReport || node.isFixecJob()){//Se genera todo el report
	    	nParent=nReport;
	    }else{//Solo se generan los nodos descendientes
	    	nParent=node;
	    }
	    if(infoRugikPlugin!=null){
	    	infoRugikPlugin.fireShowRight(ReportsListener.LOGPANE );
	    }
	    setPriority(Thread.MAX_PRIORITY);
	}
	public void run(){
		tini = System.currentTimeMillis();
		ReportMutableTreeNode node;
	    Enumeration enu=nParent.depthFirstEnumeration();
	    while(enu.hasMoreElements()){
	    	node=(ReportMutableTreeNode) enu.nextElement();
	    	if(node.isReportLeaf()&& !node.isFixecJob()){
	    		LeafReport leafReport=node.getLeafReport();
				//String msg=getTime()+getMemory()+GENERATE+getPathNode(node);
	    		String msg=GENERATE+getPathNode(node);
				logger.info(msg);
				genera(report, leafReport);
	    	}
	    }
	    logger.info("");
	    logger.info(getTime()+ getMemory());
	    logger.info("");
	}

	private void genera(Report report, LeafReport leafReport){
		List listJobs=leafReport.getJobsElements();
		for(int i=0; i<listJobs.size(); i++){
			try {
				Job job=getJob((Element) listJobs.get(i), report);
				job.run();
				Generator generador= new Generator(report.getOutDir());
				generador.generaFiles(leafReport,  job);
			} catch (Exception e) {
				logger.warn(ERROR+": ", e);
				return; //No seguimos generando el indice estara mal
			}
		}
		try {
			new LeafIndex(leafReport.getRootElement(),report.getOutDir())
				.createLeafIndex();
		} catch (Exception e) {
			logger.warn(ERROR+": ", e);
		}
	}
	private Job getJob(Element eJob, Report report) throws Exception{
		Attribute aNameFile=eJob.getAttribute(Job.KEY_JOB_NAME);
		if(aNameFile!=null)
			return getJob(aNameFile.getValue(), report);
		throw new PluginException("Attribute "+Job.KEY_JOB_NAME+" no found.");
	}
	private Job getJob(String fileJobName,  Report report) throws Exception{
		File fJob=new File(report.getJobsDir(), fileJobName);

		Document doc=new JDomUtil().JDomChk(fJob,Job.KEY_JOB);
		Element eJob=doc.getRootElement();
		if(eJob!=null && eJob.getContentSize()>0){
			Attribute aExtensionID=eJob.getAttribute(Job.KEY_EXTENSION_ID);
			String extensionID=aExtensionID.getValue();
			Attribute a=eJob.getAttribute(Job.KEY_CAPTION_PLUGIN);
			JobFactory jobFactory=JobFactoryInfo.getById(extensionID)
				.getJobFactory();
			return jobFactory.createJob(fJob);
			
		}else{ //No hay Job
			throw new PluginException("Job no found.");
		}
	}
	private String getPathNode(TreeNode node){
		String path=node.toString();
		while(node.getParent()!=null){
			node=node.getParent();
			path=node.toString()+"/"+path;
		}
		return path;
	}
	private String getMemory(){
        long total = runtime.totalMemory();
        long free  = runtime.freeMemory();
        long used  = (total - free) / (1024*1024);
        total /= (1024*1024);

        String memory=TOTALMEMORY+total+ USEDMEMORY+used+"M\n";

        return memory;
	}
	private String getTime(){
		long tsegundos =(System.currentTimeMillis()-tini)/1000;
		String time=LAPSEDTIME+tsegundos/60+":" + (tsegundos%60)+" m:s\n";
		return time;
	}

}@


1.1
log
@*** empty log message ***
@
text
@@

