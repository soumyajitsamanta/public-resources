head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2008.05.17.15.43.54;	author fsaz;	state dead;
branches;
next	1.1;

1.1
date	2005.11.28.14.02.37;	author fsaz;	state Exp;
branches;
next	;


desc
@@


1.2
log
@borrando viejos
@
text
@/******************************
This is an open source project (see definition at http://www.opensource.org/docs/definition_plain.html).
and is distributed under the GNU General Public License (see http://www.gnu.org/copyleft/gpl.html).
*******************************/
	//zoom and pan:  	alert("layer:" + layername + " fieldname:"+fieldname+" size:"+size);

var zparr=new Array();
var lastcurty;var lastcurtx;
var gwsize={x:0,y:0,w:0,h:0};
var gwvbox={x:0,y:0,w:0,h:0};
	//navigation
var pbProp={x:0,y:0,w:0,h:0};
var drag=false,pbOldX,pbOldY,pbDownX,pbDownY,pbMoveX,pbMoveY;
var cprec=4;
	//coordinate decimal display
	//legend
var LEGS, legDoc, legUse;
	//digitizer
var origX;var origY;var newX;var newY;var startX;var startY;var oldX;var oldY;
var pathadder=null; var pathadder2;
var startNew=false;
	//feature hilite
var oldobjfill; var oldobjstwd; var oldobj;var hiliteon=true;
	//toolbar
var oldcolor, pressedbutton;
var ToolBar;
/*****************************
* Static ZoomPan  					*
* to make keymap and legend stay at static position and size
******************************/
function initzp(e) {
	storeOldPos(svgdoc.getElementById('toolbar'));
	storeOldPos(svgdoc.getElementById("keyMap"));
	storeOldPos(svgdoc.getElementById("legend"));
	storeOldPos(svgdoc.getElementById("legendLayers"));
	storeOldPos(svgdoc.getElementById("legbutton"));
	storeOldPos(svgdoc.getElementById("geoWin"));
	storeOldPos(svgdoc.getElementById("windowcover"));
    var theRoot = svgDocument.documentElement;
    theRoot.addEventListener('SVGZoom',   doZoom, false);
    theRoot.addEventListener('SVGScroll', doScroll, false);
}
function storeOldPos(obj){
	var zpobj={obj:null,x:0,y:0,w:0,h:0};
	zpobj.obj=obj;
	zpobj.x=parseInt(obj.getAttribute("x"));
	zpobj.y=parseInt(obj.getAttribute("y"));
	zpobj.w=parseInt(obj.getAttribute("width"));
	zpobj.h=parseInt(obj.getAttribute("height"));
	zparr[zparr.length]=zpobj;
}
function SetStaticZP(evt){
	if (zparr.length==0) return;
   var theRoot = svgDocument.documentElement;

	var newtx = -(parseFloat(theRoot.currentTranslate.x / theRoot.currentScale));
	var newty = -(parseFloat(theRoot.currentTranslate.y / theRoot.currentScale));
	for (izp=0;izp<zparr.length;izp++){
		if (zparr[izp].obj.nodeName=='g'){
           	zparr[izp].obj.setAttribute("transform", "scale(" + (1.0 / theRoot.currentScale) + ")" );
		}else{
			zpnewx=parseFloat(newtx+zparr[izp].x/theRoot.currentScale);
			zpnewy=parseFloat(newty+zparr[izp].y/theRoot.currentScale);
			zpneww=parseFloat(zparr[izp].w/theRoot.currentScale);
			zpnewh=parseFloat(zparr[izp].h/theRoot.currentScale);
			setLayout(zparr[izp].obj,zpnewx,zpnewy,zpneww,zpnewh);
		}
	}
	setPanBox(newtx,newty,theRoot.currentScale,evt);
	var lgb = svgdoc.getElementById('legBack');
	var lgbstyle = lgb.getStyle()
	lgbstyle.setProperty('stroke-width',(1.0 / theRoot.currentScale));
	setDim();
}

/*****************************
* Arrange the svg layout	 *
******************************/
// For layout setting of mainmap, keymap and legend 
// only need one parameter : mainmap proportion of the screen width (0.0<mapwd<1.0)
// the rest is determined from this parameter
	function arrangeSVG(evt,mapwd){
		doc1=evt.getTarget().getOwnerDocument();
		tbht  = 30.0;
		var iwd = getInnerWidth();
		var iht = getInnerHeight()-tbht;
		keywd=parseFloat(1.0-mapwd);
		mapfac = parseFloat(mapwd*iwd/iht);
		keyht=keywd*iwd/(mapfac*iht);
		leght=1.0-keyht;
		wdref = keywd*iwd;
		setLayout(doc1.getElementById('toolbar'), 0, 0, iwd, tbht);
		setViewBox(doc1.getElementById('toolbar'), 0, 0, iwd, tbht);
		setLayout(doc1.getElementById('map'), 0, tbht, mapwd*iwd, iht);
		setViewBox(doc1.getElementById('map'), 0, 0, mapwd*iwd, iht);
		setLayout(doc1.getElementById('keyMap'), mapwd*iwd, tbht, keywd*iwd, keyht*iht);
		setViewBox(doc1.getElementById('keyMap'), 0, tbht, mapwd*iwd, iht);
		setLayout(doc1.getElementById('legend'), mapwd*iwd, keyht*iht+tbht, keywd*iwd, leght*iht);
		setLayout(doc1.getElementById('tester'), 0, 0, keywd*iwd, leght*iht);

		var lbwd  = parseInt(doc1.getElementById('legdown').getAttribute('width'));
		
		setLayout(doc1.getElementById('legdown'), wdref-lbwd-2, 2, lbwd, lbwd);
		setLayout(doc1.getElementById('legup'), wdref-(2*lbwd)-4, 2, lbwd, lbwd);

		gwsize.x=0;
		gwsize.y=tbht;
		gwsize.w=parseFloat(getInnerWidth());
		gwsize.h=parseFloat(getInnerHeight()-tbht);
		gwvbox.x=0.0;
		gwvbox.y=0.0;
		gwvbox.w=parseFloat(getInnerWidth());
		gwvbox.h=parseFloat(getInnerHeight()-tbht);
		setLayout(doc1.getElementById('geoWin'), gwsize.x, gwsize.y, gwsize.w, gwsize.h);
		setViewBox(doc1.getElementById('geoWin'), gwvbox.x, gwvbox.y, gwvbox.w, gwvbox.h);

		setLayout(doc1.getElementById('windowcover'),0, tbht, mapwd*iwd, iht);
	}
	function setLayout(svgnode,x,y,wd,ht){
		if(svgnode==null) return;
		if(x!=null) svgnode.setAttribute('x',x);
		if(y!=null) svgnode.setAttribute('y',y);
		if(wd!=null) svgnode.setAttribute('width',wd);
		if(ht!=null) svgnode.setAttribute('height',ht);
	}
	function setAtt(anelement,attname,attvalue){
		if(anelement==null) return;
		anelement.setAttribute(attname,attvalue);
	}
	function setViewBox(svgnode,x,y,wd,ht){
		var vbstr=x + ' ' + y + ' '+ wd + ' ' + ht;
		if(svgnode==null) return;
		svgnode.setAttribute('viewBox',vbstr);
	}


/*****************************
* PanBox Routines			 *
******************************/
// this panbox in keymap will reflect the current scale and translate of mainmap
// its also working with the standard asv context menu for zoom and pan
// also, dragging the panbox will change the current translate of the mainmap
// change current scale using buttons on the toolbar
function addPanBox(){
	var km = svgdoc.getElementById("keyMap");
	var kmvb=km.getAttribute("viewBox").split(" ");
//mod AR : to ensure pan rectangle covers whole keymap area while matching mainmap width-height ratio
	var newLayout=new adjustLayout(kmvb[0],kmvb[1],kmvb[2],kmvb[3],"map");
	pbProp.x=newLayout.x;	
	pbProp.y=newLayout.y;
	pbProp.w=newLayout.width;	pbProp.h=newLayout.height;
//end mod AR
	var rkbg = svgdoc.createElement("rect"); //background for keymap
	rkbg.setAttribute('id','keybackground');	rkbg.setAttribute('class','keymapback');
	maxwh=Math.max(pbProp.w,pbProp.h);
	setLayout(rkbg,pbProp.x-maxwh,pbProp.y-maxwh,3*maxwh,3*maxwh);
	km.insertBefore(rkbg,km.getFirstChild());

	var rpb = svgdoc.createElement("rect"); //panbox for keymap
	rpb.setAttribute('id','panBox');
	rpb.setAttribute('class','panner');
	setLayout(rpb,pbProp.x,pbProp.y,pbProp.w,pbProp.h)
	rpb.setAttribute('onmousedown','panBoxDown(evt)');
	km.appendChild(rpb);
	km.setAttribute('onmousemove','panBoxMove(evt)');
	km.setAttribute('onmouseup','window.setTimeout("panBoxUp()",10)');
	//km.setAttribute('onmouseout','window.setTimeout("panBoxUp()",10)');
	checkMarkers();initLegend();
}
function checkMarkers(){
	eldnode = svgdoc.getElementsByTagName('ExtendedLayerDescriptor').item(0);
	var nlay=eldnode.getElementsByTagName("NamedLayer")
	for (i=0;i<nlay.length;i++){
		var symbtype=nlay.item(i).getElementsByTagName("SymbolType").item(0).firstChild.nodeValue;
		if (symbtype=="marker") {
			drawMarkers(svgdoc,nlay.item(i).getAttribute("name"));
		}
	}
}
function drawMarkers(svgdoc,aName){
	fcnode = svgdoc.getElementsByTagName('featureCollection').item(0);
	fms=fcnode.getElementsByTagName(aName)
	var oldmarkg=svgdoc.getElementById("l"+aName)
	var ml=oldmarkg.getParentNode();
	var mg="<g id='l"+aName+"'>";
	for (j=0;j<fms.length;j++){
		var markx=fms.item(j).getElementsByTagName(aName+".XMin").item(0).firstChild.nodeValue;
		var marky=fms.item(j).getElementsByTagName(aName+".YMin").item(0).firstChild.nodeValue;
		var misize=0;	var mx = parseFloat(markx)-misize/2.0;	var my = parseFloat(marky)-misize/2.0;
		mg+="<use id='l" + aName + "f" + (j+1) + "' xlink:href='#marker'";
		mg+=" x='" + mx + "' y='" + my + "' width='" + misize + "' height='" + misize + "'/>"
	}
	mg+="</g>"
	var docfrag = pxml(mg);
	ml.insertBefore(docfrag.getFirstChild(),oldmarkg);
	ml.removeChild(oldmarkg);
}
function adjustLayout(vbX,vbY,vbW,vbH,referencedID){
	adjuster= findAdjuster(referencedID);	var pbscale=1.0;
	this.x=parseFloat(vbX);	this.y=parseFloat(vbY);
	unadjustx=this.x;
	unadjusty=this.y;
	if(adjuster>1.0){
		this.width=pbscale*parseFloat(vbW);
		this.height=pbscale*parseFloat(vbH)*adjuster;
		this.y=parseFloat(vbY)-pbscale*( 0.5*parseFloat(vbH)*parseFloat(1.0-1.0/adjuster) );
	}else{
		this.height=parseFloat(pbscale*vbH);
		this.width=pbscale*parseFloat(vbW)/adjuster;
		this.x=parseFloat(vbX)+pbscale*( 0.5*parseFloat(vbW)*parseFloat(1.0-1.0/adjuster) );
	}
	xShift=parseFloat(unadjustx-this.x);
	yShift=parseFloat(unadjusty-this.y);
//	alert("adjusting : "+"\n"+unadjustx+", "+unadjusty+"\n"+this.x+", "+this.y);
}

function findAdjuster(referencedID){
	var mpsvg = svgdoc.getElementById(referencedID);
	var mapbbw=parseFloat(mpsvg.getBBox().width)
	var mapbbh=parseFloat(mpsvg.getBBox().height)
	adjuster=( parseFloat(mpsvg.getAttribute("height"))*mapbbw ) / ( parseFloat(mpsvg.getAttribute("width"))*mapbbh )
	return adjuster
}

function toolbarFactor(tbarHeight){
	var rcs = svgdoc.rootElement.currentScale;
	var innH = getInnerHeight();
	var mmaph=parseFloat(svgdoc.getElementById("map").getAttribute('height'));
	var kmaph=parseFloat(svgdoc.getElementById("keyMap").getAttribute('height'));
	var fMT = (tbarHeight/innH);
	//var tbF  =parseFloat(tbarHeight*(kmaph/mmaph)/rcs);
	//var tbF  =parseFloat(tbarHeight*rcs);
	return fMT;
}

// MAJOR overhaul : AR ; sync the panbox with current zoom and pan operation (called by staticZP)
function setPanBox(curtx,curty,curscale,evt){
//	if ((!evt.type)||(evt.type=="")) return;
   var theRoot = svgdoc.documentElement;
	var mapsvg = svgdoc.getElementById('map');
	var mapw = parseFloat(mapsvg.getAttribute('width'));
	var maph = parseFloat(mapsvg.getAttribute('height'));
	var scl = 1.0/curscale
	var newtx = curtx;	var newty = curty;
	var adjuster=findAdjuster("map")
	adjuster > 1.0 ? mult=parseFloat(pbProp.w/mapw) :	mult=parseFloat(pbProp.h/maph);
	var tx=newtx*mult;	var ty=newty*mult;
	var pbx=svgdoc.getElementById("panBox")
	setLayout(pbx,parseFloat(pbProp.x+tx),parseFloat(pbProp.y+ty),parseFloat(pbProp.w*scl),parseFloat(pbProp.h*scl))
}

// panbox dragging 
function panBoxDown(evt){
	tid=evt.getTarget().getAttribute('id')
	if (tid!="panBox") return;
	evt.getTarget().setAttribute("onmousemove","");	evt.getTarget().setAttribute("onmouseup","");
	evt.getTarget().setAttribute("onmousedown","");
	drag=true;
	targ= evt.getTarget();	
	targ.setAttribute('class','pannerdown');
	pbDownX = evt.getClientX();	pbDownY = evt.getClientY();
	pbOldX=parseFloat(targ.getAttribute('x'));pbOldY=parseFloat(targ.getAttribute('y'));
}

// MAJOR overhaul : AR
function panBoxUp(){	
	if (!drag) return;
	var panb=svgdoc.getElementById("panBox");
	panb.setAttribute("onmousemove","");	panb.setAttribute("onmouseup","");
	panb.setAttribute("onmousedown","panBoxDown(evt)");
	panb.setAttribute('class','panner');
	mapv=svgdoc.getElementById("map");
	mapw=parseFloat(mapv.getAttribute('width'));
	maph=parseFloat(mapv.getAttribute('height'));
	//distX = pbMoveX-pbDownX;	distY = pbMoveY-pbDownY;
	pbdx=parseFloat(panb.getAttribute("x"))-pbProp.x;
	pbdy=parseFloat(panb.getAttribute("y"))-pbProp.y;
	var adjuster=findAdjuster("map")
	adjuster > 1.0 ? mult=parseFloat(pbProp.w/mapw) :	mult=parseFloat(pbProp.h/maph);
	newtx=pbdx/mult;	newty=pbdy/mult;
	theRoot = svgdoc.rootElement;
	theRoot.currentTranslate.x=parseFloat(-newtx*mcs);
	theRoot.currentTranslate.y=parseFloat(-newty*mcs);
	drag=false;
	getFeature();
}

function panBoxMove(evt){
	if (!drag) return;
	theRoot = svgdoc.rootElement;
	mcs = theRoot.currentScale;
	tid = evt.getTarget().getAttribute("id");
	var panb= svgdoc.getElementById("panBox");
	pbMoveX = evt.getClientX();	pbMoveY = evt.getClientY();
	var kmap= svgdoc.getElementById("keyMap");
	var tparw=parseFloat(kmap.getAttribute('width'));
	var tparh=parseFloat(kmap.getAttribute('height'));
	parvb = kmap.getAttribute('viewBox').split(" ");
	var distX = pbMoveX-pbDownX;	var distY = pbMoveY-pbDownY;
	pbNewX = pbOldX + parseFloat(distX*parseFloat(parvb[2])/(tparw*mcs) );
	pbNewY = pbOldY + parseFloat(distY*parseFloat(parvb[3])/(tparh*mcs) );
	panb.setAttribute('x',pbNewX);
	panb.setAttribute('y',pbNewY);
}

/*****************************
* 		LEGENDS			 	 *
******************************/
function initLegend(){
	LEGS = new legendList();
	legDoc=svgdoc.getElementById('tester');
	legUse=svgdoc.getElementById('masterUse');
	getLegParams();
}
// Still taking parameters from ELD and SLD.  Not yet explore the possibilities of XSD
function getLegParams(){
	str=""
	theELD=svgdoc.getElementsByTagName("ExtendedLayerDescriptor").item(0);
	theELDNL =theELD.getElementsByTagName("NamedLayer");
	theSLD=svgdoc.getElementsByTagName("StyledLayerDescriptor").item(0);
	theSLDNL =theSLD.getElementsByTagName("NamedLayer");
	for(i=0;i<theELDNL.length;i++){
		enlnod=theELDNL.item(i);
		snlnod=theSLDNL.item(i);				//note : theELDNL.length=theSLDNL.length
		theName=enlnod.getAttribute("name");
		theLT = getParam(enlnod,"LegendType","single symbol")
		theCF = getParam(enlnod,"ClassificationField","FeatureID")
		theCT = getParam(enlnod,"ClassificationType","quantile")
		theChrtT = getParam(enlnod,"ChartType","column")
		theCC = getParam(enlnod,"ClassesCount",0)
		theST = getParam(enlnod,"SymbolType","marker")
		theSS = getParam(enlnod,"SymbolSize",1)
		theLS = getParam(enlnod,"LabelSize",0)
		theLC = getParam(enlnod,"LabelColor","#000000")
		theSW = getParam(enlnod,"StrokeWidth",1)
		theFC = getParam(snlnod,"FillColor","#FFFFFF")
		theSC = getParam(snlnod,"StrokeColor","#000000")
		theCL = getParam(enlnod,"ColorList","")
		theML = getParam(enlnod,"MarkerList","")
		theLG = getParam(enlnod,"Language","es")
		makeLegend(theName,theLT,theCF,theCT,theCC,theST,theSS,theSW,theFC,theSC,theCL,theML,theLS,theLC,theChrtT,theLG);
	}	
	LEGS.arrange(legDoc);	//arrange legend layers
	makecbox(10);
	setDim();
}
function getParam(descNode,tagName,defaultValue){
	if (!descNode) return defaultValue;
	var theParam=null;	var paramNode=descNode.getElementsByTagName(tagName);
	if (paramNode.length==0) {
		theParam = defaultValue;
	}else{
		theParam = paramNode.item(0).firstChild.nodeValue;
		if (!isNaN(parseFloat(theParam))) theParam=parseFloat(theParam);
	}
	return theParam;
}
function sizeFactor(){
	var map = svgdoc.getElementById("map");
	mapvb = map.getAttribute("viewBox").split(" ");
	vbWd = parseFloat(mapvb[2]);
	mapWd = parseFloat(map.getAttribute('width'));
	screenWd = screen.width;
	return vbWd/screenWd;
}

function makeLegend(theName,theLT,theCF,theCT,theCC,theST,theSS,theSW,theFC,theSC,theCL,theML,theLS,theLC,theChrtT,theLG){
	//alert('theName:'+theName + ' theCF:' + theCF + ' theChrtT:'+theChrtT);
	
	theSS==0 ? rsize=theSW:rsize=theSS;
	var aLegend  = LEGS.append(new Legend('key_'+theName));
	aLegend.makeG(svgdoc,'legends');
	symbsize=12
	if (theST=="marker") symbsize=rsize;
	setMarkerSize(theName,theST,rsize*sizeFactor())
	aLegend.setType(theLT);
		if (aLegend.Type=='single symbol'){
			aLegend.SingleSymbol();
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}
		if (aLegend.Type=='unique value'){
			cfnodename=theName+"."+theCF;
			aLegend.Unique(cfnodename);
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}
		if ( aLegend.Type=='graduated color' ){
			cfnodename=theName+"."+theCF;
			if (theCT=="quantile") aLegend.Quantile(cfnodename,theCC);
			if (theCT=="equal interval") aLegend.Interval(cfnodename,theCC);
			if ( (theCT!="quantile")&&(theCT!="equal interval")){
				alert("sorry, the "+theCT+" classification not supported yet."+"\r"+"switching to quantile");
				aLegend.Quantile(cfnodename,theCC);
			}
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}
		if (aLegend.Type=='graduated symbol'){
			aLegend.GradSymbol();
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}
		if (aLegend.Type=='chart symbol'){
			var cfnames=theCF.split(",");
			for(var fn=0;fn<cfnames.length;fn++){
				cfnames[fn]=theName+"."+cfnames[fn];
			}
			aLegend.setType("chart symbol");
			aLegend.Chart(cfnames,theChrtT,theSS);
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}
		if (aLegend.Type=='dot symbol'){
			alert("sorry, dot and chart not supported yet."+"\r"+"switching to single symbol");
			aLegend.setType("single symbol");
			aLegend.SingleSymbol();
			aLegend.makeSymbolList(theST,theName,theFC,theSC,symbsize,theSS,theSW);
		}

		clrList = theCL.split(" ");
		for(si=0;si<clrList.length-1;si++){
			//alert("theST: "+theST)
		  switch(theST){
		    case "marker":
				aLegend.Symbols[si].bgFill=clrList[si];
				aLegend.Symbols[si].bgStroke=clrList[si];
				//aLegend.Symbols[si].strokeWidth=theSW
		    case "line":
				aLegend.Symbols[si].bgStroke=clrList[si];
		    case "fill":
				aLegend.Symbols[si].bgFill=clrList[si];
		  }
		}
		aLegend.Update();
		aLegend.arrange();		//arrange symbols in a legend
		var thelabel = theName+' : '+theCF;
		if ( (theCF=='') || (theCF==null) ) thelabel = theName;
		aLegend.makeLabel(svgdoc,aLegend.Id,thelabel);
		applyToMap(theName,aLegend);
		if (theLS>0) setInitialLabel("l"+theName,theLS,theLC,theLG) 
}

function setInitialLabel(layerId,labelSize,labelColor,labelLanguage){
//alert("setInitialLabel: layerId:"+layerId+" labelSize:"+labelSize)

	var theLayer=svgdoc.getElementById(layerId);
	var layername = layerId.substring(1,layerId.length)
	labelSize=getLabelSize(layername)
//alert(layername+" "+labelSize)
	if(labelSize<0) return
	var feats=theLayer.getChildNodes();
//alert("ls "+labelSize)
	for(f=0;f<feats.length;f++){
		featf=feats.item(f)
		if (featf.nodeName=="#text") continue;
		labelone(featf,labelSize)
	}
	var labelgroup=svgdoc.getElementById(layerId+"_label")
	if (labelgroup) labelgroup.setAttribute("fill",labelColor)
	
	if (labelLanguage) labelgroup.setAttribute("systemLanguage",labelLanguage)
	else labelgroup.setAttribute("systemLanguage","es")
	
//alert("fin")	
}



function setMarkerSize(theName,theST,rsize){
	if (theST=="marker"){
		thegmark=svgdoc.getElementById("l"+theName)
		mrk=thegmark.getElementsByTagName("use")
		for (mrki=0;mrki<mrk.length;mrki++) {
			var centerx=parseFloat(mrk.item(mrki).getAttribute("x"))+parseFloat(mrk.item(mrki).getAttribute("width"))/2.0
			var centery=parseFloat(mrk.item(mrki).getAttribute("y"))+parseFloat(mrk.item(mrki).getAttribute("height"))/2.0
			var newmx=centerx-rsize/2.0
			var newmy=centery-rsize/2.0
			setLayout(mrk.item(mrki),newmx,newmy,rsize,rsize)
		}
	}
}

function sizeFactor(){
	var map = svgdoc.getElementById("map");
	mapvb = map.getAttribute("viewBox").split(" ");
	vbWd = parseFloat(mapvb[2]);
	mapWd = parseFloat(map.getAttribute('width'));
	//screenWd = parseFloat(screen.width);
	screenWd = parseFloat(getInnerWidth());
	return vbWd/screenWd;
}
function applyToMap(theName,aLeg){
	cthis=svgdoc.getElementById("c"+aLeg.Name);	if(cthis) clearchilds(cthis);
	if (aLeg.Type=="single symbol"){
		var kids = svgdoc.getElementById("l"+theName).getChildNodes();
		for(j=0;j<kids.length;j++){
			thenod=kids.item(j);
			if (thenod.nodeName=="#text") continue;
			setFeatureAtt(thenod,aLeg.Symbols[0])
		}
	}else if((aLeg.Type=="chart symbol")){
		aLeg.drawChart(aLeg.ChartType);
		var kids = svgdoc.getElementById("l"+theName).getChildNodes();
		for(j=0;j<kids.length;j++){
			thenod=kids.item(j);
			if (thenod.nodeName=="#text") continue;
			var asymb=new Symbol();
			asymb.bgFill="rgb(255,255,204)"
			if(thenod.getAttribute("fill")!="") asymb.bgFill=thenod.getAttribute("fill")
			asymb.bgStroke="rgb(0,0,0)"
			asymb.strokeWidth="1"
			setFeatureAtt(thenod,asymb);
		}
	}else{
		var NCFnl  = svgdoc.getElementsByTagName(aLeg.fName)
		for (j=0;j<NCFnl.length;j++){
			featNodeFValue = NCFnl.item(j).firstChild.nodeValue;
			featNode =NCFnl.item(j).getParentNode();
			featID= featNode.getElementsByTagName(theName+".FeatureID").item(0).firstChild.nodeValue;
			var thenod = svgdoc.getElementById("l"+theName+"f"+featID);
			var theIdx = aLeg.getIndex(featNodeFValue);
			setFeatureAtt(thenod,aLeg.Symbols[theIdx])
		}
	}
	setDim()
}

function setFeatureAtt(thenod,asid){
	if (!asid) return;
	thenod.setAttribute('fill',asid.bgFill);
	thenod.setAttribute('stroke',asid.bgStroke);
	thenod.setAttribute('stroke-width',asid.strokeWidth*sizeFactor());
	thenod.setAttribute('opacity',asid.opac);
	if (thenod.nodeName=='use'){
		thenod.setAttribute('xlink:href',asid.xLink);
		oldwidthuse=parseFloat(thenod.getAttribute('width'));
		dimdiff=oldwidthuse-asid.size*sizeFactor();
		oldxuse=parseFloat(thenod.getAttribute('x'));oldyuse=parseFloat(thenod.getAttribute('y'));
		if (dimdiff!=0.0)	setLayout(thenod,oldxuse+dimdiff/2,oldyuse+dimdiff/2,asid.size*sizeFactor(),asid.size*sizeFactor())
	}
}

// acquire attribute data values for a classification field
function makeArrayFromCF(theName,theCF){
	var newArr = new Array();
	fval = svgdoc.getElementsByTagName(theName+"."+theCF);
	for (i=0;i<fval.length;i++){
		newArr[i]= fval.item(i).firstChild.nodeName;
	}
	return newArr;
}
// checkboxes routines
function makecbox(cboxdim){
	for (m=0;m<LEGS.List.length;m++){
		var ln = LEGS.List[m].Name;
		var usel = svgdoc.getElementById('masterUse').cloneNode(true);
		usel.setAttribute('id',ln);	usel.setAttribute('xlink:href','#check');
		var xcbox=LEGS.List[m].xpos;	var ycbox=LEGS.List[m].ypos;
		usel.setAttribute('x',xcbox);	usel.setAttribute('y',ycbox);
		usel.setAttribute('width',cboxdim);	usel.setAttribute('height',cboxdim);
		var func='onoff("'+ln+'",true)';	usel.setAttribute('onclick',func);
	 	legDoc.getElementById('cboxes').appendChild(usel);	
	}
}
function moveCBox(){
	cbs = svgdoc.getElementById("cboxes").getElementsByTagName("use")
	for (m=0;m<LEGS.List.length;m++){
		var xcbox=LEGS.List[m].xpos;	
		var ycbox=LEGS.List[m].ypos;
		cbs.item(m).setAttribute('x',xcbox);
		cbs.item(m).setAttribute('y',ycbox);
	}
}

	function chk(evt){
		var chkstate=evt.getTarget().getAttribute('xlink:href');
		if (chkstate=='#uncheck') {
			evt.getTarget().setAttribute('xlink:href','#check');
			onoff(evt.getTarget().getAttribute('id'),true);
		}else{
			evt.getTarget().setAttribute('xlink:href','#uncheck');
			onoff(evt.getTarget().getAttribute('id'),false);
		}
	}
function onoff(id,which) {		//turn layer on - off
	svgobj = svgdoc.getElementById("l"+id);
	svglabel = svgdoc.getElementById("l"+id+"_label");
	svgchart = svgdoc.getElementById("c"+id);
	svgstyle = svgobj.getStyle();
	if (which == true) {
		svgobj.setAttribute('display','inline');
		if (svglabel) svglabel.setAttribute('display','inline');
		if (svgchart) svgchart.setAttribute('display','inline');
	}else {
		svgobj.setAttribute('display','none');
		if (svglabel) svglabel.setAttribute('display','none');
		if (svgchart) svgchart.setAttribute('display','none');
	}

}

// setting legend inner svg to accomodate all legend keys
function setDim(){
	var legLay= svgdoc.getElementById("legendLayers");
	var bbx = legLay.getBBox();
	var svgRoot = svgDocument.documentElement;
	scle =1.0 / svgRoot.currentScale;
	legDoc.setAttribute('width',1.0*bbx.width*scle);
	legDoc.setAttribute('height',1.0*bbx.height*scle);
	setViewBox(legDoc,(bbx.x-4)*scle,bbx.y*scle,(bbx.width+4)*scle,bbx.height*scle);
	legDoc.setAttribute('preserveAspectRatio','xMinyMin meet');
}

function chbutd(evt){
	targ=evt.getTarget();
	tfill = targ.getAttribute("xlink:href");
	if (tfill.indexOf("2")<0) {
		targ.setAttribute("xlink:href",tfill+"2");
	}
}
function chbutu(evt){
	targ=evt.getTarget();
	tfill = targ.getAttribute("xlink:href");
	if (tfill.indexOf("2")>-1) {
		targ.setAttribute("xlink:href",tfill.substring(0,tfill.length-1));
	}
}

function legscroll(evt){
	targ=evt.getTarget();
	var svgRoot = svgDocument.documentElement;
	var svgLeg 	= svgdoc.getElementById("legend");
	var lht		= parseFloat(svgLeg.getAttribute("height"));
	scle =1.0 / svgRoot.currentScale;
	var tht		= parseFloat(legDoc.getAttribute("height"));
	var thty 	= parseFloat(legDoc.getAttribute("y"));
	scrollstep = 0.5*lht;
	if (targ.getAttribute('id')=="legup"){
		newlty = parseFloat(thty + scrollstep);
		if (newlty>0) newlty=0 ;	
	}else{
		newlty = parseFloat(thty - scrollstep);
		if (newlty<(-tht+0.9*lht)) newlty=(-tht+0.9*lht);
	}
	legDoc.setAttribute("y",newlty);

}

/*****************************
* 		MAP DIGITIZER			 *
******************************/
function addFeature(evt){
//mod : AR
	var newcoord=new coordTranslator(evt)
//end mod AR
	newX=newcoord.x
	newY=newcoord.y
		if( pathadder==null )
			{
				pathadder = svgdoc.getElementById("pathadder");
				pathadder2 = svgdoc.getElementById("pathadder2");
				pathadder2.getStyle().setProperty("visibility", "visible");
				startX=newX;
				startY=newY;
				pathadder.setAttribute("d", "M " + startX+ " " + startY + " ");
			}
			else
			{
				var newpath=pathadder.getAttribute("d");
				newpath=newpath.substring(0,newpath.length-1)
				if (startNew==true)
				{
					startX=newX;
					startY=newY;
					newpath=newpath + "z" +" M " + startX + " " + startY + " ";
					startNew=false;
				}
				else
				{
					newpath=newpath+" L " + newX + " " + newY + " ";
				}

				if((oldX==newX)&&(oldY==newY))
				{
					startNew=true;
				}
				else
				{
					oldX=newX;
					oldY=newY;
				}
				pathadder.setAttribute("d",newpath);
				pathadder2.setAttribute("d", newpath+"z" );
			}
}

function addFeaturePoint(evt) {
	var newcoord=new coordTranslator(evt)
	newX=newcoord.x;
	newY=newcoord.y;
	if((pathadder != null)&&(startNew!=true)&&(pressedButton="add_feature"))
	{
		var newpath=pathadder.getAttribute("d");
		newpath=newpath.substring(0,newpath.length-1)
		newpath=newpath+" L " + newX + " " + newY + " ";
		//alert(newpath);
		pathadder2.setAttribute("d", newpath+"z" );
	}
}

/*****************************
* 	MAINMAP EVENTS			 *
******************************/
function addEvents(){
	map = svgdoc.getElementById("map");
	map.setAttribute("onclick","mapClick(evt)");
	map.setAttribute("onmousemove","mapMove(evt)");
	mapLay = svgdoc.getElementById("mapLayers");
	mapLay.setAttribute("onmouseover","mapOver(evt)");
	mapLay.setAttribute("onmouseout","mapOut(evt)");
}
function mapClick(evt){
	if(pressedbutton=="identify") showIdentity(evt);
	if(pressedbutton=="labelmanual") labelone(evt.getTarget());
	if(pressedbutton=="input") addFeature(evt);
	if(pressedbutton=="") openMap(evt);
}
function openMap(evt){
}
//added NR
function mapMove(evt){
	if((pathadder!=null)&&(pressedbutton=="add_feature")) addFeaturePoint(evt);
	showCoord(evt);
}
//end added NR

function showCoord(evt){
	var newcoord=new coordTranslator(evt);
	crdx=newcoord.x;
	crdy=newcoord.y;
	coordstr=roundValue(crdx,cprec)+" , "+roundValue(crdy,cprec);
	setToolBarStatus(coordstr);
}
function roundValueString(aValue,aPrecission){
	var dotpos= String(aValue).indexOf(".");
	var lval  = String(aValue).substring(0,dotpos);
	var pl =dotpos+1+aPrecission
	if(pl>String(aValue).length) pl=String(aValue).length
	var rval  = String(aValue).substring(dotpos+1,pl);
	return lval+"."+rval
}

function coordTranslator(evt){
	var crtsc = svgdoc.rootElement.currentScale;
	var crttr = svgdoc.rootElement.currentTranslate;
	var mapnod = svgdoc.getElementById("map");
	var mlvb = mapnod.getAttribute("viewBox").split(" ");
	var clientx=evt.clientX;
	var clienty=evt.clientY;
	var xoffset= 0.0;
	var yoffset= 0.0;
	var adjuster=findAdjuster("map");
	if (adjuster>1.0){	//width meet vert map edges
		yoffset= parseFloat(mlvb[3])*(1.0-adjuster)*0.5
		clienty= evt.clientY+yoffset*crtsc
		var realwd = parseFloat(mapnod.getAttribute("width"))
		var realht = parseFloat(mapnod.getAttribute("height"))*adjuster
	}else{	//height meet horz map edges
		xoffset= parseFloat(mapnod.getAttribute("width"))*(1.0-adjuster)*0.5
		clientx= evt.clientX-xoffset*crtsc
		var realwd = parseFloat(mapnod.getAttribute("width"))*adjuster
		var realht = parseFloat(mapnod.getAttribute("height"))
	}
	var xfac = parseFloat(mlvb[2]) / realwd / crtsc;
	var yfac = parseFloat(mlvb[3]) / realht / crtsc;
	this.x=parseFloat(mlvb[0]) + xfac*(clientx - crttr.x);
	var tbht=30.0;	//toolbar height
	this.y=parseFloat(mlvb[1]) + parseFloat(mlvb[3]) - yfac*(clienty - crttr.y - tbht*crtsc);
}
function setinfo(whatid,whattext){
	var ttx = svgdoc.getElementById(whatid);
	if (ttx) ttx.firstChild.setData(whattext);
}
function mapOver(evt){
	if(evt.button!=0) return;	if(evt.altKey) return;	if(evt.ctrlKey) return;
	if (hiliteon) hilightFeature(evt.getTarget(),true);
	thisid=evt.getTarget().getAttribute("id")
	thevalue = findLabelValue(thisid)
	var fpos = thisid.lastIndexOf("f");
	if (thevalue==null) {
		var infostring = thisid
	}else{
		var infostring = thisid.substring(1,fpos)+" : "+thevalue
	}
	setToolBarInfo(infostring)
}
function mapOut(evt){
	setinfo('quickinfo',"GeoClient");
	if(!oldobj) return;	
	if(evt.button!=0) return; 
	if (hiliteon) hilightFeature(evt.getTarget(),false);
}

function hilightFeature(aNode,state){
	if(!aNode) return;
	var nodparent=aNode.getParentNode();	
	var crtsc = svgdoc.rootElement.currentScale;
	var curfill=aNode.getAttribute('fill');

	var layername =getLayerName(aNode.getAttribute("id"));
	var nlnod=findNamedLayer(layername);	
	if (nlnod)	var shapeTypex = nlnod.getElementsByTagName('Shape')
	if(shapeTypex) var shapeTypez = shapeTypex.item(0)
	if(shapeTypez) var shapeType = shapeTypez.firstChild.nodeValue;
	if (!nlnod) var shapeType ="button";	//point,line,polygon,button
	if(state) {
		if (shapeType=="line"){
			oldobjstwd=aNode.getAttribute('stroke-width');
			if (oldobjstwd=="") oldobjstwd=parseFloat(nodparent.getAttribute('stroke-width'));
			aNode.setAttribute('stroke-width',3*oldobjstwd);
		}else{
			if ((curfill=="none")||(curfill=="")) curfill=nodparent.getAttribute('fill');
			oldobjfill = curfill;
			aNode.setAttribute('fill',"url(#litegrad)");
		}
		oldobj=aNode;	
	}else{
		if (oldobj) {
			if (shapeType=="line"){
				oldobj.setAttribute('stroke-width',oldobjstwd);
			}else{
				oldobj.setAttribute('fill',oldobjfill);
			}
		}
	}
}

	function getTitleField(layerName){
		var nmlnode  = findNamedLayer(layerName);
		if(!nmlnode) return null;
		var theField = nmlnode.getElementsByTagName("NameField").item(0).firstChild.nodeValue;
		return theField
	}

	function xshowIdentity(evt){
	}
	function showNodeIdentity(nodeid){
	}
	function doShowInfo(){
	}

/*****************************
* 		TOOLBAR FUNCTIONS 	 *
******************************/
	function createToolbarButton(evt){
		ToolBar=new Object()
		ToolBar.Buttons=new Array();
		svgdoc=evt.getTarget().getOwnerDocument()
		var tb=svgdoc.getElementById("toolbar");
		var bn=[	["zoomin","#zoomplus","window.setTimeout('mapzoom(1)',10)",false,"zoom in"],
					["zoomnone","#nozoom","window.setTimeout('mapzoom(0)',10)",false,"zoom original"], 
					["zoomin","#zoommin","window.setTimeout('mapzoom(-1)',10)",false,"zoom out"],"space",
					["identify","#identify","",true,"identify : click map object while this button pressed for info"],
					["search","#find","showSearchWindow()",false,"query objects based on their attribute data"],
					["legendsetting","#legendsetting","showLegendSetting()",false,"legend setting"],
					["legendinstant","#quick","showInstantLegend()",false,"instant legend"],"space",
					["labelsetting","#labelsetting","showLabelSetting()",false,"label setting"],
					["labelauto","#autolabel","window.setTimeout('labelall()',10)",false,"auto label - toggle"],
					["labelmanual","#label","",true,"manual label : click map object while this button pressed to give it a label"],"space",
					["input","#input","",true,"digitizer : click on map area to draw vertex, double click to end"],
					["preferences","#pref","showPreferences()",false,"set preferences"],
					["helpabout","#helpz","helpabout()",false,"about GeoClient"]
				 ]
		var gap=1; var xp=5; var wd=24; var ht=20; var yp=(30-20)/2
		var qlt = svgdoc.getElementsByTagName("quickLegend");
		for(var i=0;i<bn.length;i++){
			if(bn[i]=="space"){
				xp+=3
			}else if((bn[i][0]=="legendinstant")&&(qlt.length==0)){
			}else{
				var gb=new GeoButton({name:bn[i][0],icon:bn[i][1],tristate:bn[i][3],x:xp,y:yp,backcolor:"skyblue",selcolor:"deepskyblue",overcolor:"url(#litegrad)",width:wd,height:ht,bordersize:1.25});
				gb.action=bn[i][2]+";checkToggledTool(this)";
				ToolBar.Buttons[ToolBar.Buttons.length]=gb;
				xp+=wd+gap
				tb.appendChild(gb.getNode());
				gb.getNode().setAttribute("onmouseover","setToolBarInfo('"+bn[i][4]+"')")
			}
		}
		ToolBar.info  = new GeoLabel({x:xp, y:2, width:400, height:12, value:"GeoClient",opacity:0, forecolor:"black", align:"left",adjust:"fit"});
		ToolBar.status= new GeoLabel({x:xp, y:16, width:400, height:13, value:"v.011",opacity:0, forecolor:"black", align:"left",adjust:"fit"});
		tb.appendChild(ToolBar.info.getNode());
		tb.appendChild(ToolBar.status.getNode());
	}
	function setToolBarInfo(str){
		if(ToolBar.info) ToolBar.info.setValue(str);
	}
	function setToolBarStatus(str){
		if(ToolBar.status) ToolBar.status.setValue(str);
	}
	function checkToggledTool(button){
		for(var i=0;i<ToolBar.Buttons.length;i++){
			if(ToolBar.Buttons[i].name==button.name){
				pressedbutton=button.name;
			}else{
				if((ToolBar.Buttons[i].tristate)&&(ToolBar.Buttons[i].state)) {
					ToolBar.Buttons[i].buttonface.click();
					ToolBar.Buttons[i].state=ToolBar.Buttons[i].buttonface.state
				}
			}
		}
	}

	function mapzoom(zt){
		var mapR = svgdoc.rootElement;
//*** mod AR
		var curwd = parseFloat(svgdoc.getElementById("map").getAttribute("width"))
		var curht = parseFloat(svgdoc.getElementById("map").getAttribute("height"))
		if (zt==-1)	{ //zoom out
			mapR.currentScale/=1.5;
			mapR.currentTranslate.x+=(curwd*1.5-curwd)*mapR.currentScale/2.0;
			mapR.currentTranslate.y+=(curht*1.5-curht)*mapR.currentScale/2.0;
		}
		if (zt==0){	
			mapR.currentScale=1.0; mapR.currentTranslate.x=0.0;	mapR.currentTranslate.y=0.0;
		}
		if (zt==1)	{ //zoom in
			mapR.currentScale*=1.5;
			mapR.currentTranslate.x+=(curwd/1.5-curwd)*mapR.currentScale/2.0;	
			mapR.currentTranslate.y+=(curht/1.5-curht)*mapR.currentScale/2.0;	
		}
//*** end mod AR
	}


/*****************************
* 		LABELING FUNCTIONS 	  *
******************************/
function autoapplylabel(){
	var map = svgdoc.getElementById("map");
	var oldlabelga = svgdoc.getElementById("autolabelgroup");
	var oldlabelgm = svgdoc.getElementById("manuallabelgroup");
	if (oldlabelgm) map.removeChild(oldlabelgm);
	if (oldlabelga) map.removeChild(oldlabelga);
	makeLabelGroup("autolabelgroup");
	var maplay = svgdoc.getElementById("mapLayers");
	mlg = maplay.getElementsByTagName("g");
	for (iml=0;iml<mlg.length;iml++){
		mlgi = mlg.item(iml);
		if (mlgi.getAttribute("display")=="none") continue;
		var labellayer=svgdoc.getElementById(mlgi.getAttribute("id")+"_label");
		mlgc = mlgi.getChildNodes();
		for (jml=0;jml<mlgc.length;jml++){
			mlgcj=mlgc.item(jml);
			if (mlgcj.nodeName=="#text") continue;
			var mlgcjid  = mlgcj.getAttribute("id");
			var	featname = findLabelValue(mlgcjid);				
			if(labellayer) labellayer.appendChild(makeFeatureLabel(mlgcj,featname));
		}
	}
}

function labelall(){
	var map = svgdoc.getElementById("map");
	var oldlabelga = svgdoc.getElementById("autolabelgroup");
	var oldlabelgm = svgdoc.getElementById("manuallabelgroup");
	if (oldlabelgm) map.removeChild(oldlabelgm);
	if (oldlabelga) {
		map.removeChild(oldlabelga);
		return;
	}
	makeLabelGroup("autolabelgroup");
	var maplay = svgdoc.getElementById("mapLayers");
	mlg = maplay.getElementsByTagName("g");
	for (iml=0;iml<mlg.length;iml++){
		mlgi = mlg.item(iml);
		if (mlgi.getAttribute("display")=="none") continue;
		var labellayer=svgdoc.getElementById(mlgi.getAttribute("id")+"_label");
		mlgc = mlgi.getChildNodes();
		for (jml=0;jml<mlgc.length;jml++){
			mlgcj=mlgc.item(jml);
			if (mlgcj.nodeName=="#text") continue;
			var mlgcjid  = mlgcj.getAttribute("id");
			var	featname = findLabelValue(mlgcjid);				
			if(labellayer) labellayer.appendChild(makeFeatureLabel(mlgcj,featname));
		}
	}
}

function labelone(targ,labelSize){
	var oldlabelga = svgdoc.getElementById("autolabelgroup");
	if (oldlabelga) map.removeChild(oldlabelga);
	var oldlabelgm = svgdoc.getElementById("manuallabelgroup");
	if (!oldlabelgm) {
		var mlgo = makeLabelGroup("manuallabelgroup",labelSize);
		if (mlgo==null) return;
	}
	var targParent = targ.getParentNode();
	var existingLabelLayer = svgdoc.getElementById(targParent.getAttribute("id")+"_label");
	if ((labelSize)&&(existingLabelLayer)) existingLabelLayer.setAttribute("font-size",labelSize*sizeFactor());

	targid = targ.getAttribute("id")
	var existingLabel = svgdoc.getElementById(targid+"_label");
	if (existingLabel) existingLabel.parentNode.removeChild(existingLabel);
	var fpos = targid.lastIndexOf("f");	
	var layerId = targid.substring(0,fpos); //e.g : lStates, not States.
	var labellayer=svgdoc.getElementById(layerId+"_label");
	if(labellayer)	labellayer.appendChild(makeFeatureLabel(targ,findLabelValue(targid)));
}

var initiallabelsize=10;
function setNameField(layername,fieldname,size){
	
	var eld=svgdoc.getElementsByTagName("ExtendedLayerDescriptor").item(0)
	var nmdlay=eld.getElementsByTagName("NamedLayer")
	for (var n=0;n<nmdlay.length;n++){
		var nlname=nmdlay.item(n).getAttribute("name")
		if (nlname==layername){
			nmdlay.item(n).getElementsByTagName("NameField").item(0).firstChild.setData(fieldname);
			var lbes = nmdlay.item(n).getElementsByTagName("LabelSize")
			if(lbes.length==0){
				var lbe = svgdoc.createElementNS(null,"LabelSize");
				var tdata = svgdoc.createTextNode(size);
				lbe.appendChild(tdata);
				var a = nmdlay.item(n).appendChild(lbe);
				//alert(pn(nmdlay.item(n)))
			}else{
				lbes.item(0).firstChild.setData(size);
			}
			break;
		}
	}
}

function makeLabelGroup(groupName,thelfsize){
	var map = svgdoc.getElementById("map");
	var maplay = svgdoc.getElementById("mapLayers");
	newlabelg=svgdoc.createElement("g");
	newlabelg.setAttribute("id",groupName);
	newlabelg.setAttribute("style","text-anchor:middle;glyph-anchor:centerline;glyph-orientation-horizontal:0;")
	newlabelg.setAttribute("font-family","Arial"); 
	//newlabelg.setAttribute("pointer-events","none")
	labelg=map.appendChild(newlabelg);
	mlg = maplay.getElementsByTagName("g");
	for (iml=0;iml<mlg.length;iml++){
		mlgi = mlg.item(iml);
		var layerid=mlgi.getAttribute("id");
		var lyname =layerid.substring(1,layerid.length);
		thelfsize = getLabelSize(lyname);
		if (thelfsize<=0) continue;
		var fs=parseFloat(thelfsize)*sizeFactor();
		var newg=labelg.appendChild(svgdoc.createElement("g"))
		newg.setAttribute("id",layerid+"_label")
		thecolor ="rgb(0,0,0)"
		newg.setAttribute("fill",thecolor); 
		newg.setAttribute("font-size",fs);
		newg.setAttribute("stroke","none");
		newg.setAttribute("opacity","1.0");
	}
}

function makeFeatureLabel(featNode,featLabelValue){
	if ((featLabelValue==null)||(featLabelValue=="")) return;
	var shapeType=null;
	var layername =getLayerName(featNode.getAttribute("id"));
	var nlnod=findNamedLayer(layername);
	if (nlnod) {
		var dasf = nlnod.getElementsByTagName('Shape')
		if(dasf.length==0) return;
		var shapeNode = dasf.item(0);
	}
	if (shapeNode) shapeType=shapeNode.firstChild.nodeValue;
	if (!shapeType) return; 
	var map = svgdoc.getElementById("map");
	var mapvb = map.getAttribute("viewBox").split(" ");
	if (shapeType=="point"){
		txty = 2*parseFloat(mapvb[1])+parseFloat(mapvb[3])-parseFloat(featNode.getAttribute('y'))-parseFloat(featNode.getAttribute('height'));
		txtx = featNode.getAttribute('x');
	}else if (shapeType=="line"){
		var cp=featNode.getPointAtLength(featNode.getTotalLength()/2.0)
		txty = 2.0*parseFloat(mapvb[1])+parseFloat(mapvb[3])-cp.y;
		txtx = cp.x
	}else{
		var tbox=featNode.getBBox();
		var tby=tbox.y+tbox.height/2.0;
		txty = 2*parseFloat(mapvb[1])+parseFloat(mapvb[3])-tby;
		txtx = tbox.x+tbox.width/2.0;
	}
	var te=svgdoc.createElement("text");
	te.appendChild(svgdoc.createTextNode(featLabelValue));
	te.setAttribute("x",txtx);	te.setAttribute("y",txty);
	te.setAttribute("id",featNode.getAttribute("id")+"_label");
	te.setAttribute("font_size",150);
	return te;
}

function findLabelValue(theNodeId){
	if (theNodeId.indexOf("_label")>-1) return;
	var labelValue="";
	var fpos = theNodeId.lastIndexOf("f");
	var featIndex= theNodeId.substring(fpos+1,theNodeId.length);
	var layerName= theNodeId.substring(1,fpos);
	var nmlnode  = findNamedLayer(layerName);
	if(!nmlnode) return null;
	var theField = nmlnode.getElementsByTagName("NameField").item(0).firstChild.nodeValue;
	var theValue =findFeatureValue(layerName,featIndex,theField);
	if (theValue!=null) labelValue=theValue;
	return labelValue;
}

function findNamedLayer(layername){
	var eldnode = svgdoc.getElementsByTagName("ExtendedLayerDescriptor").item(0);
	var nmlay = eldnode.getElementsByTagName("NamedLayer");
	for (nmi=0;nmi<nmlay.length;nmi++){
		nameAtt=nmlay.item(nmi).getAttribute("name");
		if (nameAtt==layername) {
			return nmlay.item(nmi);
		}
	}
}
// return a featureMember
function findFeatureMember(layername,itemidx){
	var fcoll = svgdoc.getElementsByTagName("featureCollection").item(0);
	var idColl = fcoll.getElementsByTagName(layername+".FeatureID");
	for (lfi=0;lfi<idColl.length;lfi++){
		var theID = idColl.item(lfi).firstChild.nodeValue;
		if (theID==itemidx) return idColl.item(lfi).getParentNode();
	}			
}
// return the corresponding featureMember from a map feature id
function getDataNode(featid){
	var featureNumber = getFeatureIndex(featid)
	var layerName = getLayerName(featid);
	return findFeatureMember(layerName,featureNumber);
}
function findFeatureValue(layerName,featIndex,field){
	var thevalue=null;
	var featnode = findFeatureMember(layerName,featIndex);
	if (featnode) var fieldnode = featnode.getElementsByTagName(layerName+"."+field).item(0)
	if (fieldnode) thevalue = fieldnode.firstChild.nodeValue
	return thevalue;
}
// return layerName and featureNumber from the id of a feature
function getLayerName(aFeatureID){
	var fpos = aFeatureID.lastIndexOf("f");
	return aFeatureID.substring(1,fpos);
}
function getFeatureIndex(aFeatureID){
	var fpos = aFeatureID.lastIndexOf("f");
	return aFeatureID.substring(fpos+1,aFeatureID.length);
}

function makeDaRect(container,xpos,ypos,wd,ht,thefill,klik){
	r=svgdoc.createElement("rect");	setLayout(r,xpos,ypos,wd,ht);
	r.setAttribute("fill",thefill);
	if((klik!="")&&(klik!=null)) r.setAttribute("onclick",klik);
	r = container.appendChild(r);
	return r;
}

//**************************	Experiments	********************

//add feature member fields to allfield if not yet in list.
function addToFieldArray(aFeatureMember,anArray){
	var fcpc=aFeatureMember.getChildNodes()
	for(g=0;g<fcpc.length;g++){
		var aNode=fcpc.item(g)
		var dotpos=aNode.nodeName.indexOf(".")
		var optT=aNode.nodeName.substring(dotpos+1,aNode.nodeName.length)
		if ((optT=="FeatureID")||(optT=="XMin")||(optT=="XMax")||(optT=="YMin")||(optT=="YMax")||(optT=="Shape")||(optT=="Geometry") ) continue;
		if (aNode.nodeName=="#text") continue;
		if(!(isThere(anArray,aNode.nodeName))) anArray[anArray.length]=aNode.nodeName;
	}
	return anArray;
}

function changeCF(aLegName,legtype,classtype,cfnodename,newCN,charttype,chartsize,chartcolors){
/*
	alert(	" ;aLegName:" + aLegName + 
		" ;legtype:" + legtype + 
		" ;classtype:" + classtype + 
		" ;cfnodename:" + cfnodename + 
		" ;newCN:" + newCN + 
		" ;charttype:" + charttype +
		" ;chartsize:" + chartsize + 
		" ;chartcolors:" + chartcolors)
*/		
	var aLeg=LEGS.findLeg(aLegName)
	if (!aLeg) {alert("error on legend name");return;}
	theName=aLeg.Name; 
	aLeg.Type=legtype;
	clearchilds(aLeg.node);
	clearchilds(svgdoc.getElementById(aLeg.Id+"label"));
	switch(legtype){
		case "single symbol"	:
			aLeg.SingleSymbol();
			break;
		case "unique value"	:
			var crarr=null;	if (chartsize)	crarr=chartsize.split(" ");
			aLeg.Unique(cfnodename);
			aLeg.modifySymbolList(crarr);
			break;
		case "chart symbol"	:
			var crarr=null;
			if(chartcolors) crarr=chartcolors.split(" ");
			aLeg.Chart(cfnodename.split("|"),charttype,chartsize);
			aLeg.modifySymbolList(crarr);
			break;
		case "graduated color"	:
			aLeg.ClassType=classtype;	theCT=aLeg.ClassType;
			if (isNaN(parseInt(newCN))) {	alert("Class number must be an integer");return;}
			newCN=parseInt(newCN);
			if (theCT=="quantile") aLeg.Quantile(cfnodename,newCN);
			if (theCT=="equal interval") aLeg.Interval(cfnodename,newCN);
			if ((theCT!="quantile")&&(theCT!="equal interval")){
				alert("sorry, the "+theCT+" classification not supported yet."+"\r"+"switching to quantile");
				aLeg.Quantile(cfnodename,newCN);
			}
			var crarr=null; if (chartsize) crarr=chartsize.split(" ");
			aLeg.modifySymbolList(crarr);
			break;
		default :		
			break;
	}

	aLeg.Update();
	aLeg.arrange();
	aLeg.makeLabel(svgdoc);
	applyToMap(theName,aLeg);
	
	LEGS.arrange(legDoc);	
	moveCBox();
	setDim();
	svgdoc.getElementById('tester').setAttribute("y","0")
}

function panto(featid){
	var mapfeature=svgdoc.getElementById(featid)
	if (mapfeature.nodeName=='use') {
		var appcentx=parseFloat(mapfeature.getAttribute('x'))+parseFloat(mapfeature.getAttribute('width'))/2.0
		var appcenty=parseFloat(mapfeature.getAttribute('y'))+parseFloat(mapfeature.getAttribute('height'))/2.0
	}else{
		var bb=mapfeature.getBBox()
		var appcentx=parseFloat(bb.x+bb.width*0.5)
		var appcenty=parseFloat(bb.y+bb.height*0.5)
	}
	calcTranslation(svgdoc.rootElement.currentScale,appcentx,appcenty)
}

function zoomto(featid){
	var mapfeature=svgdoc.getElementById(featid)
	if (mapfeature.nodeName=='use') {
		var appcentx=parseFloat(mapfeature.getAttribute('x'))-4.0*parseFloat(mapfeature.getAttribute('width'))/2.0
		var appcenty=parseFloat(mapfeature.getAttribute('y'))-4.0*parseFloat(mapfeature.getAttribute('height'))/2.0
		appwidth=4.0*parseFloat(mapfeature.getAttribute('width'))
		appheight=4.0*parseFloat(mapfeature.getAttribute('height'))
		var newcs=Math.min(parseFloat(0.5*pbProp.w/appwidth),parseFloat(0.5*pbProp.h/appheight));
	}else{
		var bb=mapfeature.getBBox()
		var appcentx=parseFloat(bb.x+bb.width*0.5)
		var appcenty=parseFloat(bb.y+bb.height*0.5)
		var newcs=Math.min(parseFloat(0.5*pbProp.w/bb.width),parseFloat(0.5*pbProp.h/bb.height));
	}
	if (newcs>8.0) newcs=8.0;
	svgdoc.rootElement.currentScale=newcs
	calcTranslation(newcs,appcentx,appcenty)
}

function calcTranslation(cs,appcentx,appcenty){
	svgroot=svgdoc.rootElement
	var map = svgdoc.getElementById("map");
	mapwd = parseFloat(map.getAttribute('width'));
	mapht = parseFloat(map.getAttribute('height'));
	mapvb=map.getAttribute("viewBox").split(" ")
	mapvbx=parseFloat(mapvb[0]);	mapvby=parseFloat(mapvb[1]);	
	mapvbwd=parseFloat(mapvb[2]);	mapvbht=parseFloat(mapvb[3]);
	var adjuster= findAdjuster("map");
	hShift=0.0;		vShift=0.0;
	if(adjuster>1.0){
		vShift=mapvbht*0.5*(1.0-adjuster);
	}else{
		hShift=mapvbwd*0.5*(1.0-adjuster);
	}
	var centx=parseFloat(appcentx-mapvbx+hShift)*parseFloat(cs*mapwd/(mapvbwd+2.0*hShift))
	var centy=parseFloat(-appcenty+mapvby+mapvbht+vShift)*parseFloat(cs*mapht/(mapvbht+2.0*vShift))
	svgroot.currentTranslate.x=-(centx-0.5*mapwd)
	svgroot.currentTranslate.y=-(centy-0.5*mapht)
}


@


1.1
log
@*** empty log message ***
@
text
@@

