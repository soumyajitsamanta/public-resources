head	1.2;
access;
symbols
	jpivot_1_8_0:1.2
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.2
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;


1.2
date	2006.11.09.13.25.44;	author avix;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.09.21.47.54;	author avix;	state Exp;
branches;
next	;


desc
@@


1.2
log
@synchronized with tonbeller cvs
@
text
@package com.tonbeller.jpivot.tags;

import java.util.Iterator;
import java.util.Stack;

/**
 * A Stack of states (name/value pairs). For every state name, there is only one value.
 * States with different names are stacked, every name is on the stack only once. Example:
 * <p />
 * <pre>
 * ps = new StackStateStrategy();
 * -- a1 is top of stack:
 * ps.setCurrent("A", a1);
 * -- replace a1 with a2:
 * ps.setCurrent("A", a2);
 * -- push b1 on the stack
 * ps.setCurrent("B", b1);
 * -- stack now contains a2, b1
 * -- push c1 on the stack
 * ps.setCurrent("C", c1);
 * -- pop c1 and b1 and make a3 top of stack
 * ps.setCurrent("A", a3);
 * -- stack contains a3 only
 * </pre>
 * 
 * @@author av
 * @@since 15.02.2005
 */
public class StackStateManager implements StateManager {
  Stack stack = new Stack();
  StateLogger logger = new Log4jStateLogger();

  private boolean stackContainsName(String name) {
    for (Iterator it = stack.iterator(); it.hasNext();) {
      State s = (State) it.next();
      if (name.equals(s.getName()))
        return true;
    }
    return false;
  }

  private void hideCurrent() throws Exception {
    State s = getCurrent();
    if (s != null) {
      logger.hide(s);
      s.hide();
    }
  }

  private void showCurrent() throws Exception {
    State s = getCurrent();
    if (s != null) {
      logger.show(s);
      s.show();
    }
  }

  private State getCurrent() {
    if (stack.isEmpty())
      return null;
    return (State) stack.peek();
  }

  /**
   * removes all properties from the stack
   * @@throws Exception 
   */
  public void initializeAndShow(State s) throws Exception {
    hideCurrent();
    while (stackContainsName(s.getName())) {
      State t = (State) stack.pop();
      logger.destroy(s);
      t.destroy();
    }
    logger.initialize(s);
    s.initialize();
    stack.push(s);
    showCurrent();
  }

  /**
   * pops and destroys all states up to but not including the named one. The named
   * state will become the visible one.
   * @@see #destroyByName 
   */
  public void showByName(String name) throws Exception {
    if (!stackContainsName(name)) {
      logger.error("not found in stack: " + name);
      return;
    }

    // already current?
    State s = getCurrent();
    if (name.equals(s.getName()))
      return;

    // unwind stack up to the requested name
    hideCurrent();
    while (!name.equals(s.getName())) {
      State t = (State) stack.pop();
      logger.destroy(t);
      t.destroy();
      s = (State) stack.peek();
    }
    showCurrent();
  }

  public void destroyAll() throws Exception {
    hideCurrent();
    while (!stack.isEmpty()) {
      State s = (State) stack.pop();
      logger.destroy(s);
      s.destroy();
    }
  }

  /**
   * pops and destroys all states up to and including the named one. If there is another
   * state beneath the named one, that will become the visible one.
   * @@see #showByName 
   */
  public void destroyByName(String name) throws Exception {
    hideCurrent();
    while (stackContainsName(name)) {
      State t = (State) stack.pop();
      logger.destroy(t);
      t.destroy();
    }
    showCurrent();
  }

  public StateLogger getLogger() {
    return logger;
  }

  public void setLogger(StateLogger logger) {
    this.logger = logger;
  }

}
@


1.1
log
@.
@
text
@a5 2
import org.apache.log4j.Logger;

d31 1
a31 1
  Logger logger = Logger.getLogger(StackStateManager.class);
d44 2
a45 1
    if (s != null)
d47 1
d52 2
a53 1
    if (s != null)
d55 1
d72 1
d75 1
d101 1
d112 1
d126 1
d131 9
a139 1
  
@

