head	1.2;
access;
symbols
	jpivot_1_8_0:1.2
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.2
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.2
date	2006.11.09.13.25.42;	author avix;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2005.07.05.14.19.55;	author avix;	state Exp;
branches;
next	;

1.2.2.1
date	2008.04.17.10.44.24;	author hbaier;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2008.04.24.04.39.57;	author kunarief;	state Exp;
branches;
next	;


desc
@@


1.2
log
@synchronized with tonbeller cvs
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 * 
 */
package com.tonbeller.jpivot.navigator.hierarchy;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import com.tonbeller.jpivot.core.ModelChangeEvent;
import com.tonbeller.jpivot.core.ModelChangeListener;
import com.tonbeller.jpivot.navigator.member.MemberSelectionModel;
import com.tonbeller.jpivot.olap.model.Axis;
import com.tonbeller.jpivot.olap.model.Hierarchy;
import com.tonbeller.jpivot.olap.model.OlapException;
import com.tonbeller.jpivot.olap.model.OlapModel;
import com.tonbeller.jpivot.olap.model.Result;
import com.tonbeller.jpivot.olap.navi.ChangeSlicer;
import com.tonbeller.jpivot.olap.navi.MemberDeleter;
import com.tonbeller.jpivot.olap.navi.PlaceHierarchiesOnAxes;
import com.tonbeller.jpivot.olap.navi.PlaceMembersOnAxes;
import com.tonbeller.jpivot.ui.Available;
import com.tonbeller.tbutils.res.Resources;
import com.tonbeller.wcf.catedit.CategoryEditor;
import com.tonbeller.wcf.catedit.CategoryModelSupport;
import com.tonbeller.wcf.component.Component;
import com.tonbeller.wcf.controller.Dispatcher;
import com.tonbeller.wcf.controller.DispatcherSupport;
import com.tonbeller.wcf.controller.RequestContext;
import com.tonbeller.wcf.controller.RequestListener;

/**
 * Navigation dialog
 *
 * @@author av
 */
public class HierarchyNavigator extends CategoryEditor implements ModelChangeListener, Available {

  public class CancelHandler implements RequestListener {
    private boolean hide;

    public CancelHandler(boolean hide) {
      this.hide = hide;
    }

    public void request(RequestContext context) throws Exception {
      editing = false;
      // we will recreate everything on the next render()
      revert(context);
      if (hide)
        setVisible(false);
    }
  }

  public class OkHandler implements RequestListener {
    private boolean hide;

    public OkHandler(boolean hide) {
      this.hide = hide;
    }

    public void request(RequestContext context) throws Exception {
      editing = false;
      boolean valid = validate(context);

      // the following will fire multiple ModelChangeEvents
      for (Iterator it = categories.iterator(); it.hasNext();)
        ((AbstractCategory) it.next()).deleteDeleted();
      for (Iterator it = categories.iterator(); it.hasNext();)
        ((AbstractCategory) it.next()).prepareApplyChanges();
      for (Iterator it = categories.iterator(); it.hasNext();)
        ((AbstractCategory) it.next()).applyChanges();

      if (valid && hide)
        setVisible(false);
    }
  }

  private String acceptButtonId;
  private String cancelButtonId;
  private RequestListener acceptHandler;
  private RequestListener revertHandler;
  private String okButtonId;
  private String revertButtonId;
  private List categories = new ArrayList();
  private Resources resources;

  /**
   * after the user has started editing, the CategoryModel is no longer synchronized with the
   * OlapModel. This means, the user may do one or more changes, and then apply these changes
   * at once to the OlapModel.
   */
  private boolean editing = false;

  private HierarchyItemClickHandler hierarchyItemClickHandler;
  private OlapModel olapModel;
  private CategoryModelSupport categoryModel;
  private Dispatcher tempDispatcher = new DispatcherSupport();
  private SlicerCategory slicerCategory;

  private static Logger logger = Logger.getLogger(HierarchyNavigator.class);

  /**
   * Constructor for HierNavigator.
   */
  public HierarchyNavigator(String id, Component parent, OlapModel olapModel) {
    super(id, parent);

    logger.info("creating instance: " + this);

    acceptButtonId = id + ".accept";
    cancelButtonId = id + ".cancel";
    okButtonId = id + ".ok";
    revertButtonId = id + ".revert";

    this.olapModel = olapModel;
    olapModel.addModelChangeListener(this);

    acceptHandler = new OkHandler(false);
    revertHandler = new CancelHandler(false);
    super.getDispatcher().addRequestListener(acceptButtonId, null, acceptHandler);
    super.getDispatcher().addRequestListener(revertButtonId, null, revertHandler);
    super.getDispatcher().addRequestListener(okButtonId, null, new OkHandler(true));
    super.getDispatcher().addRequestListener(cancelButtonId, null, new CancelHandler(true));
    super.getDispatcher().addRequestListener(null, null, tempDispatcher);
    categoryModel = new CategoryModelSupport() {
      public List getCategories() {
        return categories;
      }
    };
    super.setModel(categoryModel);
    super.setItemRenderer(new HierarchyItemRenderer());
  }

  public void initialize(RequestContext context) throws Exception {
    super.initialize(context);
    resources = context.getResources(HierarchyNavigator.class);
  }

  /**
   * Returns the hierExtension.
   * @@return PlaceHierarchiesOnAxes
   */
  public PlaceHierarchiesOnAxes getHierarchyExtension() {
    return (PlaceHierarchiesOnAxes) olapModel.getExtension(PlaceHierarchiesOnAxes.ID);
  }

  /**
   * Returns the hierarchyItemClickHandler.
   * @@return HierarchyItemClickHandler
   */
  public HierarchyItemClickHandler getHierarchyItemClickHandler() {
    return hierarchyItemClickHandler;
  }

  /**
   * Returns the memberExtension.
   * @@return PlaceMembersOnAxes
   */
  public PlaceMembersOnAxes getMemberExtension() {
    return (PlaceMembersOnAxes) olapModel.getExtension(PlaceMembersOnAxes.ID);
  }

  public MemberDeleter getDeleterExtension() {
    return (MemberDeleter) olapModel.getExtension(MemberDeleter.ID);
  }

  /**
   * Returns the olapModel.
   * @@return OlapModel
   */
  public OlapModel getOlapModel() {
    return olapModel;
  }

  /**
   * Returns the slicerExtension.
   * @@return ChangeSlicer
   */
  public ChangeSlicer getSlicerExtension() {
    return (ChangeSlicer) olapModel.getExtension(ChangeSlicer.ID);
  }

  /**
   * Returns the tempDispatcher.
   * @@return Dispatcher
   */
  Dispatcher getTempDispatcher() {
    return tempDispatcher;
  }

  /**
   * initializes the CategoryModel to reflect the OlapModel
   */
  void initializeCategories() throws OlapException {
    categories.clear();

    Result result = olapModel.getResult();
    Axis[] axes = result.getAxes();
    for (int index = 0; index < axes.length; index++) {
      Axis axis = axes[index];
      String name = resources.getString("axis." + index + ".name");
      String icon = resources.getString("axis." + index + ".icon");
      AxisCategory axisCat = new AxisCategory(this, axis, name, icon);
      categories.add(axisCat);
    }

    // the rest is added to the slicer
    String name = resources.getString("slicer.name");
    String icon = resources.getString("slicer.icon");
    slicerCategory = new SlicerCategory(this, name, icon);
    categories.add(slicerCategory);
  }

  /**
   * true if the user has changed the axis/hierarchy mapping.
   * @@return boolean
   */
  public boolean isEditing() {
    return editing;
  }

  void itemClicked(RequestContext context, HierarchyItem item, MemberSelectionModel selection,
      boolean allowChangeOrder) {
    if (hierarchyItemClickHandler != null)
      hierarchyItemClickHandler.itemClicked(context, item, selection, allowChangeOrder);
  }

  public Element render(RequestContext context, Document factory) throws Exception {
    if (!editing) {
      tempDispatcher.clear();
      initializeCategories();
    }

    Element elem = super.render(context, factory);

    elem.setAttribute("accept-id", acceptButtonId);
    elem.setAttribute("accept-title", resources.getString("accept.title"));
    elem.setAttribute("revert-id", revertButtonId);
    elem.setAttribute("revert-title", resources.getString("revert.title"));
    elem.setAttribute("ok-id", okButtonId);
    elem.setAttribute("ok-title", resources.getString("ok.title"));
    elem.setAttribute("cancel-id", cancelButtonId);
    elem.setAttribute("cancel-title", resources.getString("cancel.title"));

    return elem;
  }

  public void setEditing(boolean editing) {
    this.editing = editing;
  }

  /**
   * Sets the hierarchyItemClickHandler.
   * @@param hierarchyItemClickHandler The hierarchyItemClickHandler to set
   */
  public void setHierarchyItemClickHandler(HierarchyItemClickHandler hierarchyItemClickHandler) {
    this.hierarchyItemClickHandler = hierarchyItemClickHandler;
  }

  public void modelChanged(ModelChangeEvent e) {
    // recreate everything on next render()
    editing = false;
  }

  public void structureChanged(ModelChangeEvent e) {
    logger.info("cleaning up");
    // force reload of members, hierarchies etc
    setEditing(false);
    tempDispatcher.clear();
    categories.clear();
    // invalidate hyperlinks
    categoryModel.fireModelChanged();
  }


  /**
   * finds the HierarchyItem for <code>hier</code>
   * @@param hier the Hierarchy
   * @@return null or the HierarchyItem
   */
  public HierarchyItem findHierarchyItem(Hierarchy hier) {
    for (Iterator ci = categoryModel.getCategories().iterator(); ci.hasNext();) {
      AbstractCategory ac = (AbstractCategory) ci.next();
      for (Iterator ii = ac.getItems().iterator(); ii.hasNext();) {
        HierarchyItem hi = (HierarchyItem) ii.next();
        if (hi.getHierarchy().equals(hier))
          return hi;
      }
    }
    return null;
  }

  public RequestListener getAcceptHandler() {
    return acceptHandler;
  }

  public RequestListener getRevertHandler() {
    return revertHandler;
  }

  /**
   * returns the set of dimensions that are currently on the
   * slicer axis. This includes those dimensions that the
   * user has moved to the slicer in the navigator but not yet
   * committed by pressing the OK button.
   *
   * @@return empty set if this component has not been rendered yet
   */
  public Set getSlicerDimensions() {
    Set set = new HashSet();
    for (Iterator it = slicerCategory.getItems().iterator(); it.hasNext();) {
      HierarchyItem hi = (HierarchyItem) it.next();
      set.add(hi.getHierarchy().getDimension());
    }
    return set;
  }
  
  public Resources getRes() {
    return resources;
  }

  public boolean isAvailable() {
    return getHierarchyExtension() != null;
  }

}@


1.2.2.1
log
@* merged focus changes of jpivot into focus_1_6_0
@
text
@a33 1
import com.tonbeller.jpivot.olap.navi.MdxQuery;
a37 1
import com.tonbeller.jpivot.util.MdxTransformer;
a69 3
  private boolean applyVisualTotalsOnRows = false;
  private boolean applyVisualTotalsOnColumns = false;

a88 22
      String visualTotalsOnRows = context.getParameter(visualTotalsOnRowsId);
      String visualTotalsOnColumns= context.getParameter(visualTotalsOnColumnsId);
      applyVisualTotalsOnRows = resources.getString("visualTotalsOnRows.title").equals(visualTotalsOnRows);
      applyVisualTotalsOnColumns = resources.getString("visualTotalsOnColumns.title").equals(visualTotalsOnColumns);

      String mdxQuery = getMdxQueryExtension().getMdxQuery();
      mdxQueryWithoutVisualTotals = MdxTransformer.applyVisualTotals(mdxQuery, false);

      if(applyVisualTotalsOnRows && applyVisualTotalsOnColumns)
    	  mdxQuery = MdxTransformer.applyVisualTotals(mdxQueryWithoutVisualTotals, true);
      else if(applyVisualTotalsOnRows)
    	  mdxQuery = MdxTransformer.applyVisualTotalsOnAxis(mdxQueryWithoutVisualTotals, MdxTransformer.ROWS);
      else if(applyVisualTotalsOnColumns)
    	  mdxQuery = MdxTransformer.applyVisualTotalsOnAxis(mdxQueryWithoutVisualTotals, MdxTransformer.COLUMNS);
      else
    	  mdxQuery = mdxQueryWithoutVisualTotals;

//      getMondrianModel().setMdxQuery(mdxQuery);
//      getMondrianModel().fireModelChanged();
//      getMondrianModel().initialize();
      getMdxQueryExtension().setMdxQuery(mdxQuery);

a93 4
  public MdxQuery getMdxQueryExtension() {
	return (MdxQuery) olapModel.getExtension(MdxQuery.ID);
  }

a101 2
  private String visualTotalsOnRowsId;
  private String visualTotalsOnColumnsId;
a129 2
    visualTotalsOnRowsId = id + ".visualTotalsOnRows";
    visualTotalsOnColumnsId = id + ".visualTotalsOnColumns";
a237 1
  private String mdxQueryWithoutVisualTotals = null;
d240 1
a240 1
    if (hierarchyItemClickHandler != null) {
a242 5
  }

//  private MondrianModel getMondrianModel() {
//	  return (MondrianModel)olapModel.getRootModel();
//  }
a244 13

	// remove visualTotals
	if(!editing) {
      String mdxQuery = getMdxQueryExtension().getMdxQuery();
      mdxQueryWithoutVisualTotals = MdxTransformer.applyVisualTotals(mdxQuery, false);
      getMdxQueryExtension().setMdxQuery(mdxQueryWithoutVisualTotals);
	}
//    getMondrianModel().setMdxQuery(mdxQueryWithoutVisualTotals);
//    getMondrianModel().fireModelChanged();
//    getMondrianModel().initialize();
		//mondrianModel.fireModelChanged();


a260 9
    elem.setAttribute("visualTotalsOnRows-title", resources.getString("visualTotalsOnRows.title"));
    elem.setAttribute("visualTotalsOnColumns-title", resources.getString("visualTotalsOnColumns.title"));
    elem.setAttribute("visualTotalsOnRows-id", visualTotalsOnRowsId);
    elem.setAttribute("visualTotalsOnColumns-id", visualTotalsOnColumnsId);
    if(applyVisualTotalsOnColumns)
    	elem.setAttribute("visualTotalsOnColumns-checked", "true");
    if (applyVisualTotalsOnRows)
    	elem.setAttribute("visualTotalsOnRows-checked", "true");

@


1.2.2.2
log
@* bug fix for visualTotals on a tuple
@
text
@a66 3
      if((mdxQueryBeforeRender != null) && (!getMdxQueryExtension().getMdxQuery().equals(mdxQueryBeforeRender))) {
    	  getMdxQueryExtension().setMdxQuery(mdxQueryBeforeRender);
      }
d72 3
d100 1
a100 1
      String mdxQueryWithoutVisualTotals = MdxTransformer.applyVisualTotals(mdxQuery, false);
d111 3
a148 4
  private boolean applyVisualTotalsOnRows = false;
  private boolean applyVisualTotalsOnColumns = false;
  private String mdxQueryBeforeRender = null;

d273 1
d281 4
d289 2
a290 3
      mdxQueryBeforeRender = getMdxQueryExtension().getMdxQuery();
      if(mdxQueryBeforeRender.contains("VisualTotals")) {
        String mdxQueryWithoutVisualTotals = MdxTransformer.applyVisualTotals(mdxQueryBeforeRender, false);
d293 5
a297 1
	}
@


1.1
log
@initial version
@
text
@d27 1
a45 1
import com.tonbeller.wcf.selection.SelectionModel;
d238 1
a238 1
  void itemClicked(RequestContext context, HierarchyItem item, SelectionModel selection,
@

