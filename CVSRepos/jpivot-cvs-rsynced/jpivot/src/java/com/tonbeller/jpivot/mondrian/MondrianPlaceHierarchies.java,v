head	1.3;
access;
symbols
	jpivot_1_8_0:1.3
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.2
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.3
date	2007.07.09.16.17.06;	author remberson;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.09.22.24.18;	author jhyde;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.05.14.19.51;	author avix;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Created two JPivot base exception classess, JPivotException and
JPivotRuntimeException, and all JPivot exceptions now have one of
these as parent class. The mondrian JPivot code now gets its
SchemaReader from the MDX query rather than the connection so that
the query's cube's calculated members and the query's defined
"with" members can be displayed.
Also, added new JPivot exception, NoValidMemberException, which is
throw when a query returns no data on one or more axis.
Lastly, cleaned up html generated by 2 transforms.
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 *
 */
package com.tonbeller.jpivot.mondrian;

import java.util.ArrayList;
import java.util.List;

import mondrian.olap.Exp;
import mondrian.olap.Member;
import mondrian.olap.SchemaReader;
import mondrian.olap.Syntax;
import mondrian.mdx.UnresolvedFunCall;
import mondrian.mdx.MemberExpr;

import org.apache.log4j.Logger;

import com.tonbeller.jpivot.core.ExtensionSupport;
import com.tonbeller.jpivot.olap.model.Axis;
import com.tonbeller.jpivot.olap.model.Hierarchy;
import com.tonbeller.jpivot.olap.navi.PlaceHierarchiesOnAxes;
import com.tonbeller.jpivot.olap.query.Quax;

/**
 * generate Mondrian axis according to navigator
 */
public class MondrianPlaceHierarchies extends ExtensionSupport implements PlaceHierarchiesOnAxes {

  private boolean expandAllMember = false;
  ArrayList aMemberSet = null;
  static Logger logger = Logger.getLogger(MondrianPlaceHierarchies.class);

  /**
   * Constructor sets ID
   */
  public MondrianPlaceHierarchies() {
    super.setId(PlaceHierarchiesOnAxes.ID);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.PlaceHierarchiesOnAxes#createMemberExpression(Hierarchy)
   */
  public Object createMemberExpression(Hierarchy hier) {

    mondrian.olap.Hierarchy monHier = ((MondrianHierarchy) hier).getMonHierarchy();

    // if the query does not contain the hier,
    //  just return the highest level
    MondrianModel model = (MondrianModel) getModel();
    MondrianQueryAdapter adapter = (MondrianQueryAdapter) model.getQueryAdapter();

    // find the Quax for this hier
    Quax quax = adapter.findQuax(hier.getDimension());
    if (quax == null) {
      // the hierarchy was not found on any axis

      SchemaReader scr = model.getSchemaReader();

      return MondrianUtil.topLevelMembers(monHier, expandAllMember, scr);
      // return top level members of the hierarchy
    }

    // the member expression is the list of members plus the list of FunCalls
    //  for this dimension
    int iDimension = quax.dimIdx(hier.getDimension());
    return quax.genExpForDim(iDimension);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.PlaceHierarchiesOnAxes#setQueryAxis(Axis, Object[])
   */
  public void setQueryAxis(Axis target, Object[] memberExpressions) {

    MondrianModel model = (MondrianModel) getModel();
    MondrianQueryAdapter adapter = (MondrianQueryAdapter) model.getQueryAdapter();

    // locate the appropriate query axis
    int iQuax = ((MondrianAxis) target).getOrdinal();
    if (adapter.isSwapAxes())
      iQuax = (iQuax + 1) % 2;
    Quax quax = adapter.getQuaxes()[iQuax];

    int nDimension = 0;
    for (int i = 0; i < memberExpressions.length; i++) {
      if (memberExpressions[i] != null)
        ++nDimension;
    }

    // if any of the member expressions is a memberlist from PlaceMembers
    //  we will have to reset sorting
    Object[] sets = new Object[nDimension];
    boolean changedMemberSet = false;
    int j = 0;
    for (int i = 0; i < memberExpressions.length; i++) {
      // null possible due to access control
      if (memberExpressions[i] instanceof List) {
        List memberList = (List) memberExpressions[i];
        Exp[] members = new Exp[memberList.size()];
        for (int k = 0; k < members.length; k++) {
            members[k] = new MemberExpr((Member) memberList.get(k));
        }
        if (members.length == 1)
          sets[j++] = members[0];
        else
          sets[j++] = new UnresolvedFunCall("{}", Syntax.Braces, members);
        changedMemberSet = true;
      } else if (memberExpressions[i] != null) {
        // object generated by createMemberExpression or CalcSet.createAxisExpression
        sets[j++] = memberExpressions[i];
      }
    }

    // generate the crossjoins
    quax.regeneratePosTree(sets, true);

    if (logger.isInfoEnabled()) {
      String changed = "";
      if (changedMemberSet)
        changed = " changed by navi";
      logger.info("setQueryAxis axis=" + quax.getOrdinal() + " nDimension=" + nDimension + changed);
      logger.info("Expression for Axis=" + quax.toString());
    }

    // tell listeners, that the axis was changed.
    quax.changed(this, changedMemberSet);

    model.fireModelChanged();
  }

  /**
   * @@see PlaceHierarchiesOnAxes#setExpandAllMember
   */
  public void setExpandAllMember(boolean expandAllMember) {
    this.expandAllMember = expandAllMember;
  }

  /**
   * @@see PlaceHierarchiesOnAxes#getExpandAllMember
   */
  public boolean getExpandAllMember() {
    return expandAllMember;
  }

} // End MondrianPlaceHierarchies
@


1.2
log
@Match Mondrian API updates for compiled expressions (up to change 4994)
@
text
@d65 3
a67 1
      SchemaReader scr = ((MondrianModel) getModel()).getMonConnection().getSchemaReader();
@


1.1
log
@initial version
@
text
@d11 1
a11 1
 * 
d19 1
a19 1
import mondrian.olap.FunCall;
d22 2
d60 1
a60 1
 
d71 1
a71 1
    //  for this dimension 
d105 4
a108 1
        Exp[] members = (Exp[]) memberList.toArray(new Exp[0]);
d112 1
a112 1
          sets[j++] = new FunCall("{}", Syntax.Braces, members);
d138 1
a138 1
   * @@see PlaceHierarchiesOnAxes.setExpandAllMember
d145 1
a145 1
   * @@see PlaceHierarchiesOnAxes.getExpandAllMember
@

