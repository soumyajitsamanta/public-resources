head	1.1;
access;
symbols
	focus_1_6_0:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2008.04.17.10.44.20;	author hbaier;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2008.04.17.10.44.22;	author hbaier;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file ColorTreeModel.java was initially added on branch focus_1_6_0.
@
text
@@


1.1.2.1
log
@* merged focus changes of jpivot into focus_1_6_0
@
text
@a0 236
package com.tonbeller.jpivot.chart;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.apache.log4j.Logger;

import com.tonbeller.wcf.changeorder.ChangeOrderModel;
import com.tonbeller.wcf.changeorder.ChangeOrderUtils;
import com.tonbeller.wcf.tree.AbstractTreeModel;
import com.tonbeller.wcf.tree.DeleteNodeModel;
import com.tonbeller.wcf.tree.MutableTreeModel;
import com.tonbeller.wcf.tree.TreeModelChangeListener;
import com.tonbeller.wcf.tree.TreeModelChangeSupport;

public class ColorTreeModel extends AbstractTreeModel implements MutableTreeModel, ChangeOrderModel, DeleteNodeModel {

	private static final Logger logger = Logger.getLogger(ColorTreeModel.class);

	private String[] colors;

	Node[] roots;

	public ColorTreeModel() {
		this(new String[] {});
	}

	public String[] getColors() {
		return this.colors;
	}

	public ColorTreeModel(String[] colors) {
		this.colors = colors;
		roots = new Node[1];
		roots[0] = new Node(null, "Color List: ", 1);
		changeSupport = new TreeModelChangeSupport(this);
		childrenMap = new TreeMap();
		parentMap = new TreeMap();
	}

	public class Node{

		Node parent;

		String name;

		String color;

		int level;

		Node[] children;

		public String getColor() {
			return color;
		}

		public void setColor(String color) {
			this.color = color;
		}

		public Node(Node parent, String name, int level) {
			this.parent = parent;
			this.name = name;
			this.level = level;
			if (level < 2) {
				children = new Node[colors.length];
				for (int i = 0; i < children.length; i++) {
					children[i] = new Node(this, colors[i], level + 1);
					children[i].color = colors[i];
				}
			}
		}

		boolean hasChildren() {
			return children != null;
		}

		Object[] getChildren() {
			return children;
		}

		public int getLevel() {
			return level;
		}

		public String getName() {
			return name;
		}

		public void setLevel(int level) {
			this.level = level;
		}

		public void setName(String name) {
			this.name = name;
		}

		public Node getParent() {
			return parent;
		}

		public void setParent(Node parent) {
			this.parent = parent;
		}

		public String toString() {
			return name;
		}

		public void addColor(String color) {
			int newLength = children.length + 1;
			Node[] newChildren = new Node[newLength];
			for (int i = 0; i < children.length; i++) {
				newChildren[i] = children[i];
			}
			newChildren[newLength - 1] = new Node(this, color, 2);
			newChildren[newLength - 1].setColor(color);
			this.children = newChildren;

			logger.info("Node.addColor()");
			logger.info("children length: " + this.children.length);
		}

		public void clearChildren() {
			this.children = new Node[0];
		}

	}

	public Object[] getRoots() {
		logger.info("getRoots");
		return roots;
	}

	public boolean hasChildren(Object node) {
		logger.info("hasChildren: " + node);
		return ((Node) node).hasChildren();
	}

	public Object[] getChildren(Object node) {
		logger.info("getChildren: " + node);
		return ((Node) node).getChildren();
	}

	public Object getParent(Object node) {
		logger.info("getParent: " + node);
		return ((Node) node).getParent();
	}

	/**
	 * contains parent/child relationship, key = parent / Object, value =
	 * children / Object[]
	 */
	Map childrenMap;

	/**
	 * contains child/parent relationship, key = child / Object, value = parent /
	 * Object
	 */
	Map parentMap;

	/** support for ChangeOrderModel */
	boolean enableChangeOrder = true;

	TreeModelChangeSupport changeSupport;

	public void change(Object parent, Object[] children) {
		changeSupport.fireModelChanged(false, parent);
	}

	public boolean mayMove(Object scope, Object node) {
		return enableChangeOrder;
	}

	public void move(Object scope, Object node, int oldIndex, int newIndex) {
		Object parent = getParent(node);
		Object[] children;
		if (parent == null)
			children = getRoots();
		else
			children = getChildren(parent);
		// change order
		ChangeOrderUtils.move(children, oldIndex, newIndex);
		// save changes
		change(parent, children);
	}

	/**
	 * if enabled, changeOrder will be allowed
	 *
	 * @@return boolean
	 */
	public boolean isEnableChangeOrder() {
		return enableChangeOrder;
	}

	/**
	 * if enabled, changeOrder will be allowed
	 *
	 * @@param enableChangeOrder
	 *            The enableChangeOrder to set
	 */
	public void setEnableChangeOrder(boolean enableChangeOrder) {
		this.enableChangeOrder = enableChangeOrder;
	}

	public void fireModelChanged(boolean identityChanged) {
		changeSupport.fireModelChanged(identityChanged);
	}

	public void addTreeModelChangeListener(TreeModelChangeListener l) {
		changeSupport.addTreeModelChangeListener(l);
	}

	public void removeTreeModelChangeListener(TreeModelChangeListener l) {
		changeSupport.removeTreeModelChangeListener(l);
	}

	public void delete(Object node) {
		deleted.add(node);
		fireModelChanged(false);
	}

	Set deleted = new HashSet();

	public Set getDeleted() {
		return deleted;
	}

	public boolean isDeletable(Object node) {
		return !node.toString().startsWith("Color");
	}

}
@

