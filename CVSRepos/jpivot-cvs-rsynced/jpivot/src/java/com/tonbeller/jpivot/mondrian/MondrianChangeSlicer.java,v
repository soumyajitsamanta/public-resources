head	1.6;
access;
symbols
	jpivot_1_8_0:1.3
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.3
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.6
date	2010.07.23.07.37.28;	author uramisten;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.21.15.16.44;	author willgorman;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.02.19.44.12;	author willgorman;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.15.03.59.10;	author jhyde;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.09.22.24.18;	author jhyde;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.05.14.19.51;	author avix;	state Exp;
branches;
next	;


desc
@@


1.6
log
@mostly formatting, but a couple changed in MondrianMemberTree
--> maintain ordering of elements in navigation.  If you move items around, currently they just get reset to their original positions if you reopen the navigator.  Also, support added for calculated members not in the root of a dimension -> linked to a development for mondrian/schema allowing specification of "parentMember" in xml definition of calculated member.  This has been possible in MDX, but the schema and jpivot did not support it.   The saved sort order feature could be changed to be turned on/off by a parameter file (e.g.) if users would like to be able to keep the old results.
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 *
 */
package com.tonbeller.jpivot.mondrian;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import mondrian.olap.AxisOrdinal;
import mondrian.olap.Exp;
import mondrian.olap.QueryAxis;
import mondrian.olap.Syntax;
import mondrian.olap.AxisOrdinal;
import mondrian.mdx.UnresolvedFunCall;
import mondrian.mdx.MemberExpr;

import org.apache.log4j.Logger;

import com.tonbeller.jpivot.core.ExtensionSupport;
import com.tonbeller.jpivot.olap.model.Axis;
import com.tonbeller.jpivot.olap.model.Member;
import com.tonbeller.jpivot.olap.model.OlapException;
import com.tonbeller.jpivot.olap.model.Position;
import com.tonbeller.jpivot.olap.model.Result;
import com.tonbeller.jpivot.olap.navi.ChangeSlicer;

/**
 * @@author hh
 */
public class MondrianChangeSlicer extends ExtensionSupport implements ChangeSlicer {

  static Logger logger = Logger.getLogger(MondrianChangeSlicer.class);

  /**
   * Constructor sets ID
   */
  public MondrianChangeSlicer() {
    super.setId(ChangeSlicer.ID);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.ChangeSlicer#getSlicer()
   */
  public Member[] getSlicer() {

    MondrianModel model = (MondrianModel) getModel();
    // use result rather than query
    Result res = null;
    try {
      res = model.getResult();
    } catch (OlapException ex) {
      // do not handle
      return new Member[0];
    }

    Axis slicer = res.getSlicer();
    List positions = slicer.getPositions();
    List members = new ArrayList();
    for (Iterator iter = positions.iterator(); iter.hasNext();) {
      Position pos = (Position) iter.next();
      Member[] posMembers = pos.getMembers();
      for (int i = 0; i < posMembers.length; i++) {
        if (!members.contains(posMembers[i]))
          members.add(posMembers[i]);
      }
    }

    return (Member[]) members.toArray(new Member[0]);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.ChangeSlicer#setSlicer(Member[])
   */
  public void setSlicer(Member[] members) {
    MondrianModel model = (MondrianModel) getModel();
    MondrianQueryAdapter adapter = (MondrianQueryAdapter) model.getQueryAdapter();
    mondrian.olap.Query monQuery = adapter.getMonQuery();

    boolean logInfo = logger.isInfoEnabled();

    if (members.length == 0) {
      // empty slicer
      monQuery.setSlicerAxis(null);
      if (logInfo)
        logger.info("slicer set to null");
    } else {
	      ArrayList collectedMemberExpressions = new ArrayList();
	      ArrayList conditions = new ArrayList();
	      String prevHierarchyName = ""; 
	      String hierarchyName = ""; 
	      String mbrUniqueName = "";
	      UnresolvedFunCall f = null;
	      boolean firstCondition = true;
	      for (int i = 0; i < members.length; i++) {
	    	  mbrUniqueName = ((MondrianMember) members[i]).getUniqueName();
	    	  hierarchyName = mbrUniqueName.substring(1, mbrUniqueName.indexOf("]"));
	    	  if (!hierarchyName.equals(prevHierarchyName)) {
	    		  if(collectedMemberExpressions.size()>0) {
	    			  if (firstCondition) {
	    				  f = new UnresolvedFunCall("{}", Syntax.Braces, (Exp[])collectedMemberExpressions.toArray(new Exp[collectedMemberExpressions.size()]));
	    			  } else {
	    				  conditions.add(new UnresolvedFunCall("{}", Syntax.Braces, (Exp[])collectedMemberExpressions.toArray(new Exp[collectedMemberExpressions.size()])));
	    				  f = new UnresolvedFunCall("CrossJoin", Syntax.Function, (Exp[])conditions.toArray(new Exp[conditions.size()]));
	    				  conditions.clear();
	    			  }
	   				  conditions.add(f);
	   				  firstCondition = false;
	    			  if (logInfo) logger.info("Added a new filter condition for Hierarchy: " + prevHierarchyName + ", Conditions number: " + collectedMemberExpressions.size());
	        		  collectedMemberExpressions.clear();
	        		  if (logInfo) logger.info("Clear conditions list. Size = " + collectedMemberExpressions.size());
	    		  }
	    		  prevHierarchyName = hierarchyName;
	    		  if (logInfo) logger.info("Collecting filters on member: " + hierarchyName);
	    	  }
	        collectedMemberExpressions.add(createExpressionFor(monQuery, (MondrianMember) members[i]));
	      }
	      
	      // Add lastly collected member to filters conditions list
		  if(collectedMemberExpressions.size()>0) {
			  conditions.add(new UnresolvedFunCall("{}", Syntax.Braces, (Exp[])collectedMemberExpressions.toArray(new Exp[collectedMemberExpressions.size()])));
			  if (logInfo) logger.info("Added a new filter condition for Hierarchy: " + hierarchyName);
		  }
	      
	      if (conditions.size() == 1) 
	    	  monQuery.setSlicerAxis(new QueryAxis(false, (Exp)conditions.get(0), AxisOrdinal.StandardAxisOrdinal.SLICER, QueryAxis.SubtotalVisibility.Undefined));
	      else {
	    	  // SeraSoft - More dimensions selected. Build a CrossJoin function
	    	  UnresolvedFunCall intersectConditions = new UnresolvedFunCall("Crossjoin", Syntax.Function, (Exp[])conditions.toArray(new Exp[conditions.size()]));
	    	  monQuery.setSlicerAxis(new QueryAxis(false, intersectConditions, AxisOrdinal.StandardAxisOrdinal.SLICER, QueryAxis.SubtotalVisibility.Undefined));
	    	  
	      }
	    }
	    model.fireModelChanged();
	  }

  protected Exp createExpressionFor(mondrian.olap.Query monQuery, MondrianMember member) {
    return new MemberExpr(member.getMonMember());
  }

} // End MondrianChangeSlicer
@


1.5
log
@Incorporating community contribution from Sergio Ramazzina, Now that Mondrian allows multiple members in the slicer, updated JPivot to allow multiple member selection. see http://jira.pentaho.com/browse/BISERVER-3875 for more information.
@
text
@d85 3
a87 5
	    MondrianModel model = (MondrianModel) getModel();
	    MondrianQueryAdapter adapter = (MondrianQueryAdapter) model.getQueryAdapter();
	    mondrian.olap.Query monQuery = adapter.getMonQuery();
	    
	    boolean logInfo = logger.isInfoEnabled();
d89 8
a96 6
	    if (members.length == 0) {
	      // empty slicer
	      monQuery.setSlicerAxis(null);
	      if (logInfo)
	        logger.info("slicer set to null");
	    } else {
@


1.4
log
@updated trunk to reflect recent api changes in mondrian, in the AxisOrdinal interface.
@
text
@d19 1
d23 1
a23 1
import mondrian.olap.AxisOrdinal.StandardAxisOrdinal;
d85 60
a144 32
    MondrianModel model = (MondrianModel) getModel();
    MondrianQueryAdapter adapter = (MondrianQueryAdapter) model.getQueryAdapter();
    mondrian.olap.Query monQuery = adapter.getMonQuery();

    boolean logInfo = logger.isInfoEnabled();

    if (members.length == 0) {
      // empty slicer
      monQuery.setSlicerAxis(null);
      if (logInfo)
        logger.info("slicer set to null");
    } else {
      Exp[] monExpr = new Exp[members.length];
      for (int i = 0; i < monExpr.length; i++) {
        monExpr[i] = createExpressionFor(monQuery, (MondrianMember) members[i]);
      }

      UnresolvedFunCall f = new UnresolvedFunCall("()", Syntax.Parentheses, monExpr);
      monQuery.setSlicerAxis(new QueryAxis(false, f, StandardAxisOrdinal.SLICER, QueryAxis.SubtotalVisibility.Undefined));
      if (logInfo) {
        StringBuffer sb = new StringBuffer("slicer=(");
        for (int i = 0; i < monExpr.length; i++) {
          if (i > 0)
            sb.append(",");
          sb.append(monExpr[i].toString());
        }
        sb.append(")");
        logger.info(sb.toString());
      }
    }
    model.fireModelChanged();
  }
@


1.3
log
@Checkin mondrian.jar as of perforce change 8356, and update jpivot source code for recent API changes. Note that mondrian.jar is built using JDK 1.5 (previously JDK 1.4).
@
text
@a18 1
import mondrian.olap.AxisOrdinal;
d22 1
d102 1
a102 1
      monQuery.setSlicerAxis(new QueryAxis(false, f, AxisOrdinal.SLICER, QueryAxis.SubtotalVisibility.Undefined));
@


1.2
log
@Match Mondrian API updates for compiled expressions (up to change 4994)
@
text
@d102 1
a102 1
      monQuery.setSlicerAxis(new QueryAxis(false, f, AxisOrdinal.Slicer, QueryAxis.SubtotalVisibility.Undefined));
@


1.1
log
@initial version
@
text
@d11 1
a11 1
 * 
d19 1
d21 1
a21 1
import mondrian.olap.FunCall;
d23 2
d92 1
a92 1
      monQuery.setSlicer(null);
d101 2
a102 2
      FunCall f = new FunCall("()", Syntax.Parentheses, monExpr);
      monQuery.setSlicer(f);
d118 1
a118 1
    return member.getMonMember();
@

