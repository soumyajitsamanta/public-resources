head	1.11;
access;
symbols
	jpivot_1_8_0:1.9
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.4
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.11
date	2011.12.28.17.08.17;	author willgorman;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.02.19.44.12;	author willgorman;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.11.16.57.40;	author avix;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.11.14.18.18;	author avix;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.09.16.17.06;	author remberson;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.14.08.54.14;	author avix;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.09.09.59.19;	author avix;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.05.21.31.50;	author remberson;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.15.03.59.10;	author jhyde;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.09.22.24.18;	author jhyde;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.05.14.19.51;	author avix;	state Exp;
branches;
next	;


desc
@@


1.11
log
@BISERVER-6742 - fix to get jpivot working with Mondrian 3.3
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 *
 */
package com.tonbeller.jpivot.mondrian;

import java.util.Iterator;
import java.util.List;

import mondrian.olap.*;
import mondrian.olap.AxisOrdinal.StandardAxisOrdinal;
import mondrian.mdx.MemberExpr;
import mondrian.mdx.UnresolvedFunCall;

import org.apache.log4j.Logger;

import com.tonbeller.jpivot.olap.model.Dimension;
import com.tonbeller.jpivot.olap.model.Hierarchy;
import com.tonbeller.jpivot.olap.model.Member;
import com.tonbeller.jpivot.olap.query.Quax;
import com.tonbeller.jpivot.olap.query.QuaxChangeListener;
import com.tonbeller.jpivot.olap.query.QueryAdapter;

/**
 * Adapt the Mondrian Query Object to the JPivot System.
 */
public class MondrianQueryAdapter extends QueryAdapter implements QuaxChangeListener {

  static Logger logger = Logger.getLogger(MondrianQueryAdapter.class);

  private String originalMDX;
  private Query monQuery = null; // query object representing the current MDX
  private Query cloneQuery = null; // query object representing the original MDX
  private int nAxes; // number of axes

  private final SchemaReader scr;

  /**
   * Constructor
   */
  MondrianQueryAdapter(MondrianModel model, mondrian.olap.Query monQuery) {
    super(model);
    this.monQuery = monQuery;
    scr = monQuery.getSchemaReader(true).withLocus();

    genMDXHierarchize = true; // Result hierarchize cannot be used

    // initialize the query axis state objects
    nAxes = monQuery.getAxes().length;
    quaxes = new MondrianQuax[nAxes];
    for (int i = 0; i < monQuery.getAxes().length; i++) {
      mondrian.olap.Hierarchy[] monHiers = monQuery.getMdxHierarchiesOnAxis(
        StandardAxisOrdinal.forLogicalOrdinal(i));
      monHiers = MondrianUtil.removeNull(monHiers);
      quaxes[i] = new MondrianQuax(i, monQuery.getAxes()[i], model);
      Hierarchy[] hiers = new Hierarchy[monHiers.length];
      for (int j = 0; j < hiers.length; j++) {
        if (monHiers[j] != null) {
          hiers[j] = model.lookupHierarchy(monHiers[j].getUniqueName());
        }
      }
      quaxes[i].setHiers(hiers);
      quaxes[i].addChangeListener(this);
    }
  }
  public SchemaReader getSchemaReader() {
    return scr;
  }

  /**
   * implement MondrianQuaxChangeListener
   */
  public void quaxChanged(Quax quax, Object source, boolean changedByNavi) {
    useQuax = true;
  }

  /**
   * Returns the monQuery.
   * @@return Query
   */
  public Query getMonQuery() {

    if (monQuery != null)
      return monQuery;

    try {
      logger.warn("NOT EXPECTED getMonQuery calling parseQuery");
      MondrianModel mmodel = (MondrianModel) model;
      monQuery = mmodel.getConnection().parseQuery(mmodel.getMdxQuery());
    } catch (Exception ex) {
      // we should never get here
      logger.fatal("getMonQuery parse error", ex);
    }
    return monQuery;
  }

  /**
   * set the monQuery, used for restore
   */
  public void setMonQuery(Query q) {
    this.monQuery = q;
  }

  /**
   * Update the Mondrian Query before Execute.
   * The current query is build from
   * - the original query
   * - adding the drilldown groups
   * - apply pending swap axes
   * - apply pending sorts.
   *
   * Called from MondrianModel.getResult before the query is executed.
   */
  protected void onExecute() {

    // if quax is to be used, generate axes from quax
    if (useQuax) {
      int iQuaxToSort = -1;
      if (sortMan != null)
        iQuaxToSort = sortMan.activeQuaxToSort();

      for (int i = 0; i < quaxes.length; i++) {
        if (quaxes[i].getPosTreeRoot() == null)
          continue;
        boolean doHierarchize = false;
        if (genMDXHierarchize && quaxes[i].isHierarchizeNeeded() && i != iQuaxToSort) {
          doHierarchize = true;
          if (logger.isDebugEnabled())
            logger.debug("MDX Generation added Hierarchize()");
        }

        monQuery.getAxes()[iASwap(i)].setSet((Exp) quaxes[i].genExp(doHierarchize));
      } // for quaxes
    }

    // generate order function if neccessary
    if (sortMan != null) {
      if (!useQuax) {
        // if Quax is used, the axis exp's are re-generated every time.
        // if not -
        //    adding a sort to the query must not be permanent.
        //    Therefore, we clone the orig state of the query object and use
        //    the clone furthermore in order to avoid duplicate "Order" functions.
        if (cloneQuery == null) {
          if (sortMan.isSortOnQuery())
            cloneQuery = monQuery.safeClone();
        } else {
          // reset to original state
          if (sortMan.isSortOnQuery())
            monQuery = cloneQuery.safeClone();
          else
            monQuery = cloneQuery;
        }
      }
      sortMan.addSortToQuery();
    }

    long t1 = System.currentTimeMillis();
    String mdx = monQuery.toString();
    long t2 = System.currentTimeMillis();
    logger.info("monQuery.toString took " + (t2 - t1) + " millisec");
    ((MondrianModel) model).setCurrentMdx(mdx);

    if (logger.isDebugEnabled())
      logger.debug(mdx);

  }

  /**
   * return the corresponding mdx
   */
  protected String getCurrentMdx() {

    String mdx = monQuery.toString();
    return mdx;
  }

  /**
   * create set expression for list of members
   * @@param memList
   * @@return set expression
   */
  protected Object createMemberSet(List memList) {
    Exp[] exps = new Exp[memList.size()];
    int i = 0;
    for (Iterator iter = memList.iterator(); iter.hasNext();) {
      MondrianMember m = (MondrianMember) iter.next();
      exps[i++] = new MemberExpr(m.getMonMember());
    }
    UnresolvedFunCall f = new UnresolvedFunCall("{}", Syntax.Braces, exps);
    return f;
  }

  // ***************
  // Expand Collapse
  // ***************

  /**
   * find out, whether a member can be expanded.
   * this is true, if
   * - the member is on an axis  and
   * - the member is not yet expanded  and
   * - the member has children
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpandMember#canExpand(Member)
   * @@param member to be expanded
   * @@return true if the member can be expanded
   */
  public boolean canExpand(Member member) {
    mondrian.olap.Member monMember = ((MondrianMember) member).getMonMember();
    // a calculated member cannot be expanded
    if (monMember.isCalculatedInQuery())
      return false;

    if (!scr.isDrillable(monMember))
      return false;

    Dimension dim = member.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);
    return (quax == null) ? false : quax.canExpand(member);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpandMember#canExpand(Member)
   * @@param position position to be expanded
   * @@param Member to be expanded
   * @@return true if the member can be expanded
   */
  public boolean canExpand(Member[] pathMembers) {

    MondrianMember m = (MondrianMember) pathMembers[pathMembers.length - 1];
    mondrian.olap.Member monMember = m.getMonMember();
    // a calculated member cannot be expanded
    if (monMember.isCalculatedInQuery())
      return false;

    if (!scr.isDrillable(monMember))
      return false;

    Dimension dim = m.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);
    return (quax == null) ? false : quax.canExpand(pathMembers);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpandMember#canCollapse(Member)
   * @@param member Member to be collapsed
   * @@return true if the member can be collapsed
   */
  public boolean canCollapse(Member member) {

    // a calculated member cannot be collapsed
    if (((MondrianMember) member).getMonMember().isCalculatedInQuery())
      return false;
    Dimension dim = member.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);
    return (quax == null) ? false : quax.canCollapse(member);
  }

  /**
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpandMember#canCollapse(Member)
   * @@param position position to be expanded
   * @@return true if the position can be collapsed
   */
  public boolean canCollapse(Member[] pathMembers) {

    Member member = pathMembers[pathMembers.length - 1];
    // a calculated member cannot be collapsed
    if (((MondrianMember) member).getMonMember().isCalculatedInQuery())
      return false;
    Dimension dim = member.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);
    return (quax == null) ? false : quax.canCollapse(pathMembers);
  }

  /**
   * expand a member in all positions
   *  this is done by applying ToggleDrillState to the Query
   *
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#expand(Member)
   * @@param Member member to be expanded
   */
  public void expand(Member member) {
    Dimension dim = member.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);

    if (logger.isInfoEnabled())
      logger.info("expand Member" + poString(null, member));
    if ((quax == null) || !quax.canExpand(member)) {
      logger.fatal("Expand Member failed for " + ((MondrianMember) member).getUniqueName());
      //throw new java.lang.IllegalArgumentException("cannot expand");
      return;
    }
    quax.expand(member);
    model.fireModelChanged();
  }

  /**
   * expand a member in a specific position
   *
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#expand(Member)
   * @@param position position to be expanded
   * @@param Member member to be expanded
   */
  public void expand(Member[] pathMembers) {

    MondrianMember m = (MondrianMember) pathMembers[pathMembers.length - 1];
    Dimension dim = m.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);

    if (logger.isDebugEnabled())
      logger.info("expand Path" + poString(pathMembers, null));
    if ((quax == null) || !quax.canExpand(pathMembers)) {
      logger.fatal("Expand failed for" + poString(pathMembers, null));
      throw new java.lang.IllegalArgumentException("cannot expand");
    }

    quax.expand(pathMembers);
    model.fireModelChanged();
  }

  // ************
  // DrillReplace
  // ************

  /**
   * drill down is possible if <code>member</code> has children
   */
  public boolean canDrillDown(Member member) {
    mondrian.olap.Member monMember = ((MondrianMember) member).getMonMember();
    if (!scr.isDrillable(monMember))
      return false;
    Dimension dim = member.getLevel().getHierarchy().getDimension();
    Quax quax = findQuax(dim);
    return (quax == null) ? false : quax.canDrillDown(member);
  }

  // *********
  // Swap Axes
  // *********

  /**
   * swap axes
   *  toggle swap state if neccessary
   */
  public void setSwapAxes(boolean swap) {
    if (monQuery.getAxes().length != 2)
      return;
    // swap axes if neccessary
    if (swap != axesSwapped) {
      monQuery.swapAxes();
      axesSwapped = swap;
      if (logger.isInfoEnabled()) {
        logger.info("swapAxes " + axesSwapped);
      }
      model.fireModelChanged();
    }
  }

} // End MondrianQueryAdapter
@


1.10
log
@updated trunk to reflect recent api changes in mondrian, in the AxisOrdinal interface.
@
text
@d52 1
a52 1
    scr = monQuery.getSchemaReader(true);
@


1.9
log
@fix bug [ 1889653 ] NullPointerException when using functions
@
text
@d19 1
d61 1
a61 1
        AxisOrdinal.forLogicalOrdinal(i));
@


1.8
log
@fix bug [ 1889653 ] NullPointerException when using functions
@
text
@d61 1
@


1.7
log
@Created two JPivot base exception classess, JPivotException and
JPivotRuntimeException, and all JPivot exceptions now have one of
these as parent class. The mondrian JPivot code now gets its
SchemaReader from the MDX query rather than the connection so that
the query's cube's calculated members and the query's defined
"with" members can be displayed.
Also, added new JPivot exception, NoValidMemberException, which is
throw when a query returns no data on one or more axis.
Lastly, cleaned up html generated by 2 transforms.
@
text
@d64 3
a66 1
        hiers[j] = model.lookupHierarchy(monHiers[j].getUniqueName());
@


1.6
log
@reverted previous change because it requires further synchronization with tonbeller repository (which I dont have the time for right now).
@
text
@d51 1
a51 1
    scr = model.getMonConnection().getSchemaReader();
d70 3
d161 1
a161 1
 
d223 1
a223 4
    if ( quax == null )
      return false; // not found on any axis
 
    return quax.canExpand(member);
d245 1
a245 3
    if ( quax == null )
      return false; // not found on any axis
    return quax.canExpand(pathMembers);
d260 1
a260 4
    if ( quax == null )
      return false; // not found on any axis
 
    return quax.canCollapse(member);
d276 1
a276 4
    if ( quax == null )
      return false; // not found on any axis
 
    return quax.canCollapse(pathMembers);
d338 1
a338 4
    if ( quax == null )
      return false; // not found on any axis
 
    return quax.canDrillDown(member);
@


1.5
log
@Test for conflicting changes in sourceforge/tonbeller CVS
@
text
@d138 20
a157 1
    sortOnExecute();
@


1.4
log
@When there is no data and thus no metadata, the method
QueryAdaptor.findQuax() returns a null, but the calling
code does not check for null.
@
text
@d138 2
a139 21
    if (sortMan != null) {
      if (!useQuax) {
        // if Quax is used, the axis exp's are re-generated every time.
        // if not -
        //    adding a sort to the query must not be permanent.
        //    Therefore, we clone the orig state of the query object and use
        //    the clone furthermore in order to avoid duplicate "Order" functions.
        if (cloneQuery == null) {
          if (sortMan.isSortOnQuery())
            cloneQuery = monQuery.safeClone();
        } else {
          // reset to original state
          if (sortMan.isSortOnQuery())
            monQuery = cloneQuery.safeClone();
          else
            monQuery = cloneQuery;
        }
      }
      sortMan.addSortToQuery();
    }

d201 4
a204 1
    return (quax == null) ? false : quax.canExpand(member);
d226 3
a228 1
    return (quax == null) ? false : quax.canExpand(pathMembers);
d243 4
a246 1
    return (quax == null) ? false : quax.canCollapse(member);
d262 4
a265 1
    return (quax == null) ? false : quax.canCollapse(pathMembers);
d327 4
a330 1
    return (quax == null) ? false : quax.canDrillDown(member);
@


1.3
log
@Checkin mondrian.jar as of perforce change 8356, and update jpivot source code for recent API changes. Note that mondrian.jar is built using JDK 1.5 (previously JDK 1.4).
@
text
@d220 1
a220 1
    return quax.canExpand(member);
d242 1
a242 1
    return quax.canExpand(pathMembers);
d257 1
a257 2

    return quax.canCollapse(member);
d273 1
a273 2

    return quax.canCollapse(pathMembers);
d289 2
a290 2
    if (!quax.canExpand(member)) {
      logger.fatal("Expand Member failed for" + ((MondrianMember) member).getUniqueName());
d313 1
a313 1
    if (!quax.canExpand(pathMembers)) {
d335 1
a335 1
    return quax.canDrillDown(member);
@


1.2
log
@Match Mondrian API updates for compiled expressions (up to change 4994)
@
text
@d18 1
a18 5
import mondrian.olap.Exp;
import mondrian.olap.FunCall;
import mondrian.olap.Query;
import mondrian.olap.SchemaReader;
import mondrian.olap.Syntax;
d59 2
a60 1
      mondrian.olap.Hierarchy[] monHiers = monQuery.getMdxHierarchiesOnAxis(i);
d205 2
a206 2
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#canExpand(Member)
   * @@param Member to be expanded
d224 1
a224 1
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#canExpand(Member)
d246 2
a247 2
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#canExpand(Member)
   * @@param Member to be collapsed
d262 1
a262 1
   * @@see com.tonbeller.jpivot.olap.navi.DrillExpand#canCollapse(Member)
@


1.1
log
@initial version
@
text
@d11 1
a11 1
 * 
d23 2
d107 1
a107 1
  
d112 1
a112 1
   * - adding the drilldown groups 
d116 1
a116 1
   * Called from MondrianModel.getResult before the query is executed. 
d144 1
a144 1
        // if not - 
d183 1
a183 1
   * create set expression for list of members 
d185 1
a185 1
   * @@return set expression 
d192 1
a192 1
      exps[i++] = m.getMonMember();
d194 1
a194 1
    FunCall f = new FunCall("{}", Syntax.Braces, exps);
d204 1
a204 1
   * this is true, if 
d284 1
a284 1
   * 
d305 1
a305 1
   * 
@

