head	1.8;
access;
symbols
	jpivot_1_8_0:1.8
	focus_1_6_0:1.1.0.6
	jpivot_1_7_0:1.3
	jpivot_1_6_0:1.1
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.1;
locks; strict;
comment	@# @;
expand	@k@;


1.8
date	2008.03.17.14.03.09;	author avix;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.09.16.17.06;	author remberson;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.03.18.46.17;	author remberson;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.26.18.02.40;	author remberson;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.24.19.04.36;	author remberson;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.21.13.38.03;	author remberson;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.19.15.00.32;	author remberson;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.05.14.19.51;	author avix;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[ 1889716 ] JUnit Test EmptyResultTest fails
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 * 
 */
package com.tonbeller.jpivot.mondrian;

import org.apache.log4j.Logger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.tonbeller.jpivot.olap.model.Axis;
import com.tonbeller.jpivot.olap.model.impl.FormatStringParser;
import com.tonbeller.jpivot.olap.query.ResultBase;
import mondrian.olap.Position;
import mondrian.olap.Query;
import mondrian.olap.Member;
import mondrian.olap.ResultLimitExceededException;
import mondrian.olap.ResourceLimitExceededException;

/**
 * Result implementation for Mondrian
 */
public class MondrianResult extends ResultBase {
  static Logger logger = Logger.getLogger(MondrianResult.class);


  private mondrian.olap.Result monResult = null;
  private int[] posize;
  private FormatStringParser formatStringParser = new FormatStringParser();

  /**
   * Constructor
   * @@param model the associated MondrianModel
   */
  protected MondrianResult(mondrian.olap.Result monResult, MondrianModel model)
        throws ResultLimitExceededException {
    super(model);
    this.monResult = monResult;

    initData();
  }

  /**
   * initData creates all the wrapper objects
   */
  private void initData() throws ResultLimitExceededException {
    final int cellCountLimit = Integer.getInteger(
                                MondrianModel.CELL_LIMIT_PROP, 
                                MondrianModel.CELL_LIMIT_DEFAULT).intValue(); 

    MondrianModel mmodel = (MondrianModel) model;

    mondrian.olap.Axis[] monAxes = monResult.getAxes();
    // first step: walk through axes and add the members to the model
    int nCells = 1;
    posize = new int[monAxes.length];
    for (int i = 0; i < monAxes.length; i++) {
      List monPositions = monAxes[i].getPositions();
      int size = 0;
      int nosPositions = 0;
      int nosMembers = 0;
      Iterator pit = monPositions.iterator();
      // For the first Position, record how many Members there are.
      if (pit.hasNext()) {
        nosPositions++;
        Position position = (Position) pit.next();
        Iterator mit = position.iterator();
        while (mit.hasNext()) {
          nosMembers++;
          mmodel.addMember((Member) mit.next());
        }
        size++;
      }
      while (pit.hasNext()) {
        nosPositions++;
        Position position = (Position) pit.next();
        Iterator mit = position.iterator();
        while (mit.hasNext()) {
          mmodel.addMember((Member) mit.next());
        }
        size++;
      }

      // If there is no data on a particular axis, the table might display but
      // the axis with no data will not display. Further manipulation on the
      // table may result in NullPointerException since JPivot expects that
      // there at least be meta-data associated with every query on all
      // axes - hence we throw a controlled exception.

      // removed by av: see EmptyResultTest - thats a perfect MDX query
      // that should run w/o errors.
      //      if ((nosPositions == 0) || (nosMembers == 0)) {
      //        Query query = monResult.getQuery();
      //        String mdx = query.toMdx();
      //        throw new NoValidMemberException(i, mdx, nosPositions, nosMembers);
      //      }
      
      // check for OutOfMemory
      mmodel.checkListener();

      posize[i] = size;
      nCells = nCells * size;
    }
    mondrian.olap.Axis monSlicer = monResult.getSlicerAxis();
    List monPositions = monSlicer.getPositions();
    Iterator pit = monPositions.iterator();
    while (pit.hasNext()) {
      Position position = (Position) pit.next();
        Iterator mit = position.iterator();
        while (mit.hasNext()) {
          mmodel.addMember((Member) mit.next());
        }
        // check for OutOfMemory
        mmodel.checkListener();
    }

    if (logger.isDebugEnabled()) {
        StringBuffer buf = new StringBuffer();  
        buf.append("initData: nCells=");
        buf.append(nCells);
        logger.debug(buf.toString());
    }

    // If we are limiting the number of cells, then we do not need to
    // read them all. Rather, the number read is upto the limit plus
    // enough to finish the slice. As an example, if there are two
    // dimisions, rows and columns, then enough cells are read in
    // so that each row is complete (all columns read) but if the
    // number read in is greater than the limit, then no further rows
    // (cells) are read in.
    if ((cellCountLimit > 0) && (cellCountLimit < nCells)) {
        // How big is a slice (do not include last axis)
        int sliceSize = 1;
        for (int i = 0; i < monAxes.length - 1; i++) {
            sliceSize *= posize[i];
        }
        if (logger.isDebugEnabled()) {
            StringBuffer buf = new StringBuffer();  
            buf.append("initData: sliceSize=");
            buf.append(sliceSize);
            buf.append(", cellCountLimit=");
            buf.append(cellCountLimit);
            logger.debug(buf.toString());
        }
        if (sliceSize > cellCountLimit) {
            // One slice is bigger than can be displayed, Arrg....
            StringBuffer buf = new StringBuffer(100);
            buf.append("Can not display a single slice, exceeded cell limit(");
            buf.append(cellCountLimit);
            buf.append(") for mdx: ");
            buf.append(((MondrianQueryAdapter) mmodel.getQueryAdapter()).getMonQuery().toString());
            throw new ResourceLimitExceededException(buf.toString());
        }

        // So, how many slices should be read in
        // There is no reason to read cell in that will not be displayed;
        // this serves as a memory usage limit.
        int n = (cellCountLimit/sliceSize) + 1;
        nCells = n * sliceSize;

        if (logger.isDebugEnabled()) {
            StringBuffer buf = new StringBuffer();  
            buf.append("initData: cell limit adjusted nCells=");
            buf.append(nCells);
            logger.debug(buf.toString());
        }
    }

    // second step: create the result data
    axesList = new ArrayList();
    for (int i = 0; i < monAxes.length; i++) {
      axesList.add(new MondrianAxis(i, monAxes[i], mmodel));
      // check for OutOfMemory
      mmodel.checkListener();
    }
    slicer = new MondrianAxis(-1, monSlicer, mmodel);

    int[] iar = new int[monAxes.length];
    for (int i = 0; i < monAxes.length; i++) {
      iar[i] = 0;
    }
    for (int i = 0; i < nCells; i++) {
      mondrian.olap.Cell monCell = monResult.getCell(iar);
      MondrianCell cell = new MondrianCell(monCell, mmodel);
      cell.setFormattedValue(monCell.getFormattedValue(), formatStringParser);
      aCells.add(cell);
      if (nCells > 1) {
        // not for 0-dimensional case
        increment(iar); 
      }

      // check for OutOfMemory every 1000 cells created
      if (i % 1000 == 0) {

        // According to Java5 memory monitor are we close to running
        // out of memory.
        mmodel.checkListener();
      }
    }

  }

  /**
   * increment int array according to size of axis positions
   *  first index changes fastest
   * (0,0), (1,0) ... (NX-1, 0)
   * (0,1), (1,1) ... (NX-1, 1)
   */
  private void increment(int[] iar) {
    int nn = ++iar[0];
    // done for the 1-dimensional case
    if (iar.length > 1 && nn >= posize[0]) {
      iar[0] = 0;
      for (int i = 1; i < iar.length; i++) {
        int kk = ++iar[i];
        if (kk < posize[i])
          break;
        else
          iar[i] = 0;
      }
    }
  }

  /**
   * Returns the axes.
   * @@return Axis[]
   */
  public Axis[] getAxes() {
    if (monResult == null)
      return null; // todo error handling
    return (Axis[]) axesList.toArray(new MondrianAxis[0]);
  }

} // MondrianResult
@


1.7
log
@Created two JPivot base exception classess, JPivotException and
JPivotRuntimeException, and all JPivot exceptions now have one of
these as parent class. The mondrian JPivot code now gets its
SchemaReader from the MDX query rather than the connection so that
the query's cube's calculated members and the query's defined
"with" members can be displayed.
Also, added new JPivot exception, NoValidMemberException, which is
throw when a query returns no data on one or more axis.
Lastly, cleaned up html generated by 2 transforms.
@
text
@d98 9
a106 5
      if ((nosPositions == 0) || (nosMembers == 0)) {
        Query query = monResult.getQuery();
        String mdx = query.toMdx();
        throw new NoValidMemberException(i, mdx, nosPositions, nosMembers);
      }
@


1.6
log
@This checkin changes the behavior when the of the integer property
"com.tonbeller.jpivot.mondrian.cell.limit" is set. Previously, if a
query returned more than the non-zero value of the property, a
limit exception was thrown. Now, the TableComponent simply only
renders that number of cells (rounding up to the nearest complete row).
In addition, there is a resource property "table.cell.limit"
which is the message put at the bottom of the table so generated
which spans the final row and allows one to show both the
value of the property and the total number of cells that would
have been shown had the property not been set. This allows
one to limit the size of the table generated thus preventing
OutOfMemory errors. Also note that in MondrianResult, only the
cell limit value (rounded up) of cells are read in from Mondrian since
only that number will be displayed.
@
text
@d24 1
a27 1
import mondrian.olap.MemoryLimitExceededException;
d35 1
d69 2
d72 11
d84 1
d92 11
@


1.5
log
@The method to get the current MDX recursed (and recursed, and...)
when generating the limit exception, so getting the MDX from the Query object
was a more direct approach.
@
text
@d15 1
d33 1
d96 52
a176 10

        // Have we read in too many cells.
        if ((cellCountLimit > 0) && (cellCountLimit < aCells.size())) {
            StringBuffer buf = new StringBuffer(100);
            buf.append("Exceeded Cell limit(");
            buf.append(cellCountLimit);
            buf.append(") for mdx: ");
            buf.append(((MondrianQueryAdapter) mmodel.getQueryAdapter()).getMonQuery().toString());
            throw new ResourceLimitExceededException(buf.toString());
        }
@


1.4
log
@With this checkin one can limit the number of table cells that
JPivot attempts to render based upon a Mondrian result.
If more are returned, a limit exceeded exception is thrown.
The new JPivot property is: "com.tonbeller.jpivot.mondrian.cell.limit".
Mondrian has a property that limits how many rows of data can be read
in, but thats not sufficient. Consider, fifty thousand rows are read in
but when the axis is "NON EMPTY" only 25 are in the result versus when
"NON EMPTY" is not set on the axis and all fifty thousand are returned.
One can not rely on the Mondrian "mondrian.result.limit" property to know
what to do. So, this new property allows JPivot users to set how big
tables can be (limit is (rows * columns), total number of cells);
this limits the size of the html page that is generated.
By default, there is no limit.
@
text
@d127 1
a127 1
            buf.append("TooManyCells limit=");
d129 2
a130 2
            buf.append(" for mdx: ");
            buf.append(mmodel.getCurrentMdx());
@


1.3
log
@Now when running JPivot with a Java 1.5 or higher JVM, JPivot
uses Mondrian's Memory Manager to detect OutOfMemory
conditions and throws a mondrian.olap.MemoryLimitExceededException
prior to running out of memory (at least thats the theory).
This capability can be turned off, see the Mondrian documentation.
When running with Java 1.4 there is no change in behavior.
@
text
@d24 2
d42 1
a42 1
        throws MemoryLimitExceededException {
d52 5
a56 1
  private void initData() throws MemoryLimitExceededException {
d119 3
d123 10
@


1.2
log
@As of 01/10/07 two Mondrian classes that form part of its public API
where changed, specifically, mondrian.olap.Position and
mondrian.olap.Axis.
The build.xml file is changed because there are new jar files
required from the jpivot_repository/mondrian-HEAD directory.
Lastly, in MondrianOlapModelTag schema urls are now surrounded by
quotes so that things like ;jsessionid values can be included.
@
text
@d24 1
d39 2
a40 1
  protected MondrianResult(mondrian.olap.Result monResult, MondrianModel model) {
d50 3
a52 2
  private void initData() {
    int i, j, k;
d57 1
a57 1
    for (i = 0; i < monAxes.length; i++) {
d65 1
a65 1
          ((MondrianModel) model).addMember((Member) mit.next());
d69 3
d82 1
a82 1
          ((MondrianModel) model).addMember((Member) mit.next());
d84 2
d90 4
a93 2
    for (i = 0; i < monAxes.length; i++) {
      axesList.add(new MondrianAxis(i, monAxes[i], ((MondrianModel) model)));
d95 1
a95 1
    slicer = new MondrianAxis(-1, monSlicer, ((MondrianModel) model));
d98 1
a98 1
    for (i = 0; i < monAxes.length; i++)
d100 2
a101 1
    for (i = 0; i < nCells; i++) {
d103 1
a103 1
      MondrianCell cell = new MondrianCell(monCell, ((MondrianModel) model));
d106 9
a114 2
      if (nCells > 1)
        increment(iar); // not for 0-dimensional case
@


1.1
log
@initial version
@
text
@d16 2
d22 2
d55 8
a62 8
      mondrian.olap.Position[] monPositions = monAxes[i].positions;
      posize[i] = monPositions.length;
      nCells = nCells * monPositions.length;

      for (j = 0; j < monPositions.length; j++) {
        mondrian.olap.Member[] monMembers = monPositions[j].getMembers();
        for (k = 0; k < monMembers.length; k++) {
          ((MondrianModel) model).addMember(monMembers[k]);
d64 1
d66 2
d70 8
a77 6
    mondrian.olap.Position[] monPositions = monSlicer.positions;
    for (j = 0; j < monPositions.length; j++) {
      mondrian.olap.Member[] monMembers = monPositions[j].getMembers();
      for (k = 0; k < monMembers.length; k++) {
        ((MondrianModel) model).addMember(monMembers[k]);
      }
@

