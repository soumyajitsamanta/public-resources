head	1.5;
access;
symbols
	jpivot_1_8_0:1.5
	focus_1_6_0:1.2.0.2
	jpivot_1_7_0:1.3
	jpivot_1_6_0:1.2
	jpivot_1_5_0:1.1.0.4
	Root_jpivot_1_5_0:1.1
	mondrian_xmla_2005_08_25:1.1.0.2
	sourceforge_sync:1.2;
locks; strict;
comment	@# @;
expand	@k@;


1.5
date	2007.06.14.08.54.14;	author avix;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.09.10.43.19;	author avix;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.21.22.11.05;	author jhyde;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.09.22.24.18;	author jhyde;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.05.14.19.52;	author avix;	state Exp;
branches;
next	;


desc
@@


1.5
log
@reverted previous change because it requires further synchronization with tonbeller repository (which I dont have the time for right now).
@
text
@/*
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * Copyright (C) 2003-2004 TONBELLER AG.
 * All Rights Reserved.
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 *
 *
 */
package com.tonbeller.jpivot.mondrian;

import mondrian.olap.Exp;
import mondrian.olap.Literal;
import mondrian.olap.Syntax;
import mondrian.mdx.MemberExpr;
import mondrian.mdx.UnresolvedFunCall;

import org.apache.log4j.Logger;

import com.tonbeller.jpivot.olap.navi.SortRank;
import com.tonbeller.jpivot.olap.query.QuaxChangeListener;
import com.tonbeller.jpivot.olap.query.SortRankBase;

/**
 * @@author hh
 *
 * Implementation of the Sort Extension for Mondrian Data Source.
 */
public class MondrianSortRank extends SortRankBase implements SortRank, QuaxChangeListener {

  static Logger logger = Logger.getLogger(MondrianSortRank.class);

  public MondrianSortRank() {
    super.setId(SortRank.ID);
  }

  /**
   * apply sort to mondrian query
   */
  public void addSortToQuery() {
    if (sorting && sortPosMembers != null) {
      MondrianModel model = (MondrianModel) getModel();
      mondrian.olap.Query monQuery = ((MondrianQueryAdapter)model.getQueryAdapter()).getMonQuery();

      switch (sortMode) {
        case com.tonbeller.jpivot.olap.navi.SortRank.ASC :
        case com.tonbeller.jpivot.olap.navi.SortRank.DESC :
        case com.tonbeller.jpivot.olap.navi.SortRank.BASC :
        case com.tonbeller.jpivot.olap.navi.SortRank.BDESC :
          // call sort
          orderAxis(monQuery, sortMode);
          break;
        case com.tonbeller.jpivot.olap.navi.SortRank.TOPCOUNT :
          topBottomAxis(monQuery, "TopCount");
          break;
        case com.tonbeller.jpivot.olap.navi.SortRank.BOTTOMCOUNT :
          topBottomAxis(monQuery, "BottomCount");
          break;
        default :
          return; // do nothing
      }
    }
  }

  /**
  * Convert sort mode ordinal to sort mode name
  * @@param sortMode mode
  * @@return name of sort mode
  */
  static private String sortModeName(int sortMode) {
    switch (sortMode) {
      case com.tonbeller.jpivot.olap.navi.SortRank.ASC :
        return "ASC";
      case com.tonbeller.jpivot.olap.navi.SortRank.DESC :
        return "DESC";
      case com.tonbeller.jpivot.olap.navi.SortRank.BASC :
        return "BASC";
      case com.tonbeller.jpivot.olap.navi.SortRank.BDESC :
        return "BDESC";
      default :
        return null;
    }
  }

  /**
   * add Order Funcall to QueryAxis
   * @@param monQuery
   * @@param sortMode
   */
  private void orderAxis(mondrian.olap.Query monQuery, int sortMode) {
    // Order(TopCount) is allowed, Order(Order) is not permitted
    //removeTopLevelSort(monQuery, new String[] { "Order" });
    mondrian.olap.QueryAxis monAx = monQuery.getAxes()[quaxToSort.getOrdinal()];
    Exp setForAx = monAx.getSet();
    Exp memToSort;
    if (sortPosMembers.length == 1) {
      memToSort = new MemberExpr(((MondrianMember) sortPosMembers[0]).getMonMember());
    } else {
      MemberExpr[] memberExprs = new MemberExpr[sortPosMembers.length];
      for (int i = 0; i < memberExprs.length; i++) {
        memberExprs[i] = new MemberExpr(((MondrianMember) sortPosMembers[i]).getMonMember());
      }
      memToSort = new UnresolvedFunCall("()", Syntax.Parentheses, memberExprs);
    }
    String sDirection = sortModeName(sortMode);
    UnresolvedFunCall funOrder =
      new UnresolvedFunCall("Order", new Exp[] { setForAx, memToSort, Literal.createSymbol(sDirection)});
    monAx.setSet(funOrder);
  }

  /**
   * add Top/BottomCount Funcall to QueryAxis
   */
  private void topBottomAxis(mondrian.olap.Query monQuery, String function) {
    // TopCount(TopCount) and TopCount(Order) is not permitted
    //removeTopLevelSort(monQuery, new String[] { "TopCount", "BottomCount", "Order" });
    mondrian.olap.QueryAxis monAx = monQuery.getAxes()[quaxToSort.getOrdinal()];
    Exp setForAx = monAx.getSet();
    Exp memToSort;
    if (sortPosMembers.length > 1) {
      MemberExpr[] memberExprs = new MemberExpr[sortPosMembers.length];
      for (int i = 0; i < memberExprs.length; i++) {
        memberExprs[i] = new MemberExpr(((MondrianMember) sortPosMembers[i]).getMonMember());
      }
      memToSort = new UnresolvedFunCall("()", Syntax.Parentheses, memberExprs);
    } else {
      memToSort = new MemberExpr(((MondrianMember) sortPosMembers[0]).getMonMember());
    }
    UnresolvedFunCall funOrder =
      new UnresolvedFunCall(
        function,
        new Exp[] { setForAx, Literal.create(new Integer(topBottomCount)), memToSort });
    monAx.setSet(funOrder);
  }

  /**
   * remove top level sort functions from query axis
   * @@param monAx
   * @@param functions
   */
  /* not neeeded as of MDX generation version 3
   private void removeTopLevelSort(mondrian.olap.Query monQuery, String[] functions) {
     // if the original MDX starts with a sort function, remove it from current query
     Exp originalSet = quaxToSort.getOriginalSet();
     if (!(originalSet instanceof FunCall))
       return;
     FunCall topF = (FunCall) originalSet;
     String fuName = topF.getFunName();
     boolean found = false;
     for (int i = 0; i < functions.length; i++) {
       if (functions[i].equalsIgnoreCase(fuName)) {
         found = true;
         break;
       }
     }
     if (!found)
       return;

     // remove sort function from current set
     mondrian.olap.QueryAxis monAx = monQuery.axes[quaxToSort.getOrdinal()];
     Exp setForAx = monAx.set;
     Exp exp = setForAx;
     FunCall parent = null;
     while (exp instanceof FunCall) {
       // we skip over Hierarchize and Union, which was added by navigation
       FunCall f = (FunCall) exp;
       String currentName = f.getFunName();
       if (currentName.equalsIgnoreCase("Hierarchize") || currentName.equalsIgnoreCase("Union")) {
         // skip over
         parent = f;
         exp = f.args[0]; // first arg leads to original set
       } else if (currentName.equalsIgnoreCase(fuName)) {
         // remove it
         if (parent == null)
           monAx.set = f.args[0];
         else
           parent.args[0] = f.args[0];
         return;
       } else
         return; // should never get here
     }
   }
  */

} // End MondrianSortRank
@


1.4
log
@improve sort handling if quax is *not* used
@
text
@a14 2
import mondrian.mdx.MemberExpr;
import mondrian.mdx.UnresolvedFunCall;
a15 1
import mondrian.olap.FunCall;
d18 2
d46 1
a46 1
      mondrian.olap.Query monQuery = ((MondrianQueryAdapter) model.getQueryAdapter()).getMonQuery();
d49 15
a63 18
      case com.tonbeller.jpivot.olap.navi.SortRank.ASC:
      case com.tonbeller.jpivot.olap.navi.SortRank.DESC:
      case com.tonbeller.jpivot.olap.navi.SortRank.BASC:
      case com.tonbeller.jpivot.olap.navi.SortRank.BDESC:
        // call sort
        orderAxis(monQuery, sortMode);
        bSortOnQuery = true;
        break;
      case com.tonbeller.jpivot.olap.navi.SortRank.TOPCOUNT:
        topBottomAxis(monQuery, "TopCount");
        bSortOnQuery = true;
        break;
      case com.tonbeller.jpivot.olap.navi.SortRank.BOTTOMCOUNT:
        topBottomAxis(monQuery, "BottomCount");
        bSortOnQuery = true;
        break;
      default:
        return; // do nothing
d69 18
a86 18
   * Convert sort mode ordinal to sort mode name
   * @@param sortMode mode
   * @@return name of sort mode
   */
   static private String sortModeName(int sortMode) {
     switch (sortMode) {
       case com.tonbeller.jpivot.olap.navi.SortRank.ASC :
         return "ASC";
       case com.tonbeller.jpivot.olap.navi.SortRank.DESC :
         return "DESC";
       case com.tonbeller.jpivot.olap.navi.SortRank.BASC :
         return "BASC";
       case com.tonbeller.jpivot.olap.navi.SortRank.BDESC :
         return "BDESC";
       default :
         return null;
     }
   }
d109 2
a110 2
    UnresolvedFunCall funOrder = new UnresolvedFunCall("Order", new Exp[] { setForAx, memToSort,
        Literal.createSymbol(sDirection)});
d132 4
a135 2
    UnresolvedFunCall funOrder = new UnresolvedFunCall(function, new Exp[] { setForAx,
        Literal.create(new Integer(topBottomCount)), memToSort});
d140 3
a142 1
   * remove sort function from query axis
d144 43
a186 19
  public void removeTopLevelSort() {
    if (!bSortOnQuery)
      return;
    MondrianModel model = (MondrianModel) getModel();
    mondrian.olap.Query monQuery = ((MondrianQueryAdapter) model.getQueryAdapter()).getMonQuery();
    mondrian.olap.QueryAxis monAx = monQuery.getAxes()[quaxToSort.getOrdinal()];
    Exp setForAx = monAx.getSet();
    // if the axis set is *not* a Ordering function, return
    if (!(setForAx instanceof FunCall))
      return;
    FunCall funOrder = (FunCall) setForAx;
    String funame = funOrder.getFunName();
    if ("Order".equalsIgnoreCase(funame) || "TopCount".equalsIgnoreCase(funame)
        || "BottomCount".equalsIgnoreCase(funame)) {
      Exp set0 = funOrder.getArg(0);
      monAx.setSet(set0);
      bSortOnQuery = false;
    }
  }
@


1.3
log
@Obsolete mondrian.olap.SortDirection
@
text
@d15 2
d18 1
a20 2
import mondrian.mdx.MemberExpr;
import mondrian.mdx.UnresolvedFunCall;
d47 1
a47 1
      mondrian.olap.Query monQuery = ((MondrianQueryAdapter)model.getQueryAdapter()).getMonQuery();
d50 18
a67 15
        case com.tonbeller.jpivot.olap.navi.SortRank.ASC :
        case com.tonbeller.jpivot.olap.navi.SortRank.DESC :
        case com.tonbeller.jpivot.olap.navi.SortRank.BASC :
        case com.tonbeller.jpivot.olap.navi.SortRank.BDESC :
          // call sort
          orderAxis(monQuery, sortMode);
          break;
        case com.tonbeller.jpivot.olap.navi.SortRank.TOPCOUNT :
          topBottomAxis(monQuery, "TopCount");
          break;
        case com.tonbeller.jpivot.olap.navi.SortRank.BOTTOMCOUNT :
          topBottomAxis(monQuery, "BottomCount");
          break;
        default :
          return; // do nothing
d73 18
a90 18
  * Convert sort mode ordinal to sort mode name
  * @@param sortMode mode
  * @@return name of sort mode
  */
  static private String sortModeName(int sortMode) {
    switch (sortMode) {
      case com.tonbeller.jpivot.olap.navi.SortRank.ASC :
        return "ASC";
      case com.tonbeller.jpivot.olap.navi.SortRank.DESC :
        return "DESC";
      case com.tonbeller.jpivot.olap.navi.SortRank.BASC :
        return "BASC";
      case com.tonbeller.jpivot.olap.navi.SortRank.BDESC :
        return "BDESC";
      default :
        return null;
    }
  }
d113 2
a114 2
    UnresolvedFunCall funOrder =
      new UnresolvedFunCall("Order", new Exp[] { setForAx, memToSort, Literal.createSymbol(sDirection)});
d136 2
a137 4
    UnresolvedFunCall funOrder =
      new UnresolvedFunCall(
        function,
        new Exp[] { setForAx, Literal.create(new Integer(topBottomCount)), memToSort });
d142 1
a142 3
   * remove top level sort functions from query axis
   * @@param monAx
   * @@param functions
d144 19
a162 43
  /* not neeeded as of MDX generation version 3
   private void removeTopLevelSort(mondrian.olap.Query monQuery, String[] functions) {
     // if the original MDX starts with a sort function, remove it from current query
     Exp originalSet = quaxToSort.getOriginalSet();
     if (!(originalSet instanceof FunCall))
       return;
     FunCall topF = (FunCall) originalSet;
     String fuName = topF.getFunName();
     boolean found = false;
     for (int i = 0; i < functions.length; i++) {
       if (functions[i].equalsIgnoreCase(fuName)) {
         found = true;
         break;
       }
     }
     if (!found)
       return;

     // remove sort function from current set
     mondrian.olap.QueryAxis monAx = monQuery.axes[quaxToSort.getOrdinal()];
     Exp setForAx = monAx.set;
     Exp exp = setForAx;
     FunCall parent = null;
     while (exp instanceof FunCall) {
       // we skip over Hierarchize and Union, which was added by navigation
       FunCall f = (FunCall) exp;
       String currentName = f.getFunName();
       if (currentName.equalsIgnoreCase("Hierarchize") || currentName.equalsIgnoreCase("Union")) {
         // skip over
         parent = f;
         exp = f.args[0]; // first arg leads to original set
       } else if (currentName.equalsIgnoreCase(fuName)) {
         // remove it
         if (parent == null)
           monAx.set = f.args[0];
         else
           parent.args[0] = f.args[0];
         return;
       } else
         return; // should never get here
     }
   }
  */
@


1.2
log
@Match Mondrian API updates for compiled expressions (up to change 4994)
@
text
@a16 1
import mondrian.olap.SortDirection;
d54 1
a54 2
          int monSortMode = sortMode2Mondrian(sortMode);
          orderAxis(monQuery, monSortMode);
d69 3
a71 3
  * convert sort mode to mondrian
  * @@param sortMode mode according to JPivot
  * @@return sort mode according to Mondrian
d73 1
a73 1
  static private int sortMode2Mondrian(int sortMode) {
d76 1
a76 1
        return mondrian.olap.SortDirection.ASC;
d78 1
a78 1
        return mondrian.olap.SortDirection.DESC;
d80 1
a80 1
        return mondrian.olap.SortDirection.BASC;
d82 1
a82 1
        return mondrian.olap.SortDirection.BDESC;
d84 1
a84 1
        return mondrian.olap.SortDirection.NONE; // should not happen
d91 1
a91 1
   * @@param monSortMode
d93 1
a93 1
  private void orderAxis(mondrian.olap.Query monQuery, int monSortMode) {
d108 1
a108 1
    String sDirection = SortDirection.instance().getName(monSortMode);
@


1.1
log
@initial version
@
text
@d11 1
a11 1
 * 
a15 1
import mondrian.olap.FunCall;
d19 2
d72 1
a72 1
  * @@param sort mode according to JPivot
d92 1
a92 1
   * @@param monAx
d102 1
a102 1
      memToSort = ((MondrianMember) sortPosMembers[0]).getMonMember();
d104 3
a106 3
      mondrian.olap.Member[] monMembers = new mondrian.olap.Member[sortPosMembers.length];
      for (int i = 0; i < monMembers.length; i++) {
        monMembers[i] = ((MondrianMember) sortPosMembers[i]).getMonMember();
d108 1
a108 1
      memToSort = new FunCall("()", Syntax.Parentheses, monMembers);
d111 2
a112 2
    FunCall funOrder =
      new FunCall("Order", new Exp[] { setForAx, memToSort, Literal.createSymbol(sDirection)});
a117 2
   * @@param monAx
   * @@param nShow
d126 3
a128 3
      mondrian.olap.Member[] monMembers = new mondrian.olap.Member[sortPosMembers.length];
      for (int i = 0; i < monMembers.length; i++) {
        monMembers[i] = ((MondrianMember) sortPosMembers[i]).getMonMember();
d130 1
a130 1
      memToSort = new FunCall("()", Syntax.Parentheses, monMembers);
d132 1
a132 1
      memToSort = ((MondrianMember) sortPosMembers[0]).getMonMember();
d134 2
a135 2
    FunCall funOrder =
      new FunCall(
d163 1
a163 1
  
@

