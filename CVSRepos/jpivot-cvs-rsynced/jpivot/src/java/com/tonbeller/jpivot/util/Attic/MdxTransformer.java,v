head	1.1;
access;
symbols
	focus_1_6_0:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2008.04.17.10.44.55;	author hbaier;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2008.04.17.10.44.56;	author hbaier;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2008.05.19.06.13.47;	author kunarief;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file MdxTransformer.java was initially added on branch focus_1_6_0.
@
text
@@


1.1.2.1
log
@* merged focus changes of jpivot into focus_1_6_0
@
text
@a0 179
package com.tonbeller.jpivot.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;

import java_cup.runtime.Symbol;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;
import com.tonbeller.jpivot.olap.mdxparse.CompoundId;
import com.tonbeller.jpivot.olap.mdxparse.Exp;
import com.tonbeller.jpivot.olap.mdxparse.Formula;
import com.tonbeller.jpivot.olap.mdxparse.FunCall;
import com.tonbeller.jpivot.olap.mdxparse.Lexer;
import com.tonbeller.jpivot.olap.mdxparse.Literal;
import com.tonbeller.jpivot.olap.mdxparse.MemberProperty;
import com.tonbeller.jpivot.olap.mdxparse.ParsedQuery;
import com.tonbeller.jpivot.olap.mdxparse.QueryAxis;
import com.tonbeller.jpivot.olap.mdxparse.parser;

public class MdxTransformer {

	private static final String DIR = "/com/tonbeller/jpivot/util/xslt/";
	public static final String ROWS = "ROWS";
	public static final String COLUMNS = "COLUMNS";

	public static String applyVisualTotalsOnAxis(String mdxQuery, String axis) {
		ParsedQuery parsedQuery = parse(removeVisualTotals(mdxQuery));
		QueryAxis[] axes = parsedQuery.getAxes();
		for (int i = 0; i < axes.length; i++) {
			QueryAxis queryAxis = axes[i];
			if(axis.equals(queryAxis.getName())) {
				String xml = getXStream().toXML(queryAxis);
				xml = processXml(xml, "visualTotals.xsl");
				QueryAxis queryAxisWithVisualTotals = (QueryAxis) xmlToExp(xml);
				axes[i] = queryAxisWithVisualTotals;
			}
		}

		return parsedQuery.toMdx();
	}

	public static String applyVisualTotals(String mdxQuery, boolean append) {
		mdxQuery = removeVisualTotals(mdxQuery);
		if(append) {
			mdxQuery = appendVisualTotals(mdxQuery);
		}
		return mdxQuery;
	}

	private static String removeVisualTotals(String mdxQuery) {
		String result = applyXsltOntoMdx(mdxQuery, "removeVisualTotals.xsl");
		return result;
	}

	public static String removeHierarchize(String mdxQuery) {
		String result = applyXsltOntoMdx(mdxQuery, "removeHierarchize.xsl");
		return result;
	}

	private static String appendVisualTotals(String mdxQuery) {
		return applyXsltOntoMdx(mdxQuery, "visualTotals.xsl");
	}

	private static String applyXsltOntoMdx(String mdxQuery, String xslt) {
		String xml = mdxToXml(mdxQuery);
		xml = processXml(xml, xslt);
		return xmlToMdx(xml);
	}

	private static String processXml(String xml, String xslt) {
		ByteArrayInputStream xmlInputStream = new ByteArrayInputStream(xml.getBytes());
		StreamSource xmlSource = new StreamSource(xmlInputStream);

		InputStream resourceAsStream = MdxTransformer.class.getResourceAsStream(DIR + xslt);
		Source xsltSource = new StreamSource(resourceAsStream);

		ByteArrayOutputStream bos = new ByteArrayOutputStream();

		TransformerFactory transFact = TransformerFactory.newInstance();

		try {
			Transformer trans = transFact.newTransformer(xsltSource);
			Result result = new StreamResult(bos);
			trans.transform(xmlSource, result);
		} catch(TransformerException e) {
			throw new RuntimeException(e);
		}

		return bos.toString();
	}

	private static Exp xmlToExp(String xml) {
		Exp exp = (Exp) getXStream().fromXML(xml);
		return exp;
	}

	private static String xmlToMdx(String xml) {
		final String mdx = xmlToExp(xml).toMdx();
		return mdx;
	}

	private static String mdxToXml(String mdxQuery) {
		XStream xstream = getXStream();
		ParsedQuery query;
		try {
			query = parse(mdxQuery);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		String xml = xstream.toXML(query);
		return xml;
	}

	public static ParsedQuery parse(String mdxQuery) {
		// parse the query string
		parser parser_obj;
		Reader reader = new StringReader(mdxQuery);
		parser_obj = new parser(new Lexer(reader));

		Symbol parse_tree = null;
		ParsedQuery pQuery = null;
		try {
			parse_tree = parser_obj.parse();
			pQuery = (ParsedQuery) parse_tree.value;
			pQuery.afterParse();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		// this keeps FunCall to replace parameters with its values
		pQuery.getParaMap().clear();

		return pQuery;
	}

	private static XStream xstream = null;

	protected static XStream getXStream() {
		if (xstream == null) {
			xstream = new XStream(new DomDriver());
			xstream.alias("CompoundId", CompoundId.class);
			xstream.addImplicitCollection(CompoundId.class, "names");

			final Class namePartClass = CompoundId.class.getDeclaredClasses()[0];
			xstream.alias("NamePart", namePartClass);
			xstream.useAttributeFor(namePartClass, "name");
			xstream.useAttributeFor(namePartClass, "isKey");
			xstream.alias("QueryAxis", QueryAxis.class);
			xstream.useAttributeFor(QueryAxis.class, "name");
			xstream.useAttributeFor(QueryAxis.class, "nonEmpty");
			xstream.alias("Formula", Formula.class);
			xstream.useAttributeFor(Formula.class, "isMember");
			xstream.alias("FunCall", FunCall.class);
			xstream.omitField(FunCall.class, "pQuery");
			// xstream.addImplicitCollection(FunCall.class, "args");
			xstream.useAttributeFor(FunCall.class, "syntacticType");
			xstream.useAttributeFor(FunCall.class, "function");
			xstream.alias("Literal", Literal.class);
			xstream.useAttributeFor(Literal.class, "type");
			xstream.alias("MemberProperty", MemberProperty.class);
			xstream.useAttributeFor(MemberProperty.class, "name");
			xstream.alias("ParsedQuery", ParsedQuery.class);
		}
		return xstream;
	}

}
@


1.1.2.2
log
@* adding feature for hidden member selection
@
text
@a7 5
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.io.UnsupportedEncodingException;

d12 1
a18 2
import org.apache.log4j.Logger;

d33 1
a33 1
	private static Logger logger = Logger.getLogger(MdxTransformer.class);
d83 1
a83 9
		ByteArrayInputStream xmlInputStream;

		try {
			xmlInputStream = new ByteArrayInputStream(xml.getBytes("UTF-8"));
		} catch (UnsupportedEncodingException e) {
			logger.error(e);
			throw new RuntimeException(e);
		}

d86 2
a87 3
		InputStream resourceAsStream = MdxTransformer.class
				.getResourceAsStream(DIR + xslt);
		StreamSource xsltSource = new StreamSource(resourceAsStream);
d89 1
a89 15
		return applyXsltOnXml(xmlSource, xsltSource, new HashMap());
	}

	public static String applyXsltOnXml(String xml, StreamSource xsltSource, Map parameters) {
		ByteArrayInputStream xmlInputStream = new ByteArrayInputStream(xml
				.getBytes());
		StreamSource xmlSource = new StreamSource(xmlInputStream);

		return applyXsltOnXml(xmlSource, xsltSource, parameters);
	}

	public static String applyXsltOnXml(StreamSource xmlSource,
			StreamSource xsltSource, Map parameters) {

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
d95 1
a95 2
			setXslParameters(trans, parameters);
			Result result = new StreamResult(outputStream);
a97 9
			logger.error("Error occurred while XSL-transforming the following XML : '\n"
					+ xmlSource + "'\nwith the following XSLT: '" + xsltSource + "\n'", e);
			throw new RuntimeException(e);
		}

		try {
			return outputStream.toString("UTF-8");
		} catch (UnsupportedEncodingException e) {
			logger.error(e);
a99 1
	}
d101 1
a101 6
	private static void setXslParameters(Transformer transformer, Map parameters) {
		for (Iterator it = parameters.keySet().iterator(); it.hasNext();) {
			String name = (String) it.next();
			Object value = parameters.get(name);
			transformer.setParameter(name, value);
		}
a138 1
			logger.error("Error occurred while parsing the following mdx:'\n" + mdxQuery + "'\n", e);
@


